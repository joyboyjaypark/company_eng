import tkinter as tk
from tkinter import ttk, simpledialog, messagebox, filedialog
from math import sqrt, ceil
import math
import json
import sys

# Shapely 관련 import
from shapely.geometry import Polygon, LineString, Point
from shapely.ops import unary_union, polygonize
import re
import os

# HVAC type names
HVAC_NAMES = {
    1: "중앙공조",
    2: "개별공조",
    3: "비공조",
}


class RectShape:
    """하나의 직사각형 도형 + 치수 정보를 관리하는 클래스"""
    def __init__(self, shape_id, coords, rect_id, side_ids, dim_items,
                 editable=True, color="black"):
        self.shape_id = shape_id
        self.coords = coords          # (x1, y1, x2, y2)
        self.rect_id = rect_id        # canvas rectangle id
        self.side_ids = side_ids      # {"top": line_id, ...}
        self.dim_items = dim_items    # {"top": {...}, "left": {...}}
        self.editable = editable
        self.color = color
        self.snap_highlight_sides = set()  # 스냅으로 강조된 변 이름들


class Palette:
    """팔레트 하나(캔버스)와 그 안의 모든 도형/동작을 관리하는 클래스"""

    def __init__(self, parent, app, width=900, height=600):
        # Initialize basic properties and canvas
        self.app = app
        self.canvas = tk.Canvas(parent, bg="white", width=width, height=height)
        self.canvas.pack(fill=tk.BOTH, expand=True)

        # 상태
        self.shapes = []
        self.next_shape_id = 1
        self.scale = 20.0  # 1m = 20px
        self.unit = "m"

        # rectangle selection state
        self.rect_select_start = None
        self.rect_select_id = None
        self.rect_draw_canvas = None
        self.rect_draw_total = False
        self.rect_selecting = False
        self.selected_points = set()

        # drag / editing state
        self.active_shape = None
        self.active_side_name = None
        self.drag_start_mouse_pos = None
        self.drag_start_coords = None

        # corner/move state
        self.corner_snap_tolerance = 8
        self.corner_highlight_id = None
        self.corner_hover_shape = None
        self.corner_hover_index = None
        self.moving_shape = None
        self.move_start_mouse_pos = None
        self.move_start_shape_coords = None

        # highlight / tooltip state
        self.highlight_line_id = None
        self.tooltip_id = None
        self.flow_tooltip_id = None
        self.flow_tooltip_canvas = None

        # panning
        self.panning = False
        self.pan_last_pos = None

        # snap and undo
        self.snap_tolerance = 8
        self.history = []

        # corner right-click menu
        self.corner_menu = tk.Menu(self.canvas, tearoff=0)
        try:
            self.corner_menu.add_command(label="삭제하기", command=self.delete_corner_shape)
        except Exception:
            pass
        self.corner_menu_target_shape = None

        # autogenerated space labels
        self.generated_space_labels = []

        # grid state
        self.grid_ids = []
        self.show_grid = True
        self._grid_redraw_after_id = None

        # event bindings
        try:
            self.canvas.bind("<Motion>", self.on_mouse_move)
            self.canvas.bind("<ButtonPress-1>", self.on_left_down)
            self.canvas.bind("<B1-Motion>", self.on_left_drag)
            self.canvas.bind("<ButtonRelease-1>", self.on_left_up)
            self.canvas.bind("<ButtonPress-3>", self.on_right_click)
            self.canvas.bind("<MouseWheel>", self.on_mouse_wheel)
            self.canvas.bind("<Button-4>", self.on_mouse_wheel_linux)
            self.canvas.bind("<Button-5>", self.on_mouse_wheel_linux)
            self.canvas.bind("<ButtonPress-2>", self.on_middle_button_down)
            self.canvas.bind("<B2-Motion>", self.on_middle_button_drag)
            self.canvas.bind("<ButtonRelease-2>", self.on_middle_button_up)
            self.canvas.tag_bind("dim_width", "<Button-1>", self.on_dim_width_click)
            self.canvas.tag_bind("dim_height", "<Button-1>", self.on_dim_height_click)
            self.canvas.tag_bind("space_name", "<Button-1>", self.on_space_name_click)
            self.canvas.tag_bind("space_heat_norm", "<Button-1>", self.on_space_heat_norm_click)
            self.canvas.tag_bind("space_heat_equip", "<Button-1>", self.on_space_heat_equip_click)
            self.canvas.bind("<Configure>", self._on_canvas_configure)
        except Exception:
            pass

        try:
            self.canvas.after(50, self.draw_grid)
        except Exception:
            pass

        # Overlay canvas for transient UI (try to create an overlay; fallback to main canvas)
        try:
            self.overlay = tk.Canvas(parent, bg='', highlightthickness=0)
            try:
                self.overlay.place(in_=self.canvas, relx=0, rely=0, relwidth=1, relheight=1)
                try:
                    self.overlay.lift(self.canvas)
                except Exception:
                    try:
                        self.overlay.lift()
                    except Exception:
                        pass
            except Exception:
                try:
                    self.overlay.place(relx=0, rely=0, relwidth=1, relheight=1)
                    try:
                        self.overlay.lift(self.canvas)
                    except Exception:
                        pass
                except Exception:
                    pass
        except Exception:
            self.overlay = self.canvas

        # total overlay Toplevel state
        self.total_overlay_toplevel = None
        self.total_overlay_canvas = None
        self.total_overlay_rect_id = None
        self.use_total_overlay = False
        # Do NOT force a visible, topmost overlay by default —
        # a topmost overlay can cover modal dialogs (hide buttons).
        self._force_visible_overlay = False
        # Do not auto-enable the total overlay; enable it explicitly when needed.

    def _to_overlay_coords(self, event):
        try:
            cx = self.canvas.winfo_rootx()
            cy = self.canvas.winfo_rooty()
            return (event.x_root - cx, event.y_root - cy)
        except Exception:
            return (event.x, event.y)

    def _drawing_canvas(self):
        """Return the canvas object to draw transient UI on.

        If total overlay is enabled and available, return that canvas with
        coordinates in screen-relative space; otherwise return the in-app overlay.
        """
        # For visibility and reliability, draw on the main canvas by default.
        # The overlay machinery exists but some platforms/window managers
        # don't reliably show an overlaid Toplevel; drawing directly on
        # the main canvas is the most portable and visible approach.
        return self.canvas, False

    def _create_total_overlay(self):
        """Create a top-level transparent overlay exactly over the main canvas."""
        if getattr(self, 'total_overlay_toplevel', None):
            return
        try:
            root = self.canvas.winfo_toplevel()
            x = self.canvas.winfo_rootx()
            y = self.canvas.winfo_rooty()
            w = max(1, self.canvas.winfo_width())
            h = max(1, self.canvas.winfo_height())
            top = tk.Toplevel(root)
            top.overrideredirect(True)
            try:
                # Only make the overlay topmost when explicitly forcing visible
                if getattr(self, '_force_visible_overlay', False):
                    top.wm_attributes("-topmost", True)
            except Exception:
                pass
            # Position and size to match the canvas on screen
            try:
                top.geometry(f"{w}x{h}+{x}+{y}")
            except Exception:
                try:
                    top.geometry(f"{w}x{h}")
                except Exception:
                    pass
            # Use a transparent background color for Windows
            try:
                top.wm_attributes("-transparentcolor", "#ff00ff")
                overlay_bg = '#ff00ff'
            except Exception:
                overlay_bg = ''

            # If forcing visible overlay for debug, use a visible background
            if getattr(self, '_force_visible_overlay', False):
                overlay_bg = 'lightgrey'

            canvas = tk.Canvas(top, bg=overlay_bg or '', highlightthickness=0)
            canvas.pack(fill=tk.BOTH, expand=True)
            self.total_overlay_toplevel = top
            self.total_overlay_canvas = canvas
        except Exception:
            self.total_overlay_toplevel = None
            self.total_overlay_canvas = None

    def enable_total_overlay(self, enable: bool = True):
        """Enable or disable the total overlay. When enabled, the rubber-band rectangle
        will be drawn on a top-level transparent window above the application.
        """
        self.use_total_overlay = bool(enable)
        if self.use_total_overlay:
            self._create_total_overlay()
        else:
            self._destroy_total_overlay()

    def _destroy_total_overlay(self):
        try:
            if getattr(self, 'total_overlay_toplevel', None):
                try:
                    self.total_overlay_toplevel.destroy()
                except Exception:
                    pass
            self.total_overlay_toplevel = None
            self.total_overlay_canvas = None
            self.total_overlay_rect_id = None
        except Exception:
            pass

    # -------- 기본 유틸 --------

    def pixel_to_meter(self, length_px: float) -> float:
        return length_px / self.scale

    def meter_to_pixel(self, length_m: float) -> float:
        return length_m * self.scale

    def _on_canvas_configure(self, event=None):
        if getattr(self, 'show_grid', False):
            try:
                self.draw_grid()
            except Exception:
                pass

    def clear_grid(self):
        for gid in list(getattr(self, 'grid_ids', [])):
            try:
                self.canvas.delete(gid)
            except Exception:
                pass
        self.grid_ids = []

    def toggle_grid(self, show: bool):
        """Show or hide the grid. If showing, draw it for current viewport."""
        self.show_grid = bool(show)
        if self.show_grid:
            try:
                self.draw_grid()
            except Exception:
                pass
        else:
            try:
                self.clear_grid()
            except Exception:
                pass

    def draw_grid(self):
        """Viewport-limited 0.5m grid. Coarsen spacing if too many lines to avoid UI freeze."""
        # remove old grid
        try:
            self.clear_grid()
        except Exception:
            self.grid_ids = []

        # get widget size
        try:
            w = int(self.canvas.winfo_width())
            h = int(self.canvas.winfo_height())
        except Exception:
            w = int(self.canvas['width']) if 'width' in self.canvas.keys() else 800
            h = int(self.canvas['height']) if 'height' in self.canvas.keys() else 600

        # spacing in pixels for 0.5m
        spacing = max(1.0, self.meter_to_pixel(0.5))

        # visible region
        try:
            view_left = self.canvas.canvasx(0)
            view_top = self.canvas.canvasy(0)
            view_right = self.canvas.canvasx(w)
            view_bottom = self.canvas.canvasy(h)
        except Exception:
            view_left, view_top, view_right, view_bottom = 0.0, 0.0, float(w), float(h)

        # small margin to avoid tiny gaps (use larger margin to tolerate pan/rounding)
        MARGIN_MULT = 2
        view_left -= spacing * MARGIN_MULT
        view_top -= spacing * MARGIN_MULT
        view_right += spacing * MARGIN_MULT
        view_bottom += spacing * MARGIN_MULT

        import math
        # Anchor grid to a stable reference so it stays aligned with shapes after zoom/pan.
        # Use first shape's top-left as anchor if available, otherwise use world origin (0,0).
        try:
            if self.shapes:
                anchor_x = float(self.shapes[0].coords[0])
                anchor_y = float(self.shapes[0].coords[1])
            else:
                anchor_x = 0.0
                anchor_y = 0.0
        except Exception:
            anchor_x = 0.0
            anchor_y = 0.0

        # compute remainder offset so anchor_x == (k*spacing + rem_x)
        rem_x = anchor_x - math.floor(anchor_x / spacing) * spacing
        rem_y = anchor_y - math.floor(anchor_y / spacing) * spacing

        kmin = math.floor((view_left - rem_x) / spacing)
        kmax = math.ceil((view_right - rem_x) / spacing)
        hmin = math.floor((view_top - rem_y) / spacing)
        hmax = math.ceil((view_bottom - rem_y) / spacing)

        v_count = max(0, int(kmax - kmin + 1))
        h_count = max(0, int(hmax - hmin + 1))

        # cap total lines to avoid freezing
        MAX_LINES = 1200
        total = v_count + h_count
        while total > MAX_LINES and spacing < max(w, h):
            spacing *= 2
            kmin = math.floor(view_left / spacing)
            kmax = math.ceil(view_right / spacing)
            hmin = math.floor(view_top / spacing)
            hmax = math.ceil(view_bottom / spacing)
            v_count = max(0, int(kmax - kmin + 1))
            h_count = max(0, int(hmax - hmin + 1))
            total = v_count + h_count

        color = "#e6e6e6"
        # draw vertical lines
        for k in range(kmin, kmax + 1):
            x = k * spacing + rem_x
            try:
                lid = self.canvas.create_line(x, view_top, x, view_bottom, fill=color, width=1, tags=("grid",))
                self.grid_ids.append(lid)
            except Exception:
                continue

        # draw horizontal lines
        for k in range(hmin, hmax + 1):
            y = k * spacing + rem_y
            try:
                lid = self.canvas.create_line(view_left, y, view_right, y, fill=color, width=1, tags=("grid",))
                self.grid_ids.append(lid)
            except Exception:
                continue

        try:
            self.canvas.tag_lower("grid")
        except Exception:
            pass

    def push_history(self):
        snapshot = {
            "scale": self.scale,
            "next_shape_id": self.next_shape_id,
            "shapes": [],
            "generated_space_labels": []
        }
        for s in self.shapes:
            snapshot["shapes"].append({
                "shape_id": s.shape_id,
                "coords": tuple(s.coords),
                "editable": s.editable,
                "color": s.color
            })

        # 자동생성 라벨 저장 (디퓨저 위치 포함)
        for lab in self.generated_space_labels:
            name_bbox = self.canvas.bbox(lab["name_id"])
            heat_norm_bbox = self.canvas.bbox(lab["heat_norm_id"])
            heat_equip_bbox = self.canvas.bbox(lab["heat_equip_id"])
            area_bbox = self.canvas.bbox(lab["area_id"])
            
            # 디퓨저 좌표 저장
            diffuser_coords = []
            if "diffuser_ids" in lab:
                for did in lab["diffuser_ids"]:
                    coords = self.canvas.coords(did)
                    if coords:
                        # oval coords (x1, y1, x2, y2) -> center (cx, cy)
                        cx = (coords[0] + coords[2]) / 2
                        cy = (coords[1] + coords[3]) / 2
                        diffuser_coords.append((cx, cy))

            snapshot["generated_space_labels"].append({
                "polygon_coords": list(lab["polygon"].exterior.coords),
                "name_text": self.canvas.itemcget(lab["name_id"], "text"),
                "heat_norm_text": self.canvas.itemcget(lab["heat_norm_id"], "text"),
                "heat_equip_text": self.canvas.itemcget(lab["heat_equip_id"], "text"),
                "area_text": self.canvas.itemcget(lab["area_id"], "text"),
                "name_pos": name_bbox,
                "heat_norm_pos": heat_norm_bbox,
                "heat_equip_pos": heat_equip_bbox,
                "area_pos": area_bbox,
                "diffuser_coords": diffuser_coords
            })

        self.history.append(snapshot)

    def undo(self):
        if not self.history:
            return

        snapshot = self.history.pop()
        self.canvas.delete("all")
        self.shapes.clear()
        self.generated_space_labels.clear()
        self.highlight_line_id = None
        self.tooltip_id = None
        self.corner_highlight_id = None

        self.scale = snapshot["scale"]
        self.next_shape_id = snapshot["next_shape_id"]

        # 도형 복원
        for info in snapshot["shapes"]:
            s = self.create_rect_shape(
                info["coords"][0], info["coords"][1],
                info["coords"][2], info["coords"][3],
                editable=info["editable"],
                color=info["color"],
                push_to_history=False
            )
            s.shape_id = info["shape_id"]

        # 공간 라벨 복원
        for lab in snapshot["generated_space_labels"]:
            poly = Polygon(lab["polygon_coords"])
            if not lab["name_pos"]:
                continue

            x1, y1, x2, y2 = lab["name_pos"]
            name_id = self.canvas.create_text(
                (x1 + x2) / 2, (y1 + y2) / 2,
                text=lab["name_text"], fill="blue", font=("Arial", 11, "bold"),
                tags=("space_name",)
            )

            hx1, hy1, hx2, hy2 = lab["heat_norm_pos"]
            heat_norm_id = self.canvas.create_text(
                (hx1 + hx2) / 2, (hy1 + hy2) / 2,
                text=lab["heat_norm_text"], fill="darkred", font=("Arial", 10),
                tags=("space_heat_norm",)
            )

            ex1, ey1, ex2, ey2 = lab["heat_equip_pos"]
            heat_equip_id = self.canvas.create_text(
                (ex1 + ex2) / 2, (ey1 + ey2) / 2,
                text=lab["heat_equip_text"], fill="darkred", font=("Arial", 10),
                tags=("space_heat_equip",)
            )

            ax1, ay1, ax2, ay2 = lab["area_pos"]
            area_id = self.canvas.create_text(
                (ax1 + ax2) / 2, (ay1 + ay2) / 2,
                text=lab["area_text"], fill="green", font=("Arial", 10)
            )
            
            # 디퓨저 복원
            diffuser_ids = []
            r = 3
            if "diffuser_coords" in lab:
                for (cx, cy) in lab["diffuser_coords"]:
                    did = self.canvas.create_oval(
                        cx - r, cy - r, cx + r, cy + r,
                        fill="green", outline=""
                    )
                    diffuser_ids.append(did)

            self.generated_space_labels.append({
                "polygon": poly,
                "name_id": name_id,
                "heat_norm_id": heat_norm_id,
                "heat_equip_id": heat_equip_id,
                "area_id": area_id,
                "diffuser_ids": diffuser_ids
            })

        # 태그 바인딩 복원
        self.canvas.tag_bind("dim_width", "<Button-1>", self.on_dim_width_click)
        self.canvas.tag_bind("dim_height", "<Button-1>", self.on_dim_height_click)
        self.canvas.tag_bind("space_name", "<Button-1>", self.on_space_name_click)
        self.canvas.tag_bind("space_heat_norm", "<Button-1>", self.on_space_heat_norm_click)
        self.canvas.tag_bind("space_heat_equip", "<Button-1>", self.on_space_heat_equip_click)

        self.active_shape = None
        self.active_side_name = None
        self.app.update_selected_area_label(self)

    # -------- 도형 생성/그리기 --------

    def draw_square_from_area(self, area: float):
        if area <= 0:
            return

        self.push_history()

        side_m = sqrt(area)
        side_px = self.meter_to_pixel(side_m)

        cw = int(self.canvas["width"])
        ch = int(self.canvas["height"])

        x1 = cw / 2 - side_px / 2
        y1 = ch / 2 - side_px / 2
        x2 = cw / 2 + side_px / 2
        y2 = ch / 2 + side_px / 2

        shape = self.create_rect_shape(x1, y1, x2, y2, editable=True, color="black",
                                       push_to_history=False)
        self.set_active_shape(shape)

    def create_rect_shape(self, x1, y1, x2, y2,
                          editable=True, color="black",
                          push_to_history=True):
        if x2 < x1:
            x1, x2 = x2, x1
        if y2 < y1:
            y1, y2 = y2, y1

        shape_id = self.next_shape_id
        self.next_shape_id += 1

        rect_id = self.canvas.create_rectangle(
            x1, y1, x2, y2,
            outline=color,
            width=2,
            dash=() if color == "black" else (3, 2)
        )

        top_id = self.canvas.create_line(x1, y1, x2, y1, fill=color, width=3)
        bottom_id = self.canvas.create_line(x1, y2, x2, y2, fill=color, width=3)
        left_id = self.canvas.create_line(x1, y1, x1, y2, fill=color, width=3)
        right_id = self.canvas.create_line(x2, y1, x2, y2, fill=color, width=3)

        side_ids = {"top": top_id, "bottom": bottom_id,
                    "left": left_id, "right": right_id}
        for side_name, lid in side_ids.items():
            self.canvas.addtag_withtag(f"shape_{shape_id}", lid)
            self.canvas.addtag_withtag(f"side_{shape_id}_{side_name}", lid)

        dim_items = self.draw_dimensions_for_shape(shape_id, x1, y1, x2, y2, color=color)

        shape = RectShape(shape_id, (x1, y1, x2, y2),
                          rect_id, side_ids, dim_items,
                          editable=editable, color=color)

        self.shapes.append(shape)
        self.bring_shape_to_front(shape)
        
        try:
            if self.generated_space_labels:
                pass
        except Exception:
            pass

        return shape

    def bring_shape_to_front(self, shape: RectShape):
        ids = [shape.rect_id]
        ids.extend(shape.side_ids.values())
        for part in shape.dim_items.values():
            ids.extend(part["lines"])
            ids.extend(part["ticks"])
            ids.append(part["text"])
        for item_id in ids:
            if item_id in self.canvas.find_all():
                self.canvas.tag_raise(item_id)

    def draw_dimensions_for_shape(self, shape_id, x1, y1, x2, y2, color="black"):
        dim_items = {}
        offset = 30
        tick_len = 8
        text_offset = 4

        # 가로
        width_px = x2 - x1
        width_m = self.pixel_to_meter(width_px)
        dim_y = y1 - offset

        dim_line_top = self.canvas.create_line(x1, dim_y, x2, dim_y,
                                               fill=color, width=1)
        left_tick_top = self.canvas.create_line(
            x1, dim_y - tick_len / 2, x1, dim_y + tick_len / 2,
            fill=color, width=1)
        right_tick_top = self.canvas.create_line(
            x2, dim_y - tick_len / 2, x2, dim_y + tick_len / 2,
            fill=color, width=1)
        text_x = (x1 + x2) / 2
        text_y = dim_y - text_offset

        width_text_id = self.canvas.create_text(
            text_x, text_y,
            text=f"{width_m:.2f} {self.unit}",
            fill=color,
            font=("Arial", 10),
            tags=("dim_width", f"dim_width_{shape_id}")
        )

        dim_items["top"] = {
            "lines": [dim_line_top],
            "ticks": [left_tick_top, right_tick_top],
            "text": width_text_id
        }

        # 세로
        height_px = y2 - y1
        height_m = self.pixel_to_meter(height_px)
        dim_x = x1 - offset

        dim_line_left = self.canvas.create_line(dim_x, y1, dim_x, y2,
                                                fill=color, width=1)
        top_tick_left = self.canvas.create_line(
            dim_x - tick_len / 2, y1, dim_x + tick_len / 2, y1,
            fill=color, width=1)
        bottom_tick_left = self.canvas.create_line(
            dim_x - tick_len / 2, y2, dim_x + tick_len / 2, y2,
            fill=color, width=1)
        text_x2 = dim_x - text_offset
        text_y2 = (y1 + y2) / 2

        height_text_id = self.canvas.create_text(
            text_x2, text_y2,
            text=f"{height_m:.2f} {self.unit}",
            fill=color,
            font=("Arial", 10),
            angle=90,
            tags=("dim_height", f"dim_height_{shape_id}")
        )

        dim_items["left"] = {
            "lines": [dim_line_left],
            "ticks": [top_tick_left, bottom_tick_left],
            "text": height_text_id
        }

        for item in [dim_line_top, left_tick_top, right_tick_top,
                     dim_line_left, top_tick_left, bottom_tick_left,
                     width_text_id, height_text_id]:
            self.canvas.addtag_withtag(f"shape_{shape_id}", item)

        return dim_items

    # -------- 선택/하이라이트 --------

    def get_shape_by_id(self, shape_id):
        for s in self.shapes:
            if s.shape_id == shape_id:
                return s
        return None

    def set_active_shape(self, shape):
        self.active_shape = shape
        self.app.update_selected_area_label(self)
        if shape:
            self.bring_shape_to_front(shape)

    def find_side_under_mouse(self, x, y, tol=5):
        best_shape = None
        best_side = None
        best_dist2 = None

        for shape in reversed(self.shapes):
            x1, y1, x2, y2 = shape.coords
            candidates = []
            if x1 <= x <= x2:
                candidates.append(("top", (y - y1) ** 2, abs(y - y1)))
                candidates.append(("bottom", (y - y2) ** 2, abs(y - y2)))
            if y1 <= y <= y2:
                candidates.append(("left", (x - x1) ** 2, abs(x - x1)))
                candidates.append(("right", (x - x2) ** 2, abs(x - x2)))

            for side_name, d2, absd in candidates:
                if absd <= tol:
                    if best_dist2 is None or d2 < best_dist2:
                        best_dist2 = d2
                        best_shape = shape
                        best_side = side_name
        return best_shape, best_side

    def highlight_side(self, shape, side_name):
        if self.highlight_line_id and self.highlight_line_id in self.canvas.find_all():
            self.canvas.itemconfigure(self.highlight_line_id, width=3)
        self.highlight_line_id = None

        if not shape or not side_name:
            return

        line_id = shape.side_ids.get(side_name)
        if line_id:
            self.canvas.itemconfigure(line_id, width=4)
            self.highlight_line_id = line_id

    # -------- 모서리 감지 --------

    def clear_corner_highlight(self):
        if self.corner_highlight_id and self.corner_highlight_id in self.canvas.find_all():
            self.canvas.delete(self.corner_highlight_id)
        self.corner_highlight_id = None
        self.corner_hover_shape = None
        self.corner_hover_index = None

    def detect_corner_under_mouse(self, x, y):
        tol = self.corner_snap_tolerance
        best_shape = None
        best_index = None
        best_cx = best_cy = None
        best_d2 = None

        for shape in self.shapes:
            x1, y1, x2, y2 = shape.coords
            corners = [(x1, y1), (x2, y1), (x1, y2), (x2, y2)]
            for idx, (cx, cy) in enumerate(corners):
                dx = x - cx
                dy = y - cy
                d2 = dx * dx + dy * dy
                if abs(dx) <= tol and abs(dy) <= tol:
                    if best_d2 is None or d2 < best_d2:
                        best_d2 = d2
                        best_shape = shape
                        best_index = idx
                        best_cx, best_cy = cx, cy
        return best_shape, best_index, best_cx, best_cy

    # -------- 스냅 하이라이트 --------

    def clear_edge_snap_highlight(self, shape: RectShape):
        for side in shape.snap_highlight_sides:
            lid = shape.side_ids.get(side)
            if lid in self.canvas.find_all():
                self.canvas.itemconfigure(lid, fill=shape.color)
        shape.snap_highlight_sides.clear()

    def highlight_edge_snap(self, shape: RectShape, snapped_sides):
        self.clear_edge_snap_highlight(shape)
        for side in snapped_sides:
            lid = shape.side_ids.get(side)
            if lid in self.canvas.find_all():
                self.canvas.itemconfigure(lid, fill="orange")
                shape.snap_highlight_sides.add(side)

    # -------- 툴팁 --------

    def show_length_tooltip(self, shape, side_name, mx, my):
        x1, y1, x2, y2 = shape.coords
        if side_name in ("top", "bottom"):
            length_px = x2 - x1
        else:
            length_px = y2 - y1
        length_m = self.pixel_to_meter(length_px)
        text = f"{length_m:.2f} {self.unit}"

        if self.tooltip_id and self.tooltip_id in self.canvas.find_all():
            self.canvas.delete(self.tooltip_id)
            self.tooltip_id = None

        offset = 15
        self.tooltip_id = self.canvas.create_text(
            mx + offset, my - offset,
            text=text,
            fill="darkgreen",
            font=("Arial", 10, "bold"),
            anchor="sw"
        )

    def hide_length_tooltip(self):
        if self.tooltip_id and self.tooltip_id in self.canvas.find_all():
            self.canvas.delete(self.tooltip_id)
        self.tooltip_id = None

    # -------- 공유 변 판정 --------

    def find_shared_vertical_edges(self, shape):
        x1, y1, x2, y2 = shape.coords
        shared = {"left": False, "right": False}
        for other in self.shapes:
            if other is shape:
                continue
            ox1, oy1, ox2, oy2 = other.coords
            if abs(ox1 - x1) < 1e-6 or abs(ox2 - x1) < 1e-6:
                overlap = min(y2, oy2) - max(y1, oy1)
                if overlap > 0:
                    shared["left"] = True
            if abs(ox1 - x2) < 1e-6 or abs(ox2 - x2) < 1e-6:
                overlap = min(y2, oy2) - max(y1, oy1)
                if overlap > 0:
                    shared["right"] = True
        return shared

    def find_shared_horizontal_edges(self, shape):
        x1, y1, x2, y2 = shape.coords
        shared = {"top": False, "bottom": False}
        for other in self.shapes:
            if other is shape:
                continue
            ox1, oy1, ox2, oy2 = other.coords
            if abs(oy1 - y1) < 1e-6 or abs(oy2 - y1) < 1e-6:
                overlap = min(x2, ox2) - max(x1, ox1)
                if overlap > 0:
                    shared["top"] = True
            if abs(oy1 - y2) < 1e-6 or abs(oy2 - y2) < 1e-6:
                overlap = min(x2, ox2) - max(x1, ox1)
                if overlap > 0:
                    shared["bottom"] = True
        return shared

    # -------- 코너 팝업 삭제 --------

    def delete_corner_shape(self):
        shape = self.corner_menu_target_shape
        if not shape or not shape.editable:
            return

        self.push_history()

        self.canvas.delete(shape.rect_id)
        for lid in shape.side_ids.values():
            self.canvas.delete(lid)
        for part in shape.dim_items.values():
            for lid in part["lines"] + part["ticks"] + [part["text"]]:
                self.canvas.delete(lid)

        if shape in self.shapes:
            self.shapes.remove(shape)

        if self.active_shape is shape:
            self.active_shape = None
        if self.corner_hover_shape is shape:
            self.clear_corner_highlight()

        self.app.update_selected_area_label(self)
        self.corner_menu_target_shape = None

    # -------- 마우스 이벤트 --------

    def on_mouse_move(self, event):
        if self.moving_shape:
            return

        shape, idx, cx, cy = self.detect_corner_under_mouse(event.x, event.y)
        if shape:
            if not self.corner_highlight_id or self.corner_highlight_id not in self.canvas.find_all():
                r = 4
                self.corner_highlight_id = self.canvas.create_oval(
                    cx - r, cy - r, cx + r, cy + r,
                    fill="red", outline=""
                )
            else:
                r = 4
                self.canvas.coords(self.corner_highlight_id,
                                   cx - r, cy - r, cx + r, cy + r)
            self.corner_hover_shape = shape
            self.corner_hover_index = idx
        else:
            self.clear_corner_highlight()

        if self.active_side_name is None and not self.corner_hover_shape:
            s, side = self.find_side_under_mouse(event.x, event.y, tol=5)
            self.highlight_side(s, side)

        # Display per-diffuser flow when hovering over a diffuser in Room Design tab
        try:
            current_widget = None
            try:
                current_widget = self.app.left_notebook.nametowidget(self.app.left_notebook.select())
            except Exception:
                current_widget = None
            # proceed only when NOT on the Duct tab (i.e., Room Design)
            if current_widget is not getattr(self.app, 'duct_tab', None):
                # use slightly larger tolerance to reliably hit small diffuser ovals
                tol = 6
                nearby = list(self.canvas.find_overlapping(event.x - tol, event.y - tol, event.x + tol, event.y + tol))
                found = None
                for iid in nearby:
                    try:
                        if self._is_diffuser_item(iid):
                            found = iid
                            break
                    except Exception:
                        continue

                if found:
                    # determine per-diffuser value: prefer stored mapping, otherwise compute on the fly
                    val = None
                    for lab in getattr(self, 'generated_space_labels', []):
                        try:
                            # if mapping exists
                            mapping = lab.get('diffuser_flows')
                            if mapping and found in mapping:
                                val = mapping.get(found)
                                break
                            # fallback: compute from room total and count of supply diffusers
                            if float(lab.get('supply_flow_value', 0)) > 0 and 'diffuser_ids' in lab:
                                # count supply diffusers in this lab
                                supply_ids = [d for d in lab.get('diffuser_ids', []) if 'supply' in self.canvas.gettags(d)]
                                if supply_ids and found in supply_ids:
                                    try:
                                        val = round(float(lab.get('supply_flow_value', 0)) / len(supply_ids), 2)
                                    except Exception:
                                        val = None
                                    break
                        except Exception:
                            continue

                    if val is not None:
                        # show tooltip near cursor (delete previous)
                        try:
                            if self.flow_tooltip_id and self.flow_tooltip_id in self.canvas.find_all():
                                self.canvas.delete(self.flow_tooltip_id)
                                self.flow_tooltip_id = None
                        except Exception:
                            pass
                        try:
                            text = f"{val:.2f} m3/hr"
                            # create with a stable tag so it can be removed reliably
                            self.flow_tooltip_id = self.canvas.create_text(event.x + 12, event.y - 10,
                                                                           text=text, fill='black',
                                                                           font=("Arial", 9, "bold"), anchor='nw', tags=('flow_tooltip',))
                            # lift tooltip above other items
                            try:
                                self.canvas.tag_raise(self.flow_tooltip_id)
                            except Exception:
                                pass
                        except Exception:
                            self.flow_tooltip_id = None
                    else:
                        try:
                            if self.flow_tooltip_id and self.flow_tooltip_id in self.canvas.find_all():
                                self.canvas.delete(self.flow_tooltip_id)
                                self.flow_tooltip_id = None
                        except Exception:
                            pass
                else:
                    try:
                        if self.flow_tooltip_id and self.flow_tooltip_id in self.canvas.find_all():
                            self.canvas.delete(self.flow_tooltip_id)
                            self.flow_tooltip_id = None
                    except Exception:
                        pass
        except Exception:
            pass

    # ----- diffuser item hover handlers (item-level bindings) -----
    def _diffuser_enter(self, event):
        """Canvas <Enter> handler for diffuser items: show flow tooltip near cursor."""
        try:
            canvas = event.widget
            items = canvas.find_withtag('current')
            if not items:
                return
            did = items[0]
            val = None
            for lab in getattr(self, 'generated_space_labels', []):
                try:
                    mapping = lab.get('diffuser_flows')
                    if mapping and did in mapping:
                        val = mapping.get(did)
                        break
                    if float(lab.get('supply_flow_value', 0)) > 0 and 'diffuser_ids' in lab:
                        supply_ids = [d for d in lab.get('diffuser_ids', []) if 'supply' in self.canvas.gettags(d)]
                        if supply_ids and did in supply_ids:
                            val = round(float(lab.get('supply_flow_value', 0)) / len(supply_ids), 2)
                            break
                except Exception:
                    continue

            if val is None:
                return

            try:
                print(f"DEBUG: _diffuser_enter called for item(s)={canvas.find_withtag('current')}")
                sys.stdout.flush()
                if self.flow_tooltip_id and self.flow_tooltip_id in self.canvas.find_all():
                    self.canvas.delete(self.flow_tooltip_id)
                    self.flow_tooltip_id = None
            except Exception:
                pass

            try:
                text = f"{val:.2f} m3/hr"
                self._show_flow_tooltip(text, event.x, event.y)
                try:
                    print(f"DEBUG: created tooltip (box+text) at {event.x},{event.y} text={text}")
                    sys.stdout.flush()
                except Exception:
                    pass
            except Exception:
                self._hide_flow_tooltip()
        except Exception:
            pass

    def _diffuser_leave(self, event):
        """Canvas <Leave> handler for diffuser items: hide flow tooltip."""
        try:
            self._hide_flow_tooltip()
        except Exception:
            pass

    def _show_flow_tooltip(self, text: str, x: int, y: int):
        """Create a small background rectangle and text at (x,y) relative to canvas.
        Uses overlay if available, otherwise main canvas. Stores ids in self.flow_tooltip_id
        and the canvas object in self.flow_tooltip_canvas for later deletion.
        """
        try:
            # hide any existing tooltip first
            self._hide_flow_tooltip()
        except Exception:
            pass
        try:
            draw_canvas = getattr(self, 'overlay', None) or self.canvas
            # measure text roughly by using a temporary text item
            tmp = draw_canvas.create_text(0, 0, text=text, font=("Arial", 9, "bold"), anchor='nw')
            bbox = draw_canvas.bbox(tmp) or (0, 0, 0, 0)
            draw_canvas.delete(tmp)
            padding = 4
            tx1, ty1, tx2, ty2 = bbox
            w = max(30, tx2 - tx1)
            h = max(12, ty2 - ty1)
            # compute box position near cursor with offset
            ox = 12
            oy = -10
            bx1 = x + ox
            by1 = y + oy
            bx2 = bx1 + w + padding * 2
            by2 = by1 + h + padding * 2
            # create background rectangle and text
            try:
                rect_id = draw_canvas.create_rectangle(bx1, by1, bx2, by2, fill='#fff8a8', outline='black', width=1, tags=('flow_tooltip',))
            except Exception:
                rect_id = None
            try:
                text_id = draw_canvas.create_text(bx1 + padding, by1 + padding, text=text, anchor='nw', font=("Arial", 9, "bold"), tags=('flow_tooltip',))
            except Exception:
                text_id = None
            # store ids (keep both in a tuple)
            self.flow_tooltip_canvas = draw_canvas
            self.flow_tooltip_id = (rect_id, text_id)
            try:
                draw_canvas.tag_raise('flow_tooltip')
            except Exception:
                pass
        except Exception:
            self.flow_tooltip_id = None
            self.flow_tooltip_canvas = None

    def _hide_flow_tooltip(self):
        try:
            if getattr(self, 'flow_tooltip_canvas', None) is not None and getattr(self, 'flow_tooltip_id', None) is not None:
                try:
                    for iid in (self.flow_tooltip_id if isinstance(self.flow_tooltip_id, (list, tuple)) else [self.flow_tooltip_id]):
                        if iid and iid in self.flow_tooltip_canvas.find_all():
                            try:
                                self.flow_tooltip_canvas.delete(iid)
                            except Exception:
                                pass
                except Exception:
                    try:
                        # fallback: delete by tag
                        self.flow_tooltip_canvas.delete('flow_tooltip')
                    except Exception:
                        pass
        except Exception:
            pass
        finally:
            self.flow_tooltip_id = None
            self.flow_tooltip_canvas = None

    def on_left_down(self, event):
        try:
            print(f"DEBUG on_left_down ENTRY at ({event.x},{event.y}) widget={event.widget} state=0x{getattr(event, 'state', 0):04x}")
        except Exception:
            pass

        try:
            try:
                current_widget = self.app.left_notebook.nametowidget(self.app.left_notebook.select())
            except Exception:
                current_widget = None
            is_duct_dbg = (current_widget is getattr(self.app, 'duct_tab', None))
            try:
                print(f"DEBUG on_left_down: notebook_tab={current_widget} is_duct={is_duct_dbg} hvac_active={bool(getattr(self.app, '_active_hvac_name', None))}")
            except Exception:
                pass
        except Exception:
            pass

        # corner handle move takes precedence
        if self.corner_hover_shape is not None:
            try:
                self.push_history()
            except Exception:
                pass
            self.moving_shape = self.corner_hover_shape
            self.move_start_mouse_pos = (event.x, event.y)
            self.move_start_shape_coords = self.moving_shape.coords
            self.set_active_shape(self.moving_shape)
            return

        # decide whether we are in Duct (HVAC) mode
        try:
            try:
                current_widget = self.app.left_notebook.nametowidget(self.app.left_notebook.select())
            except Exception:
                current_widget = None
            is_duct = (current_widget is getattr(self.app, 'duct_tab', None))
        except Exception:
            is_duct = False
        hvac_active = bool(getattr(self.app, '_active_hvac_name', None))

        if is_duct and hvac_active:
            # Ctrl-click toggles single diffuser under cursor
            try:
                ctrl_pressed = bool(event.state & 0x0004)
            except Exception:
                ctrl_pressed = False

            if ctrl_pressed:
                try:
                    nearby = list(self.canvas.find_overlapping(event.x-3, event.y-3, event.x+3, event.y+3))
                except Exception:
                    nearby = []
                for iid in nearby:
                    try:
                        if self._is_diffuser_item(iid):
                            if iid in self.selected_points:
                                try:
                                    self.canvas.itemconfigure(iid, outline='')
                                except Exception:
                                    pass
                                try:
                                    self.selected_points.remove(iid)
                                except Exception:
                                    pass
                            else:
                                try:
                                    self.canvas.itemconfigure(iid, outline='red', width=2)
                                except Exception:
                                    pass
                                try:
                                    self.selected_points.add(iid)
                                except Exception:
                                    pass
                            try:
                                if getattr(self.app, 'duct_selected_label_var', None) is not None:
                                    self.app.duct_selected_label_var.set(f"선택 디퓨저: {len(self.selected_points)}")
                            except Exception:
                                pass
                            return
                    except Exception:
                        continue

            # begin rectangle selection on main canvas
            self.rect_select_start = (event.x, event.y)
            self.rect_select_ctrl = bool(ctrl_pressed)
            self.rect_draw_canvas = self.canvas
            self.rect_draw_total = False
            try:
                if self.rect_select_id and self.rect_select_id in self.rect_draw_canvas.find_all():
                    self.rect_draw_canvas.delete(self.rect_select_id)
            except Exception:
                pass
            try:
                self.clear_corner_highlight()
            except Exception:
                pass
            try:
                self.rect_select_id = self.rect_draw_canvas.create_rectangle(event.x, event.y, event.x, event.y,
                                                                               outline='red', dash=(), width=3, fill='', tags=('rect_select',))
                try:
                    self.rect_draw_canvas.tag_raise(self.rect_select_id)
                except Exception:
                    try:
                        self.rect_draw_canvas.lift(self.rect_select_id)
                    except Exception:
                        pass
            except Exception:
                self.rect_select_id = None
            try:
                if not self.rect_select_ctrl:
                    self._clear_point_selection()
            except Exception:
                pass
            try:
                if getattr(self.app, 'duct_selected_label_var', None) is not None:
                    self.app.duct_selected_label_var.set(f"선택 디퓨저: {len(self.selected_points)}")
            except Exception:
                pass
            return

        # Not in Duct mode: begin side-drag if cursor over a side
        try:
            shape_under, side_under = self.find_side_under_mouse(event.x, event.y, tol=5)
        except Exception:
            shape_under, side_under = (None, None)
        if shape_under and side_under and getattr(shape_under, 'editable', True):
            try:
                self.push_history()
            except Exception:
                pass
            try:
                self.set_active_shape(shape_under)
            except Exception:
                pass
            try:
                self.active_side_name = side_under
                self.drag_start_mouse_pos = (event.x, event.y)
                self.drag_start_coords = shape_under.coords
            except Exception:
                self.active_side_name = None
                self.drag_start_mouse_pos = None
                self.drag_start_coords = None
            return
        # on_left_down finishes here; dragging handled by on_left_drag
        return

    def on_left_drag(self, event):
        """Handle mouse motion while Button1 is down: update rect-select or perform shape dragging."""
        # Determine whether Duct-mode rect-selection is appropriate for this event.
        try:
            try:
                current_widget = self.app.left_notebook.nametowidget(self.app.left_notebook.select())
            except Exception:
                current_widget = None
            is_duct = (current_widget is getattr(self.app, 'duct_tab', None))
        except Exception:
            is_duct = False
        hvac_active = bool(getattr(self.app, '_active_hvac_name', None))

        # If we're doing a rectangle selection (Duct tab + HVAC selected), update the rect and return
        try:
            if is_duct and hvac_active:
                # If a rect select already started, use its start
                if getattr(self, 'rect_select_start', None):
                    x0, y0 = self.rect_select_start
                else:
                    # If no rect_select_start, but the user is dragging with Button1
                    # held and the Duct tab is active, initialize rect selection here.
                    try:
                        current_widget = None
                        try:
                            current_widget = self.app.left_notebook.nametowidget(self.app.left_notebook.select())
                        except Exception:
                            current_widget = None
                        is_duct = (current_widget is getattr(self.app, 'duct_tab', None))
                    except Exception:
                        is_duct = False
                    try:
                        button1_down = bool(event.state & 0x100)
                    except Exception:
                        button1_down = False
                    if is_duct and getattr(self.app, '_active_hvac_name', None) and button1_down:
                        # initialize rect select at current point
                        try:
                            ctrl_pressed = bool(event.state & 0x0004)
                        except Exception:
                            ctrl_pressed = False
                        try:
                            self.rect_select_ctrl = ctrl_pressed
                            self.rect_select_start = (event.x, event.y)
                            if self.rect_select_id and getattr(self, 'overlay', None) and self.rect_select_id in self.overlay.find_all():
                                try:
                                    self.overlay.delete(self.rect_select_id)
                                except Exception:
                                    pass
                            try:
                                self.clear_corner_highlight()
                            except Exception:
                                pass
                            try:
                                # Prefer main canvas rect if overlay is not available
                                if getattr(self, 'overlay', None):
                                    self.rect_select_id = self.overlay.create_rectangle(event.x, event.y, event.x, event.y,
                                                        outline='black', dash=(), width=2, fill='yellow', stipple='gray25', tags=('rect_select',))
                                else:
                                    self.rect_select_id = self.rect_draw_canvas.create_rectangle(event.x, event.y, event.x, event.y,
                                                        outline='black', dash=(), width=2, fill='yellow', tags=('rect_select',))
                            except Exception:
                                try:
                                    self.rect_select_id = self.overlay.create_rectangle(event.x, event.y, event.x, event.y,
                                                                                    outline='black', dash=(), width=2, fill='yellow', tags=('rect_select',))
                                except Exception:
                                    self.rect_select_id = None
                            try:
                                print(f"DEBUG on_left_drag: auto-began rect at ({event.x},{event.y}) id={self.rect_select_id} ctrl={self.rect_select_ctrl}")
                            except Exception:
                                pass
                            try:
                                # ensure rectangle is on top so it's visible above shapes
                                if getattr(self, 'overlay', None) and self.rect_select_id in self.overlay.find_all():
                                    try:
                                        self.overlay.tag_raise(self.rect_select_id)
                                    except Exception:
                                        try:
                                            self.overlay.lift(self.rect_select_id)
                                        except Exception:
                                            pass
                                    try:
                                        self.overlay.itemconfigure(self.rect_select_id, outline='red', width=2)
                                    except Exception:
                                        pass
                            except Exception:
                                pass
                            # clear previous selection unless ctrl-modifying
                            try:
                                if not getattr(self, 'rect_select_ctrl', False):
                                    self._clear_point_selection()
                            except Exception:
                                pass
                        except Exception:
                            pass
                # if we initialized, fall through to update coords below
                if not getattr(self, 'rect_select_start', None):
                    return
                # update rectangle outline on the canvas it was drawn on
                try:
                    drawc = getattr(self, 'rect_draw_canvas', None) or getattr(self, 'overlay', None) or self.canvas
                    if self.rect_select_id and drawc and self.rect_select_id in drawc.find_all():
                        try:
                            drawc.coords(self.rect_select_id, x0, y0, event.x, event.y)
                            # ensure visible and on top after coords change
                            try:
                                drawc.tag_raise(self.rect_select_id)
                            except Exception:
                                try:
                                    drawc.lift(self.rect_select_id)
                                except Exception:
                                    pass
                            try:
                                drawc.itemconfigure(self.rect_select_id, outline='black', width=2, fill='yellow', stipple='gray25')
                            except Exception:
                                try:
                                    drawc.itemconfigure(self.rect_select_id, outline='black', width=2, fill='yellow')
                                except Exception:
                                    pass
                        except Exception:
                            pass
                except Exception:
                    pass
                return
            else:
                # Not in Duct mode: clear any lingering rectangle-selection state so
                # Room Design dragging is not affected by previous Duct actions.
                try:
                    if getattr(self, 'rect_select_id', None):
                        drawc = getattr(self, 'rect_draw_canvas', None) or getattr(self, 'overlay', None) or self.canvas
                        if drawc and self.rect_select_id in drawc.find_all():
                            try:
                                drawc.delete(self.rect_select_id)
                            except Exception:
                                pass
                except Exception:
                    pass
                try:
                    self.rect_select_id = None
                    self.rect_select_start = None
                    self.rect_select_ctrl = False
                    self.rect_draw_canvas = None
                    self.rect_draw_total = False
                except Exception:
                    pass
        except Exception:
            pass

        # 도형 전체 이동 (shape dragging)
        if self.moving_shape and self.move_start_mouse_pos and self.move_start_shape_coords:
            dx = event.x - self.move_start_mouse_pos[0]
            dy = event.y - self.move_start_mouse_pos[1]
            x1, y1, x2, y2 = self.move_start_shape_coords
            tentative = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)

            snapped_sides = []
            tentative2, s_left = self.apply_snap_edge(self.moving_shape, "left", tentative)
            if s_left:
                snapped_sides.append("left")
                tentative = tentative2
            tentative2, s_right = self.apply_snap_edge(self.moving_shape, "right", tentative)
            if s_right:
                snapped_sides.append("right")
                tentative = tentative2
            tentative2, s_top = self.apply_snap_edge(self.moving_shape, "top", tentative)
            if s_top:
                snapped_sides.append("top")
                tentative = tentative2
            tentative2, s_bottom = self.apply_snap_edge(self.moving_shape, "bottom", tentative)
            if s_bottom:
                snapped_sides.append("bottom")
                tentative = tentative2

            self.moving_shape.coords = tentative
            self.redraw_shape(self.moving_shape)
            self.highlight_edge_snap(self.moving_shape, snapped_sides)
            self.app.update_selected_area_label(self)
            return

        def _is_diffuser_item(self, iid):
            """Return True if the canvas item id looks like a diffuser (oval) by checking
            tag 'point' or membership in generated_space_labels.diffuser_ids."""
            try:
                if not iid:
                    return False
                # check tag
                try:
                    tags = self.canvas.gettags(iid)
                    if 'point' in tags:
                        return True
                except Exception:
                    pass
                # check generated_space_labels
                try:
                    for lab in getattr(self, 'generated_space_labels', []):
                        if 'diffuser_ids' in lab and iid in lab['diffuser_ids']:
                            return True
                except Exception:
                    pass
            except Exception:
                pass
            return False

        # 변 드래그
        if not self.active_shape or not self.active_side_name or not self.drag_start_coords:
            return
        if not self.active_shape.editable:
            return

        x1, y1, x2, y2 = self.drag_start_coords
        dx = event.x - self.drag_start_mouse_pos[0]
        dy = event.y - self.drag_start_mouse_pos[1]
        min_size_px = 20
        side = self.active_side_name

        if side == "top":
            new_y1 = y1 + dy
            if new_y1 > y2 - min_size_px:
                new_y1 = y2 - min_size_px
            tentative = (x1, new_y1, x2, y2)
        elif side == "bottom":
            new_y2 = y2 + dy
            if new_y2 < y1 + min_size_px:
                new_y2 = y1 + min_size_px
            tentative = (x1, y1, x2, new_y2)
        elif side == "left":
            new_x1 = x1 + dx
            if new_x1 > x2 - min_size_px:
                new_x1 = x2 - min_size_px
            tentative = (new_x1, y1, x2, y2)
        elif side == "right":
            new_x2 = x2 + dx
            if new_x2 < x1 + min_size_px:
                new_x2 = x1 + min_size_px
            tentative = (x1, y1, new_x2, y2)
        else:
            return

        snapped_coords, snapped = self.apply_snap_edge(self.active_shape, side, tentative)
        self.active_shape.coords = snapped_coords

        self.redraw_shape(self.active_shape)
        self.bring_shape_to_front(self.active_shape)
        if snapped:
            self.highlight_edge_snap(self.active_shape, [side])
        else:
            self.clear_edge_snap_highlight(self.active_shape)

        self.highlight_side(self.active_shape, side)
        self.show_length_tooltip(self.active_shape, side, event.x, event.y)
        self.app.update_selected_area_label(self)

    def on_left_up(self, event):
        """Handle left mouse button release: finish moves/drags and finalize rect selection."""
        try:
            print(f"DEBUG on_left_up ENTRY at ({event.x},{event.y}) widget={event.widget}")
        except Exception:
            pass
        if self.moving_shape:
            self.clear_edge_snap_highlight(self.moving_shape)
        self.moving_shape = None
        self.move_start_mouse_pos = None
        self.move_start_shape_coords = None

        if self.active_shape:
            self.clear_edge_snap_highlight(self.active_shape)
        self.active_side_name = None
        self.drag_start_mouse_pos = None
        self.drag_start_coords = None
        self.hide_length_tooltip()

        # finalize rectangle selection if active
        try:
            if getattr(self, 'rect_select_start', None):
                x0, y0 = self.rect_select_start
                x1, y1 = event.x, event.y
                # delete the transient rect from the same canvas it was drawn on
                try:
                    drawc = getattr(self, 'rect_draw_canvas', None) or self.canvas
                except Exception:
                    drawc = self.canvas
                try:
                    if self.rect_select_id and drawc and self.rect_select_id in drawc.find_all():
                        try:
                            drawc.delete(self.rect_select_id)
                        except Exception:
                            pass
                except Exception:
                    pass
                self.rect_select_id = None
                self.rect_select_start = None
                # clear rect_draw_canvas state
                try:
                    self.rect_draw_canvas = None
                    self.rect_draw_total = False
                except Exception:
                    pass
                # select ovals inside the rectangle
                try:
                    minx = min(x0, x1)
                    miny = min(y0, y1)
                    maxx = max(x0, x1)
                    maxy = max(y0, y1)
                    mode = 'invert' if getattr(self, 'rect_select_ctrl', False) else 'replace'
                    try:
                        print(f"DEBUG on_left_up: rect ({minx},{miny})-({maxx},{maxy}) mode={mode}")
                    except Exception:
                        pass
                    # clear the stored ctrl flag for next operation
                    try:
                        self.rect_select_ctrl = False
                    except Exception:
                        pass
                    self._select_points_in_rect(minx, miny, maxx, maxy, mode=mode)
                    try:
                        print(f"DEBUG on_left_up: selection_count={len(getattr(self, 'selected_points', set()))}")
                    except Exception:
                        pass
                except Exception:
                    pass
        except Exception:
            pass

    def _select_points_in_rect(self, minx, miny, maxx, maxy, mode='replace'):
        """Select small point-like items (ovals) whose centers fall inside the rectangle.

        mode: 'replace' (default) will clear existing selection and set new selection.
              'invert' will invert selection state for items inside the rect.
        """
        try:
            # Collect candidate items from two sources:
            # 1) canvas items tagged 'point' (if diffusers were created with that tag)
            # 2) diffuser IDs tracked in generated_space_labels (if available)
            items_set = set()
            try:
                for iid in self.canvas.find_withtag('point'):
                    items_set.add(iid)
            except Exception:
                pass
            # include diffuser ids tracked on generated labels
            try:
                for lab in getattr(self, 'generated_space_labels', []):
                    for did in lab.get('diffuser_ids', []) or []:
                        try:
                            items_set.add(int(did))
                        except Exception:
                            pass
            except Exception:
                pass
            items = list(items_set)
            # If replace mode, start with a fresh selection. If invert, toggle membership.
            if mode == 'replace':
                current_selected = set()
            else:
                current_selected = set(self.selected_points)

            for iid in items:
                coords = self.canvas.coords(iid)
                if not coords or len(coords) < 4:
                    continue
                cx = (coords[0] + coords[2]) / 2
                cy = (coords[1] + coords[3]) / 2
                if minx <= cx <= maxx and miny <= cy <= maxy:
                    if mode == 'invert':
                        # toggle
                        if iid in current_selected:
                            try:
                                current_selected.remove(iid)
                            except Exception:
                                pass
                            try:
                                # Check if item is applied (blue) - if so, restore blue; if assigned yellow, restore yellow; else clear
                                try:
                                    applied_diffusers = set(getattr(self.app, '_supply_assigned', set()) or set())
                                except Exception:
                                    applied_diffusers = set()
                                if iid in applied_diffusers:
                                    self.canvas.itemconfigure(iid, outline='blue', width=2)
                                else:
                                    assigned = False
                                    try:
                                        for m in getattr(self.app, 'hvac_map', {}).values():
                                            try:
                                                ids_set = set(int(x) if isinstance(x, (int, str)) and str(x).isdigit() else x for x in (m.get('ids', set()) or set()))
                                            except Exception:
                                                ids_set = set(m.get('ids', set()) or set())
                                            if iid in ids_set:
                                                assigned = True
                                                break
                                    except Exception:
                                        assigned = False
                                    if assigned:
                                        self.canvas.itemconfigure(iid, outline='yellow', width=2)
                                    else:
                                        self.canvas.itemconfigure(iid, outline='')
                            except Exception:
                                pass
                        else:
                            try:
                                current_selected.add(iid)
                            except Exception:
                                pass
                            try:
                                # when user selects via drag, show all selected items as red (temporary selection)
                                self.canvas.itemconfigure(iid, outline='red', width=2)
                            except Exception:
                                pass
                    else:
                        try:
                            current_selected.add(iid)
                        except Exception:
                            pass
                        # visually mark all drag-selected items as red (temporary selection state)
                        try:
                            self.canvas.itemconfigure(iid, outline='red', width=2)
                        except Exception:
                            pass
            # finalize selection set
            try:
                self.selected_points = set(current_selected)
            except Exception:
                pass
            # update app label if available
            try:
                if getattr(self.app, 'duct_selected_label_var', None) is not None:
                    self.app.duct_selected_label_var.set(f"선택 디퓨저: {len(self.selected_points)}")
            except Exception:
                pass
        except Exception as e:
            print(f"select_points_in_rect error: {e}")

    def _clear_point_selection(self):
        try:
            # compute global set of assigned ids so assigned items stay red
            assigned_all = set()
            try:
                for m in getattr(self.app, 'hvac_map', {}).values():
                    try:
                        for iid in m.get('ids', set()) or set():
                            try:
                                assigned_all.add(int(iid))
                            except Exception:
                                assigned_all.add(iid)
                    except Exception:
                        continue
            except Exception:
                assigned_all = set()

            try:
                applied_diffusers = set(getattr(self.app, '_supply_assigned', set()) or set())
            except Exception:
                applied_diffusers = set()

            for iid in list(self.selected_points):
                try:
                    # if this item is applied, keep blue outline; if assigned to HVAC, restore yellow; otherwise clear
                    if iid in applied_diffusers:
                        try:
                            self.canvas.itemconfigure(iid, outline='blue', width=2)
                        except Exception:
                            pass
                    elif iid in assigned_all:
                        try:
                            self.canvas.itemconfigure(iid, outline='yellow', width=2)
                        except Exception:
                            pass
                    else:
                        try:
                            self.canvas.itemconfigure(iid, outline='')
                        except Exception:
                            pass
                except Exception:
                    pass
            # clear selection set (assigned items remain highlighted red)
            self.selected_points.clear()
            try:
                if getattr(self.app, 'duct_selected_label_var', None) is not None:
                    self.app.duct_selected_label_var.set("선택 디퓨저: 0")
            except Exception:
                pass
        except Exception:
            pass

    def clear_corner_highlight(self):
        """Ensure the small corner highlight marker is removed from the canvas.

        This is called before starting rectangle selection so the tiny red
        corner dot does not visually occlude the rubber-band rectangle.
        """
        try:
            if getattr(self, 'corner_highlight_id', None):
                try:
                    if self.corner_highlight_id in self.canvas.find_all():
                        self.canvas.delete(self.corner_highlight_id)
                except Exception:
                    try:
                        self.canvas.delete(self.corner_highlight_id)
                    except Exception:
                        pass
                self.corner_highlight_id = None
                self.corner_hover_shape = None
                self.corner_hover_index = None
        except Exception:
            # non-critical; ignore
            pass

    # -------- 스냅 --------

    def apply_snap_edge(self, shape, side, coords):
        x1, y1, x2, y2 = coords
        snap = self.snap_tolerance

        candidate_positions = []
        for other in self.shapes:
            if other is shape:
                continue
            ox1, oy1, ox2, oy2 = other.coords
            if side in ("top", "bottom"):
                candidate_positions.extend([oy1, oy2])
            else:
                candidate_positions.extend([ox1, ox2])

        if not candidate_positions:
            return coords, False

        snapped = False
        if side in ("top", "bottom"):
            cur_y = y1 if side == "top" else y2
            best_y = cur_y
            best_diff = None
            for py in candidate_positions:
                diff = abs(py - cur_y)
                if diff <= snap and (best_diff is None or diff < best_diff):
                    best_diff = diff
                    best_y = py
            if best_diff is not None:
                snapped = True
                if side == "top":
                    y1 = best_y
                else:
                    y2 = best_y
        else:
            cur_x = x1 if side == "left" else x2
            best_x = cur_x
            best_diff = None
            for px in candidate_positions:
                diff = abs(px - cur_x)
                if diff <= snap and (best_diff is None or diff < best_diff):
                    best_diff = diff
                    best_x = px
            if best_diff is not None:
                snapped = True
                if side == "left":
                    x1 = best_x
                else:
                    x2 = best_x

        return (x1, y1, x2, y2), snapped

    # -------- 다시 그리기 --------

    def redraw_shape(self, shape):
        self.canvas.delete(shape.rect_id)
        for lid in shape.side_ids.values():
            self.canvas.delete(lid)
        for part in shape.dim_items.values():
            for lid in part["lines"] + part["ticks"] + [part["text"]]:
                self.canvas.delete(lid)

        x1, y1, x2, y2 = shape.coords
        color = shape.color

        rect_id = self.canvas.create_rectangle(
            x1, y1, x2, y2,
            outline=color,
            width=2,
            dash=() if color == "black" else (3, 2)
        )
        top_id = self.canvas.create_line(x1, y1, x2, y1, fill=color, width=3)
        bottom_id = self.canvas.create_line(x1, y2, x2, y2, fill=color, width=3)
        left_id = self.canvas.create_line(x1, y1, x1, y2, fill=color, width=3)
        right_id = self.canvas.create_line(x2, y1, x2, y2, fill=color, width=3)
        side_ids = {"top": top_id, "bottom": bottom_id, "left": left_id, "right": right_id}

        for side_name, lid in side_ids.items():
            self.canvas.addtag_withtag(f"shape_{shape.shape_id}", lid)
            self.canvas.addtag_withtag(f"side_{shape.shape_id}_{side_name}", lid)

        dim_items = self.draw_dimensions_for_shape(shape.shape_id, x1, y1, x2, y2, color=color)

        shape.rect_id = rect_id
        shape.side_ids = side_ids
        shape.dim_items = dim_items

        self.bring_shape_to_front(shape)

    # -------- 치수 클릭 (공유벽 고정 규칙 포함) --------

    def on_dim_width_click(self, event):
        closest_id = event.widget.find_closest(event.x, event.y)[0]
        tags = self.canvas.gettags(closest_id)
        shape_id = None
        for t in tags:
            if t.startswith("dim_width_"):
                shape_id = int(t.split("_")[2])
                break
        if shape_id is None:
            return
        shape = self.get_shape_by_id(shape_id)
        if not shape or not shape.editable:
            return

        x1, y1, x2, y2 = shape.coords
        cur_w_m = self.pixel_to_meter(x2 - x1)

        new_w_m = simpledialog.askfloat(
            "가로 길이 변경",
            f"새 가로 길이({self.unit})를 입력하세요 (현재: {cur_w_m:.2f} {self.unit}):",
            minvalue=0.01
        )
        if new_w_m is None:
            return

        shared = self.find_shared_vertical_edges(shape)
        shared_count = sum(1 for k in ("left", "right") if shared[k])

        if shared_count > 1:
            messagebox.showwarning(
                "변경 불가",
                "좌우 변이 모두 다른 도형과 공유되고 있어 가로 길이를 변경할 수 없습니다."
            )
            return

        self.push_history()
        self.set_active_shape(shape)

        new_w_px = self.meter_to_pixel(new_w_m)
        new_x1 = x1
        new_x2 = x2

        if shared_count == 1:
            if shared["left"]:
                new_x1 = x1
                new_x2 = x1 + new_w_px
            else:
                new_x2 = x2
                new_x1 = x2 - new_w_px
        else:
            new_x1 = x1
            new_x2 = x1 + new_w_px

        min_size_px = 20
        if new_x2 - new_x1 < min_size_px:
            if shared_count == 1 and shared["right"]:
                new_x1 = new_x2 - min_size_px
            else:
                new_x2 = new_x1 + min_size_px

        shape.coords = (new_x1, y1, new_x2, y2)
        self.redraw_shape(shape)
        self.app.update_selected_area_label(self)

    def on_dim_height_click(self, event):
        closest_id = event.widget.find_closest(event.x, event.y)[0]
        tags = self.canvas.gettags(closest_id)
        shape_id = None
        for t in tags:
            if t.startswith("dim_height_"):
                shape_id = int(t.split("_")[2])
                break
        if shape_id is None:
            return
        shape = self.get_shape_by_id(shape_id)
        if not shape or not shape.editable:
            return

        x1, y1, x2, y2 = shape.coords
        cur_h_m = self.pixel_to_meter(y2 - y1)

        new_h_m = simpledialog.askfloat(
            "세로 길이 변경",
            f"새 세로 길이({self.unit})를 입력하세요 (현재: {cur_h_m:.2f} {self.unit}):",
            minvalue=0.01
        )
        if new_h_m is None:
            return

        shared = self.find_shared_horizontal_edges(shape)
        shared_count = sum(1 for k in ("top", "bottom") if shared[k])

        if shared_count > 1:
            messagebox.showwarning(
                "변경 불가",
                "위·아래 변이 모두 다른 도형과 공유되고 있어 세로 길이를 변경할 수 없습니다."
            )
            return

        self.push_history()
        self.set_active_shape(shape)

        new_h_px = self.meter_to_pixel(new_h_m)
        new_y1 = y1
        new_y2 = y2

        if shared_count == 1:
            if shared["top"]:
                new_y1 = y1
                new_y2 = y1 + new_h_px
            else:
                new_y2 = y2
                new_y1 = y2 - new_h_px
        else:
            new_y1 = y1
            new_y2 = y1 + new_h_px

        min_size_px = 20
        if new_y2 - new_y1 < min_size_px:
            if shared_count == 1 and shared["bottom"]:
                new_y1 = new_y2 - min_size_px
            else:
                new_y2 = new_y1 + min_size_px

        shape.coords = (x1, new_y1, x2, new_y2)
        self.redraw_shape(shape)
        self.app.update_selected_area_label(self)

    # -------- 공간 텍스트 수정 --------

    def _find_space_label_by_item(self, item_id):
        for lab in self.generated_space_labels:
            if item_id in (
                lab["name_id"],
                lab["heat_norm_id"],
                lab["heat_equip_id"],
                lab["area_id"],
            ):
                return lab
        return None

    def on_space_name_click(self, event):
        item_id = event.widget.find_closest(event.x, event.y)[0]
        lab = self._find_space_label_by_item(item_id)
        if not lab:
            return
        # ensure hvac fields exist so popup initialization can rely on them
        try:
            cur_hvac_def = int(lab.get("hvac_type", 1))
        except Exception:
            cur_hvac_def = 1
        if 'hvac_text' not in lab:
            try:
                lab['hvac_text'] = f"{cur_hvac_def}. {HVAC_NAMES.get(cur_hvac_def, '')}"
            except Exception:
                lab['hvac_text'] = None
        if 'hvac_detail' not in lab:
            lab['hvac_detail'] = None
        # current name and hvac
        old = self.canvas.itemcget(lab["name_id"], "text")
        # extract bare name (remove existing hvac suffix like 'Room 1(1. 중앙공조)'
        # and trailing detail like '_1.PAC(냉방)')
        m = re.match(r'^(.*?)(?:\s*\(\d+\..*?\))?(?:_\d+\..*)?$', old)
        base_name = m.group(1).strip() if m else old

        # popup dialog with entry + combobox
        try:
            # ensure any transient overlay is removed so the dialog is visible
            try:
                self._destroy_total_overlay()
            except Exception:
                pass
        except Exception:
            pass
        dlg = tk.Toplevel(self.canvas.master)
        try:
            dlg.lift()
            try:
                dlg.wm_attributes('-topmost', True)
                dlg.after(60, lambda: dlg.wm_attributes('-topmost', False))
            except Exception:
                pass
        except Exception:
            pass
        dlg.transient(self.canvas.master)
        dlg.title("공간편집")
        # prefer letting the dialog size itself; enforce a reasonable minimum width/height
        try:
            dlg.minsize(750, 600)
        except Exception:
            try:
                dlg.geometry("750x600")
            except Exception:
                pass
        # Reserve a right-side column for the CSV table so left-side controls keep their positions
        try:
            dlg.grid_columnconfigure(0, weight=0)
            dlg.grid_columnconfigure(1, weight=0)
            # reserve a fixed min width for the table column so adding the table won't shift left widgets
            dlg.grid_columnconfigure(2, weight=0, minsize=480)
        except Exception:
            pass
        tk.Label(dlg, text="공간이름:").grid(row=0, column=0, padx=6, pady=6)
        name_entry = tk.Entry(dlg, width=30)
        name_entry.grid(row=0, column=1, padx=6, pady=6, sticky='w')
        name_entry.insert(0, base_name)

        tk.Label(dlg, text="공조방식:").grid(row=1, column=0, padx=6, pady=6)
        from tkinter import ttk
        hvac_var = tk.StringVar()
        # make combobox width match name_entry and align left
        combo = ttk.Combobox(dlg, textvariable=hvac_var, state='readonly', width=30)
        combo['values'] = [f"{k}. {v}" for k, v in HVAC_NAMES.items()]
        # initialize HVAC combobox display from stored lab values
        cur_hvac = lab.get("hvac_type", 1)
        hvac_text = lab.get('hvac_text', None)
        try:
            vals = list(combo['values'])
            if hvac_text and hvac_text in vals:
                combo.current(vals.index(hvac_text))
                hvac_var.set(hvac_text)
                # force visible text after the popup is mapped to avoid readonly rendering quirks
                dlg.after(10, lambda v=hvac_text: combo.set(v))
            else:
                # format from numeric hvac_type
                try:
                    hv_num = int(cur_hvac)
                except Exception:
                    hv_num = 1
                display = f"{hv_num}. {HVAC_NAMES.get(hv_num, '')}"
                if display in vals:
                    combo.current(vals.index(display))
                else:
                    combo.current(0)
                hvac_var.set(display)
                dlg.after(10, lambda v=display: combo.set(v))
        except Exception:
            try:
                combo.current(0)
            except Exception:
                pass
        combo.grid(row=1, column=1, padx=6, pady=6, sticky='w')

        # 공조 상세 콤보박스 추가 (will be enabled only when HVAC == 2)
        tk.Label(dlg, text="공조상세:").grid(row=2, column=0, padx=6, pady=6)
        hvac_detail_var = tk.StringVar()
        # match width with other controls and align left
        detail_combo = ttk.Combobox(dlg, textvariable=hvac_detail_var, state='readonly', width=30)
        # show stripped text (no numeric prefix)
        detail_combo['values'] = [
            "PAC(냉방)",
            "PAC(냉난방)",
            "EHP",
            "항온항습기",
        ]
        # set initial hvac_detail selection from stored lab value if any
        cur_detail = lab.get("hvac_detail", None)
        try:
            vals_d = list(detail_combo['values'])
            if cur_detail is not None and isinstance(cur_detail, int) and 1 <= cur_detail <= len(vals_d):
                di = int(cur_detail) - 1
                detail_combo.current(di)
                try:
                    dval = vals_d[di]
                    hvac_detail_var.set(dval)
                    dlg.after(10, lambda v=dval: detail_combo.set(v))
                except Exception:
                    pass
            else:
                try:
                    # stored hvac_detail_text is already stripped (no prefix)
                    prev = lab.get('hvac_detail_text', None)
                    if prev and prev in vals_d:
                        idx = vals_d.index(prev)
                        detail_combo.current(idx)
                        hvac_detail_var.set(prev)
                        dlg.after(10, lambda v=prev: detail_combo.set(v))
                    else:
                        detail_combo.set("")
                except Exception:
                    detail_combo.set("")
        except Exception:
            detail_combo.set("")
        # enable/disable detail_combo depending on current hvac type
        try:
            if int(cur_hvac) == 2:
                detail_combo.configure(state='readonly')
                if not cur_detail:
                    detail_combo.current(0)
            else:
                detail_combo.configure(state='disabled')
        except Exception:
            detail_combo.configure(state='disabled')
        detail_combo.grid(row=2, column=1, padx=6, pady=6, sticky='w')

        # compute and show total heat (kW) beneath the detail combobox
        total_kw = None
        try:
            area_text = self.canvas.itemcget(lab["area_id"], "text")
            norm_text = self.canvas.itemcget(lab["heat_norm_id"], "text")
            equip_text = self.canvas.itemcget(lab["heat_equip_id"], "text")

            def _extract_first_float(s: str) -> float:
                if not s:
                    return 0.0
                for tok in s.replace(',', ' ').split():
                    try:
                        return float(tok)
                    except Exception:
                        continue
                return 0.0

            # area might be like '100.00 m²' or similar
            area_val = _extract_first_float(area_text)
            norm_v = _extract_first_float(norm_text)
            equip_v = _extract_first_float(equip_text)

            total_kw = area_val * (norm_v + equip_v) / 1000.0
            heat_label = tk.Label(dlg, text=f"총 발열량: {total_kw:.3f} kW")
            heat_label.grid(row=3, column=0, columnspan=2, padx=6, pady=(4, 6), sticky='w')
            status_label = tk.Label(dlg, text="", fg="gray")
            status_label.grid(row=4, column=0, columnspan=2, padx=6, pady=(0,6), sticky='w')
            # prepare CSV table/placeholders (will be updated dynamically)
            csv_shown = None
            tbl = None
            csv_msg = None
            # fix vertical spacing of left-side rows (name, hvac, detail, heat_label)
            fixed_row_mins = {}
            try:
                dlg.update_idletasks()
                # map rows to widgets we want to lock and record initial heights
                row_widget_map = {
                    0: name_entry,
                    1: combo,
                    2: detail_combo,
                    3: heat_label
                }
                for r, w in row_widget_map.items():
                    try:
                        h = max(18, int(w.winfo_reqheight()) + 6)
                        fixed_row_mins[r] = h
                        dlg.grid_rowconfigure(r, minsize=h, weight=0)
                    except Exception:
                        try:
                            dlg.grid_rowconfigure(r, weight=0)
                        except Exception:
                            pass
            except Exception:
                fixed_row_mins = {}

            # table container on the right (keeps the left controls fixed when table appears/disappears)
            table_frame = tk.Frame(dlg, bd=0)
            try:
                table_frame.grid(row=0, column=2, rowspan=7, padx=6, pady=6, sticky='nsew')
            except Exception:
                try:
                    table_frame.grid(row=0, column=2, rowspan=7, padx=6, pady=6)
                except Exception:
                    pass

            # helper to make the Treeview cells (second column) editable inline
            def make_tree_editable(tv):
                # tv: Treeview instance
                def _on_double_click(event):
                    try:
                        row_id = tv.identify_row(event.y)
                        col = tv.identify_column(event.x)
                        # only allow editing the second column (value)
                        if not row_id or col != '#2':
                            return
                        bbox = tv.bbox(row_id, column=col)
                        if not bbox:
                            return
                        x, y, w, h = bbox
                        # get current value
                        vals = list(tv.item(row_id, 'values'))
                        cur = vals[1] if len(vals) > 1 else ''
                        # create Entry overlay
                        entry = tk.Entry(table_frame)
                        entry.insert(0, cur)
                        # place relative to treeview widget
                        # translate bbox x,y to table_frame coordinates
                        try:
                            # tv.winfo_rootx/winfo_rooty not used because placing in same parent simplifies
                            entry.place(x=x, y=y, width=w, height=h)
                        except Exception:
                            entry.place(x=x, y=y, width=w, height=h)
                        entry.focus_set()

                        def _save(e=None):
                            try:
                                new = entry.get()
                                vals2 = list(tv.item(row_id, 'values'))
                                if len(vals2) < 2:
                                    # pad
                                    while len(vals2) < 2:
                                        vals2.append('')
                                vals2[1] = new
                                tv.item(row_id, values=vals2)
                                # update underlying csv_shown if present (keep sync)
                                try:
                                    children = list(tv.get_children())
                                    idx = children.index(row_id)
                                    if csv_shown and 'values' in csv_shown and 0 <= idx < len(csv_shown['values']):
                                        t0 = csv_shown['values'][idx][0] if len(csv_shown['values'][idx]) > 0 else ''
                                        csv_shown['values'][idx] = (t0, new)
                                        # If the edited row is the first row (quantity), recompute target and update table column
                                        if idx == 0:
                                            try:
                                                qty = int(float(new)) if new is not None and new != '' else 1
                                            except Exception:
                                                try:
                                                    qty = int(new)
                                                except Exception:
                                                    qty = 1
                                            try:
                                                # recompute target and choose new column from preferred columns if available
                                                if total_kw is None:
                                                    tval = 0.0
                                                else:
                                                    tval = float(total_kw) / max(1, qty)
                                                # find headers matching sel_detail
                                                sel_detail_local = None
                                                try:
                                                    sel_detail_local = detail_combo.get().strip() if detail_combo.get() else None
                                                except Exception:
                                                    sel_detail_local = None
                                                local_rows = getattr(self.app, 'last_csv_rows', None)
                                                headers_local = local_rows[0] if local_rows else []
                                                preferred = []
                                                if sel_detail_local:
                                                    for ci, h in enumerate(headers_local):
                                                        try:
                                                            if sel_detail_local.lower() in str(h).lower():
                                                                preferred.append(ci)
                                                        except Exception:
                                                            continue
                                                # build candidate list from preferred columns; if none, leave unchanged
                                                cand = []
                                                if preferred:
                                                    for ci in preferred:
                                                        try:
                                                            v = float(local_rows[1][ci]) if local_rows and ci < len(local_rows[1]) else None
                                                            if v is not None:
                                                                cand.append((ci, v))
                                                        except Exception:
                                                            continue
                                                # select column whose second-row value is > tval and closest
                                                chosen = None
                                                if cand:
                                                    greater_local = [c for c in cand if c[1] > tval]
                                                    if greater_local:
                                                        chosen = min(greater_local, key=lambda x: x[1])
                                                    else:
                                                        lesser_local = [c for c in cand if c[1] <= tval]
                                                        if lesser_local:
                                                            chosen = min(lesser_local, key=lambda x: abs(x[1] - tval))
                                                # if chosen found, update csv_shown values to that column
                                                if chosen:
                                                    nci = chosen[0]
                                                    try:
                                                        new_values = [((r[0] if len(r) > 0 else ''), (r[nci] if nci < len(r) else '')) for r in (local_rows if local_rows else [])]
                                                        csv_shown['col_index'] = nci
                                                        csv_shown['header'] = headers_local[nci] if nci < len(headers_local) else csv_shown.get('header', '')
                                                        csv_shown['values'] = new_values
                                                        # ensure quantity row is first
                                                        try:
                                                            csv_shown['values'].insert(0, ("대수(Q'ty)", str(qty)))
                                                        except Exception:
                                                            pass
                                                        # refresh treeview display
                                                        try:
                                                            for it in tv.get_children():
                                                                tv.delete(it)
                                                            for idx2, (t0, v0) in enumerate(csv_shown['values']):
                                                                iid2 = tv.insert('', tk.END, values=(t0, v0))
                                                                if idx2 == 0:
                                                                    try:
                                                                        tv.item(iid2, tags=('qty',))
                                                                    except Exception:
                                                                        pass
                                                            try:
                                                                tv.tag_configure('qty', background='#3399ff', foreground='white')
                                                            except Exception:
                                                                pass
                                                        except Exception:
                                                            pass
                                                    except Exception:
                                                        pass
                                            except Exception:
                                                pass
                                except Exception:
                                    pass
                            except Exception:
                                pass
                            try:
                                entry.destroy()
                            except Exception:
                                pass

                        entry.bind('<Return>', _save)
                        entry.bind('<FocusOut>', _save)
                    except Exception:
                        return

                try:
                    tv.unbind('<Double-1>')
                except Exception:
                    pass
                tv.bind('<Double-1>', _on_double_click)

            def update_csv_table():
                nonlocal csv_shown, tbl, total_kw
                # re-apply fixed row min sizes so left-side vertical spacing does not change
                try:
                    for rr, hh in fixed_row_mins.items():
                        try:
                            dlg.grid_rowconfigure(rr, minsize=hh, weight=0)
                        except Exception:
                            pass
                except Exception:
                    pass
                try:
                    # CSV is stored on the application object (self.app)
                    rows = getattr(self.app, 'last_csv_rows', None)
                    # check current hvac selection (kept for informational use)
                    try:
                        cur_sel = combo.get()
                        hv = int(cur_sel.split('.')[0]) if cur_sel else int(lab.get('hvac_type', 1))
                    except Exception:
                        hv = int(lab.get('hvac_type', 1)) if lab.get('hvac_type', None) is not None else 1

                    # If HVAC is not 개별공조(2), do not show CSV-derived table here
                    try:
                        if int(hv) != 2:
                            if tbl is not None:
                                try:
                                    tbl.destroy()
                                except Exception:
                                    pass
                                tbl = None
                            csv_shown = None
                            try:
                                if csv_msg is not None:
                                    try:
                                        csv_msg.destroy()
                                    except Exception:
                                        pass
                                    csv_msg = None
                            except Exception:
                                pass
                            return
                    except Exception:
                        pass

                    # If CSV rows exist and total_kw is available, proceed
                    if not rows or total_kw is None or len(rows) < 2:
                        # no CSV rows or no total: remove table if present
                        if tbl is not None:
                            try:
                                tbl.destroy()
                            except Exception:
                                pass
                            tbl = None
                        csv_shown = None
                        # if no CSV loaded, show an instruction
                        try:
                            if not rows:
                                if csv_msg is None:
                                    csv_msg = tk.Label(dlg, text="CSV가 로드되지 않았습니다. 툴바의 'CSV로드'로 파일을 먼저 불러오세요.", fg="gray")
                                    csv_msg.grid(row=4, column=0, columnspan=2, padx=6, pady=(2,6), sticky='w')
                            else:
                                if csv_msg is not None:
                                    try:
                                        csv_msg.destroy()
                                    except Exception:
                                        pass
                                    csv_msg = None
                        except Exception:
                            pass
                        return

                    headers = rows[0]
                    second = rows[1]
                    # prefer columns where the CSV first-row header matches the selected 공조상세
                    try:
                        # if HVAC is not 개별공조 (2), ignore detail_combo value even if present
                        if int(hv) != 2:
                            sel_detail = None
                        else:
                            sel_detail = detail_combo.get().strip() if detail_combo.get() else None
                    except Exception:
                        sel_detail = None

                    headers = rows[0]
                    preferred_cols = []
                    if sel_detail:
                        for ci, h in enumerate(headers):
                            try:
                                if sel_detail.lower() in str(h).lower():
                                    preferred_cols.append(ci)
                            except Exception:
                                continue

                    candidates = []
                    # if sel_detail provided but no preferred columns found, do not show table
                    if sel_detail and not preferred_cols:
                        # No header match: show table with empty values and DO NOT run fallback selection.
                        try:
                            first_col_vals = [((r[0] if len(r) > 0 else ''), '') for r in rows]
                        except Exception:
                            first_col_vals = []
                        csv_shown = {
                            'col_index': None,
                            'header': sel_detail if sel_detail else '',
                            'values': first_col_vals
                        }
                        # remove any CSV-not-loaded message
                        try:
                            if csv_msg is not None:
                                try:
                                    csv_msg.destroy()
                                except Exception:
                                    pass
                                csv_msg = None
                        except Exception:
                            pass
                        # create or update treeview immediately with empty values and return
                        try:
                            from tkinter import ttk
                            if tbl is None:
                                tbl = ttk.Treeview(table_frame, columns=("title", "value"), show='headings', height=15)
                                first_col_name = rows[0][0] if rows and len(rows) > 0 and len(rows[0]) > 0 else ""
                                try:
                                    tbl.heading('title', text=first_col_name)
                                except Exception:
                                    tbl.heading('title', text='')
                                tbl.heading('value', text=csv_shown['header'])
                                tbl.column('title', width=180, anchor='w')
                                tbl.column('value', width=300, anchor='w')
                                try:
                                    tbl.pack(fill=tk.BOTH, expand=True)
                                except Exception:
                                    tbl.grid(row=0, column=0, sticky='nsew')
                                try:
                                    make_tree_editable(tbl)
                                except Exception:
                                    pass
                            else:
                                tbl.heading('value', text=csv_shown['header'])
                                for it in tbl.get_children():
                                    tbl.delete(it)
                            for title, val in csv_shown['values']:
                                tbl.insert('', tk.END, values=(title, val))
                            try:
                                status_label.configure(text=f"CSV 로드: {len(rows)}행, 선택열 없음 (공조상세 일치 없음)")
                            except Exception:
                                pass
                        except Exception:
                            pass
                        return

                    # if we have preferred columns from header matching, only consider them
                    if preferred_cols:
                        for ci in preferred_cols:
                            try:
                                v = float(second[ci]) if ci < len(second) else None
                                if v is not None:
                                    candidates.append((ci, v))
                            except Exception:
                                continue
                    else:
                        for ci, val in enumerate(second):
                            try:
                                v = float(val)
                                candidates.append((ci, v))
                            except Exception:
                                continue

                    if not candidates:
                        if tbl is not None:
                            try:
                                tbl.destroy()
                            except Exception:
                                pass
                            tbl = None
                        csv_shown = None
                        return

                    # Special selection when we have preferred columns (header match)
                    import math
                    # if user previously saved a quantity for this lab, prefer it
                    stored_qty = None
                    try:
                        if 'hvac_qty' in lab and lab.get('hvac_qty') is not None:
                            stored_qty = int(lab.get('hvac_qty'))
                    except Exception:
                        stored_qty = None
                    if preferred_cols and sel_detail:
                        # consider only the candidate values (from preferred columns)
                        vals_only = [c[1] for c in candidates]
                        max_val = max(vals_only) if vals_only else 0.0
                        # Assumptions:
                        # - If total_kw < max_val -> divide total by 2, use qty=2.
                        # - If total_kw > max_val -> compute ratio = total_kw / max_val,
                        #   take qty = ceil(ratio) + 2 (integer), then target = total_kw / qty.
                        # These are inferred from the user's description.
                        try:
                            if total_kw is None:
                                total_kw = 0.0
                        except Exception:
                            total_kw = 0.0

                        # if stored_qty exists, use it; else compute per original logic
                        if stored_qty is not None:
                            qty = stored_qty
                            target = total_kw / max(1, qty)
                        else:
                            if max_val > 0 and total_kw < max_val:
                                target = total_kw / 2.0
                                qty = 2
                            else:
                                if max_val > 0:
                                    ratio = total_kw / max_val
                                else:
                                    ratio = total_kw
                                qty = int(math.ceil(ratio)) + 2
                                if qty <= 0:
                                    qty = 2
                                target = total_kw / qty if qty != 0 else total_kw

                        # pick candidate column closest above target, else largest below
                        greater = [c for c in candidates if c[1] >= target]
                        if greater:
                            best = min(greater, key=lambda x: x[1])
                        else:
                            lesser = [c for c in candidates if c[1] < target]
                            if lesser:
                                best = max(lesser, key=lambda x: x[1])
                            else:
                                best = candidates[0]
                        ci, cv = best
                        csv_shown = {
                            'col_index': ci,
                            'header': headers[ci] if ci < len(headers) else f'C{ci+1}',
                            # values: tuples of (first-column title, selected-column value) per row
                            'values': [((r[0] if len(r) > 0 else ''), (r[ci] if ci < len(r) else '')) for r in rows]
                        }
                        # prepend quantity row with computed qty
                        try:
                            # if user has a stored qty prefer that display
                            csv_shown['values'].insert(0, ("대수(Q'ty)", str(qty)))
                        except Exception:
                            pass
                    else:
                        # default selection logic (no header-priority special rules)
                        greater = [c for c in candidates if c[1] >= total_kw]
                        if greater:
                            best = min(greater, key=lambda x: x[1])
                        else:
                            lesser = [c for c in candidates if c[1] < total_kw]
                            if lesser:
                                best = max(lesser, key=lambda x: x[1])
                            else:
                                best = candidates[0]
                        ci, cv = best
                        csv_shown = {
                            'col_index': ci,
                            'header': headers[ci] if ci < len(headers) else f'C{ci+1}',
                            # values: tuples of (first-column title, selected-column value) per row
                            'values': [((r[0] if len(r) > 0 else ''), (r[ci] if ci < len(r) else '')) for r in rows]
                        }
                        # If we found preferred columns by header match, prepend a quantity row as before
                        try:
                            if preferred_cols:
                                try:
                                    stored_qty2 = int(lab.get('hvac_qty')) if lab.get('hvac_qty') is not None else None
                                except Exception:
                                    stored_qty2 = None
                                if stored_qty2 is not None:
                                    csv_shown['values'].insert(0, ("대수(Q'ty)", str(stored_qty2)))
                                else:
                                    csv_shown['values'].insert(0, ("대수(Q'ty)", "1"))
                        except Exception:
                            pass

                    # create or update treeview
                    try:
                        from tkinter import ttk
                        if tbl is None:
                            # place Treeview inside reserved table_frame so left controls don't shift
                            tbl = ttk.Treeview(table_frame, columns=("title", "value"), show='headings', height=15)
                            # first column shows the row title (CSV first column), second shows selected value
                            first_col_name = headers[0] if headers and len(headers) > 0 else ""
                            try:
                                tbl.heading('title', text=first_col_name)
                            except Exception:
                                tbl.heading('title', text='')
                            tbl.heading('value', text=csv_shown['header'])
                            tbl.column('title', width=180, anchor='w')
                            tbl.column('value', width=300, anchor='w')
                            try:
                                tbl.pack(fill=tk.BOTH, expand=True)
                            except Exception:
                                tbl.grid(row=0, column=0, sticky='nsew')
                            # make cells editable
                            try:
                                make_tree_editable(tbl)
                            except Exception:
                                pass
                        else:
                            tbl.heading('value', text=csv_shown['header'])
                            for it in tbl.get_children():
                                tbl.delete(it)

                        # remove any CSV-not-loaded message
                        try:
                            if csv_msg is not None:
                                try:
                                    csv_msg.destroy()
                                except Exception:
                                    pass
                                csv_msg = None
                        except Exception:
                            pass

                        for idx, (title, val) in enumerate(csv_shown['values']):
                            iid = tbl.insert('', tk.END, values=(title, val))
                            # tag the first row (quantity row) to have a blue background
                            if idx == 0:
                                try:
                                    tbl.item(iid, tags=('qty',))
                                except Exception:
                                    pass
                        try:
                            tbl.tag_configure('qty', background='#3399ff', foreground='white')
                        except Exception:
                            pass
                        # ensure popup width can contain the table
                        try:
                            dlg.update_idletasks()
                            req = table_frame.winfo_reqwidth()
                            cur_w = dlg.winfo_width()
                            # reserve ~380px for left controls; expand dlg width if table would be clipped
                            min_total = req + 380
                            if cur_w < min_total:
                                try:
                                    dlg.geometry(f"{min_total}x{dlg.winfo_height()}")
                                except Exception:
                                    pass
                        except Exception:
                            pass

                        # update status label if present
                        try:
                            status_label.configure(text=f"CSV 로드: {len(rows)}행, 선택열: {csv_shown['header']}")
                        except Exception:
                            pass
                    except Exception:
                        # ensure no half-created widget remains
                        try:
                            if tbl is not None:
                                tbl.destroy()
                        except Exception:
                            pass
                        tbl = None
                except Exception:
                    csv_shown = None
                    try:
                        if tbl is not None:
                            tbl.destroy()
                    except Exception:
                        pass
                    tbl = None

            # schedule initial csv table update after the popup widgets settle
            try:
                dlg.after(50, lambda: (update_csv_table()))
            except Exception:
                try:
                    update_csv_table()
                except Exception:
                    pass
        except Exception:
            # fallback: show nothing if parsing fails
            heat_label = tk.Label(dlg, text="총 발열량: - kW")
            heat_label.grid(row=3, column=0, columnspan=2, padx=6, pady=(4, 6), sticky='w')
            csv_shown = None

    # when HVAC selection changes, toggle the detail combobox
        def _on_hvac_change(event=None):
            sel = combo.get()
            try:
                hv = int(sel.split('.')[0])
            except Exception:
                hv = 1
            if hv == 2:
                detail_combo.configure(state='readonly')
                # if no previous detail, default to first
                if not detail_combo.get():
                    detail_combo.current(0)
            else:
                # clear detail selection and disable
                detail_combo.set("")
                detail_combo.configure(state='disabled')
            # update CSV table view when HVAC selection changes
            try:
                update_csv_table()
            except Exception:
                pass

        combo.bind("<<ComboboxSelected>>", _on_hvac_change)
        # also update CSV table when 공조상세 selection changes
        try:
            detail_combo.bind("<<ComboboxSelected>>", lambda e: update_csv_table())
        except Exception:
            pass

        def on_ok():
            new_name = name_entry.get().strip()
            if not new_name:
                return
            sel = combo.get()
            # determine hvac number: prefer parsed combo, fallback to existing lab value
            try:
                if sel:
                    num = int(sel.split('.')[0])
                else:
                    num = int(lab.get('hvac_type', 1))
            except Exception:
                try:
                    num = int(lab.get('hvac_type', 1))
                except Exception:
                    num = 1
            # detail: determine numeric index from combobox (values are stripped text)
            dsel = detail_combo.get()
            prev_detail = lab.get('hvac_detail', None)
            dnum = prev_detail
            try:
                if dsel:
                    vals_d = list(detail_combo['values'])
                    if dsel in vals_d:
                        dnum = vals_d.index(dsel) + 1
                    else:
                        # fallback: try matching after removing possible 'N. ' prefix from candidates
                        stripped = [v[3:].strip() if len(v) > 3 and v[1] == '.' else v for v in vals_d]
                        if dsel in stripped:
                            dnum = stripped.index(dsel) + 1
                        else:
                            dnum = prev_detail
                else:
                    dnum = prev_detail
            except Exception:
                dnum = prev_detail
            # persist: do NOT display hvac or detail on palette; only store values in lab
            full = new_name
            self.push_history()
            self.canvas.itemconfigure(lab["name_id"], text=full)
            lab["hvac_type"] = num
            # store full display text of the selected HVAC (e.g. '2. 개별공조')
            try:
                lab["hvac_text"] = combo.get().strip() if combo.get() else None
            except Exception:
                lab["hvac_text"] = None
            # store hvac_detail numeric and stripped text; clear if hvac != 2
            try:
                if int(num) == 2:
                    if dnum is None:
                        lab["hvac_detail"] = prev_detail if prev_detail is not None else 1
                    else:
                        lab["hvac_detail"] = int(dnum)
                    # store stripped text (no numeric prefix)
                    try:
                        lab["hvac_detail_text"] = detail_combo.get().strip() if detail_combo.get() else lab.get('hvac_detail_text', None)
                    except Exception:
                        lab["hvac_detail_text"] = lab.get('hvac_detail_text', None)
                else:
                    lab["hvac_detail"] = None
                    lab["hvac_detail_text"] = None
            except Exception:
                lab["hvac_detail"] = None
                lab["hvac_detail_text"] = None
            # If csv_shown exists and its first row is the quantity row, persist that quantity into the label
            try:
                if csv_shown and 'values' in csv_shown and len(csv_shown['values']) > 0:
                    first_title, first_val = csv_shown['values'][0]
                    if isinstance(first_title, str) and "대수" in first_title:
                        try:
                            qv = int(float(first_val)) if first_val is not None and str(first_val).strip() != '' else None
                        except Exception:
                            try:
                                qv = int(str(first_val))
                            except Exception:
                                qv = None
                        if qv is not None:
                            lab['hvac_qty'] = qv
            except Exception:
                pass
            dlg.destroy()
            
            # Room Design 탭이 활성화되어 있을 때만 자동 작업 수행
            try:
                # 현재 활성화된 팔레트가 있는지 확인
                if self.app and hasattr(self.app, 'get_current_palette'):
                    current_palette = self.app.get_current_palette()
                    # 이 팔레트가 self와 같은지 확인 (Room Design 탭)
                    if current_palette is self:
                        # 1. 자동생성 실행
                        try:
                            self.app.auto_generate_current()
                        except Exception as e:
                            print(f"자동생성 실행 오류: {e}")
                        
                        # 2. 급기 풍량 산정 실행
                        try:
                            self.app._on_calc_supply_flow()
                        except Exception as e:
                            print(f"급기 풍량 산정 실행 오류: {e}")
                        
                        # 3. 디퓨저 자동 배치 실행
                        try:
                            self.app._on_place_diffusers()
                        except Exception as e:
                            print(f"디퓨저 자동 배치 실행 오류: {e}")
            except Exception as e:
                print(f"자동 작업 수행 중 오류: {e}")

        def on_cancel():
            dlg.destroy()

        # if csv_shown prepared at popup creation time, place an initial empty table in the reserved frame
        if csv_shown:
            try:
                from tkinter import ttk
                tbl = ttk.Treeview(table_frame, columns=("title","value"), show='headings', height=15)
                try:
                    rows_top = getattr(self.app, 'last_csv_rows', None)
                    first_col_name = rows_top[0][0] if rows_top and len(rows_top) > 0 and len(rows_top[0]) > 0 else ""
                except Exception:
                    first_col_name = ""
                try:
                    tbl.heading('title', text=first_col_name)
                except Exception:
                    tbl.heading('title', text='')
                tbl.heading('value', text=csv_shown['header'])
                tbl.column('title', width=180, anchor='w')
                tbl.column('value', width=300, anchor='w')
                for idx, (title, val) in enumerate(csv_shown['values']):
                    iid = tbl.insert('', tk.END, values=(title, val))
                    if idx == 0:
                        try:
                            tbl.item(iid, tags=('qty',))
                        except Exception:
                            pass
                try:
                    tbl.pack(fill=tk.BOTH, expand=True)
                except Exception:
                    tbl.grid(row=0, column=0, sticky='nsew')
                # make editable and style first row
                try:
                    make_tree_editable(tbl)
                except Exception:
                    pass
                try:
                    tbl.tag_configure('qty', background='#3399ff', foreground='white')
                except Exception:
                    pass
                # resize dialog if table would be clipped
                try:
                    dlg.update_idletasks()
                    req = table_frame.winfo_reqwidth()
                    cur_w = dlg.winfo_width()
                    min_total = req + 380
                    if cur_w < min_total:
                        try:
                            dlg.geometry(f"{min_total}x{dlg.winfo_height()}")
                        except Exception:
                            pass
                except Exception:
                    pass
            except Exception:
                csv_shown = None

        # 버튼을 grid 레이아웃으로 명확한 row에 배치 (항상 보이도록)
        btn_frame = tk.Frame(dlg)
        btn_frame.grid(row=10, column=0, columnspan=3, sticky='ew', padx=6, pady=12)
        ok_btn = tk.Button(btn_frame, text="확인", command=on_ok, width=10)
        ok_btn.pack(side='left', padx=6)
        cancel_btn = tk.Button(btn_frame, text="취소", command=on_cancel, width=10)
        cancel_btn.pack(side='left', padx=6)
        name_entry.focus_set()

    def on_space_heat_norm_click(self, event):
        item_id = event.widget.find_closest(event.x, event.y)[0]
        lab = self._find_space_label_by_item(item_id)
        if not lab:
            return
        old_text = self.canvas.itemcget(lab["heat_norm_id"], "text")
        try:
            num_str = old_text.split(":")[1].replace("W/m²", "").strip()
            old_val = float(num_str)
        except Exception:
            old_val = 0.0
        new_val = simpledialog.askfloat(
            "일반 발열량 변경",
            "새 일반 발열량 (W/m²)을 입력하세요:",
            initialvalue=old_val,
            minvalue=0.0
        )
        if new_val is None:
            return
        self.push_history()
        self.canvas.itemconfigure(
            lab["heat_norm_id"],
            text=f"Norm: {new_val:.2f} W/m²"
        )

    def on_space_heat_equip_click(self, event):
        item_id = event.widget.find_closest(event.x, event.y)[0]
        lab = self._find_space_label_by_item(item_id)
        if not lab:
            return
        old_text = self.canvas.itemcget(lab["heat_equip_id"], "text")
        try:
            num_str = old_text.split(":")[1].replace("W/m²", "").strip()
            old_val = float(num_str)
        except Exception:
            old_val = 0.0
        new_val = simpledialog.askfloat(
            "장비 발열량 변경",
            "새 장비 발열량 (W/m²)을 입력하세요:",
            initialvalue=old_val,
            minvalue=0.0
        )
        if new_val is None:
            return
        self.push_history()
        self.canvas.itemconfigure(
            lab["heat_equip_id"],
            text=f"Equip: {new_val:.2f} W/m²"
        )

    # -------- 오른쪽 클릭 --------

    def on_right_click(self, event):
        px, py = event.x, event.y
        shape, idx, cx, cy = self.detect_corner_under_mouse(px, py)
        if shape is not None:
            self.corner_menu_target_shape = shape
            try:
                self.corner_menu.tk_popup(event.x_root, event.y_root)
            finally:
                self.corner_menu.grab_release()
            return

        if not self.shapes:
            return

        best_corner = None
        best_d2 = None
        for shape in self.shapes:
            x1, y1, x2, y2 = shape.coords
            corners = [(x1, y1), (x2, y1), (x1, y2), (x2, y2)]
            for cx, cy in corners:
                d2 = (cx - px) ** 2 + (cy - py) ** 2
                if best_d2 is None or d2 < best_d2:
                    best_d2 = d2
                    best_corner = (cx, cy)

        if best_corner is None:
            return

        self.push_history()
        cx, cy = best_corner
        new_shape = self.create_rect_shape(cx, cy, px, py, editable=True, color="blue",
                                           push_to_history=False)
        self.set_active_shape(new_shape)

    # -------- Shapely 기반 자동 공간 생성 (텍스트 유지/새로 생성 규칙) --------

    def auto_generate_space_labels(self):
        if not self.shapes:
            messagebox.showinfo("자동생성", "도형이 없습니다.")
            return

        # 1. 모든 사각형의 경계선을 LineString으로 모음
        lines = []
        for s in self.shapes:
            x1, y1, x2, y2 = s.coords
            lines.append(LineString([[x1, y1], [x2, y1]]))
            lines.append(LineString([[x2, y1], [x2, y2]]))
            lines.append(LineString([[x2, y2], [x1, y2]]))
            lines.append(LineString([[x1, y2], [x1, y1]]))

        merged = unary_union(lines)
        polys = list(polygonize(merged))

        if not polys:
            messagebox.showinfo("자동생성", "밀폐된 공간을 찾지 못했습니다.")
            return

        valid_polys = []
        for p in polys:
            area_px2 = p.area
            area_m2 = area_px2 / (self.scale * self.scale)
            if area_m2 > 0.01:
                valid_polys.append((p, area_m2))

        if not valid_polys:
            messagebox.showinfo("자동생성", "유효한 공간이 없습니다.")
            return

        self.push_history()

        # 면적 기준 정렬
        valid_polys.sort(key=lambda x: x[1])

        # 기존 라벨의 텍스트 위치(캔버스 좌표) 및 텍스트 정보 목록
        existing_centers = []
        for lab in self.generated_space_labels:
            poly_old = lab["polygon"]
            try:
                name_coords = self.canvas.coords(lab["name_id"])
                if name_coords:
                    nx, ny = name_coords[0], name_coords[1]
                else:
                    rep_old = poly_old.representative_point()
                    nx, ny = rep_old.x, rep_old.y
            except Exception:
                rep_old = poly_old.representative_point()
                nx, ny = rep_old.x, rep_old.y

            name_text = self.canvas.itemcget(lab["name_id"], "text")
            heat_norm_text = self.canvas.itemcget(lab["heat_norm_id"], "text")
            heat_equip_text = self.canvas.itemcget(lab["heat_equip_id"], "text")
            room_number = None
            if name_text.lower().startswith("room"):
                try:
                    room_number = int(name_text.split()[1])
                except Exception:
                    room_number = None
            
            diffuser_ids = lab.get("diffuser_ids", [])
            existing_centers.append((lab, nx, ny, name_text, heat_norm_text, heat_equip_text, room_number, diffuser_ids))

        used_existing = []   
        new_labels = []

        max_room_index = 0
        for lab in self.generated_space_labels:
            name_text = self.canvas.itemcget(lab["name_id"], "text")
            if name_text.lower().startswith("room"):
                try:
                    idx = int(name_text.split()[1])
                    if idx > max_room_index:
                        max_room_index = idx
                except Exception:
                    pass

        next_room_index = max_room_index + 1 if max_room_index > 0 else 1

        for p, area_m2 in valid_polys:
            cent = p.centroid
            cx, cy = cent.x, cent.y

            matched = None
            matched_name = None
            matched_norm = None
            matched_equip = None
            matched_room_number = None
            matched_diffusers = []

            for lab, nx, ny, name_text, heat_norm_text, heat_equip_text, room_number, diffuser_ids in existing_centers:
                try:
                    if p.contains(Point(nx, ny)):
                        matched = lab
                        matched_name = name_text
                        matched_norm = heat_norm_text
                        matched_equip = heat_equip_text
                        matched_room_number = room_number
                        matched_diffusers = diffuser_ids
                        break
                except Exception:
                    continue

            if matched is not None:
                # 기존 라벨 유지, 면적만 갱신
                name_id = matched["name_id"]
                heat_norm_id = matched["heat_norm_id"]
                heat_equip_id = matched["heat_equip_id"]
                area_id = matched["area_id"]

                self.canvas.itemconfigure(area_id, text=f"{area_m2:.2f} m²")
                if matched_room_number is not None:
                    # preserve hvac_type if present in matched
                    # Do not display hvac on the palette; show only the room number/name
                    self.canvas.itemconfigure(name_id, text=f"Room {matched_room_number}")
                else:
                    # if matched_name has hvac in suffix preserve, else leave as-is
                    if '(' in matched_name and ')' in matched_name:
                        self.canvas.itemconfigure(name_id, text=matched_name)
                    else:
                        # preserve matched_name as-is (do not append hvac)
                        self.canvas.itemconfigure(name_id, text=matched_name)
                self.canvas.itemconfigure(heat_norm_id, text=matched_norm)
                self.canvas.itemconfigure(heat_equip_id, text=matched_equip)

                new_labels.append({
                    "polygon": p,
                    "name_id": name_id,
                    "heat_norm_id": heat_norm_id,
                    "heat_equip_id": heat_equip_id,
                    "area_id": area_id,
                    "diffuser_ids": matched_diffusers, # 기존 디퓨저 점 유지
                    "hvac_type": matched.get('hvac_type', 1) if isinstance(matched, dict) else 1,
                    # Preserve HVAC metadata if present on the matched label so popup selections
                    # (공조방식/공조상세) survive auto-generation.
                    "hvac_text": matched.get('hvac_text') if isinstance(matched, dict) else None,
                    "hvac_detail": matched.get('hvac_detail') if isinstance(matched, dict) else None,
                    "hvac_detail_text": matched.get('hvac_detail_text') if isinstance(matched, dict) else None,
                    "hvac_qty": matched.get('hvac_qty') if isinstance(matched, dict) else None
                })
                used_existing.append(matched)
            else:
                # 새 라벨
                name_text = f"Room {next_room_index}"
                next_room_index += 1

                heat_norm_text = "Norm: 0.00 W/m²"
                heat_equip_text = "Equip: 0.00 W/m²"
                area_text = f"{area_m2:.2f} m²"

                name_id = self.canvas.create_text(
                    cx, cy,
                    text=name_text,
                    fill="blue",
                    font=("Arial", 11, "bold"),
                    tags=("space_name",)
                )
                heat_norm_id = self.canvas.create_text(
                    cx, cy + 14,
                    text=heat_norm_text,
                    fill="darkred",
                    font=("Arial", 10),
                    tags=("space_heat_norm",)
                )
                heat_equip_id = self.canvas.create_text(
                    cx, cy + 28,
                    text=heat_equip_text,
                    fill="darkred",
                    font=("Arial", 10),
                    tags=("space_heat_equip",)
                )
                area_id = self.canvas.create_text(
                    cx, cy + 42,
                    text=area_text,
                    fill="green",
                    font=("Arial", 10)
                )

                # default hvac type = 1 (중앙공조)
                hvac_type = 1
                # display only base name on palette (do not append hvac)
                name_text_with_hvac = name_text
                new_labels.append({
                    "polygon": p,
                    "name_id": name_id,
                    "heat_norm_id": heat_norm_id,
                    "heat_equip_id": heat_equip_id,
                    "area_id": area_id,
                    "diffuser_ids": [],
                    "hvac_type": hvac_type,
                    # ensure hvac_text and hvac_detail are present for later popup uses
                    "hvac_text": f"{hvac_type}. {HVAC_NAMES.get(hvac_type, '')}",
                    "hvac_detail": None
                })
                # set displayed name (base name only)
                self.canvas.itemconfigure(name_id, text=name_text_with_hvac)

        # 기존 라벨 중 사용되지 않은 것 삭제
        for lab in self.generated_space_labels:
            if lab not in used_existing:
                self.canvas.delete(lab["name_id"])
                self.canvas.delete(lab["heat_norm_id"])
                self.canvas.delete(lab["heat_equip_id"])
                self.canvas.delete(lab["area_id"])
                # 디퓨저도 삭제
                if "diffuser_ids" in lab:
                    for did in lab["diffuser_ids"]:
                        self.canvas.delete(did)

        self.generated_space_labels = new_labels

    # -------- 일괄 발열량 적용 --------

    def apply_norm_to_all(self, value: float):
        if not self.generated_space_labels:
            return
        self.push_history()
        for lab in self.generated_space_labels:
            try:
                self.canvas.itemconfigure(lab["heat_norm_id"], text=f"Norm: {value:.2f} W/m²")
            except Exception:
                continue

    def apply_equip_to_all(self, value: float):
        if not self.generated_space_labels:
            return
        self.push_history()
        for lab in self.generated_space_labels:
            try:
                self.canvas.itemconfigure(lab["heat_equip_id"], text=f"Equip: {value:.2f} W/m²")
            except Exception:
                continue

    def compute_and_apply_supply_flow(self):
        if not self.generated_space_labels:
            return 0.0

        try:
            indoor_t = float(self.app.indoor_temp_entry.get())
            supply_t = float(self.app.supply_temp_entry.get())
        except Exception:
            messagebox.showerror("입력 오류", "실내/급기 온도를 올바르게 입력하세요.")
            return 0.0

        delta_t = indoor_t - supply_t
        if delta_t <= 0:
            messagebox.showerror("입력 오류", "실내 온도는 급기 온도보다 높아야 합니다.")
            return 0.0

        total_flow = 0
        for lab in self.generated_space_labels:
            try:
                area_text = self.canvas.itemcget(lab["area_id"], "text")
                area_val = 0.0
                for tok in area_text.split():
                    try:
                        area_val = float(tok)
                        break
                    except Exception:
                        continue

                norm_text = self.canvas.itemcget(lab["heat_norm_id"], "text")
                equip_text = self.canvas.itemcget(lab["heat_equip_id"], "text")
                
                def extract_num(s: str) -> float:
                    for part in s.replace(',', ' ').split():
                        try:
                            return float(part)
                        except Exception:
                            continue
                    return 0.0

                norm_v = extract_num(norm_text)
                equip_v = extract_num(equip_text)

                raw_flow = area_val * (norm_v + equip_v) * 860.0 / 1.2 / 0.24 / 1000.0 / delta_t
                flow_int = int(ceil(raw_flow))
                total_flow += flow_int

                flow_text = f"{flow_int:,}"
                # store numeric supply flow value on the lab for later distribution
                try:
                    lab["supply_flow_value"] = float(flow_int)
                except Exception:
                    lab["supply_flow_value"] = float(raw_flow) if raw_flow else float(flow_int)

                # Try to update existing flow text if present
                updated = False
                if "flow_id" in lab:
                    try:
                        fid = lab["flow_id"]
                        if fid in self.canvas.find_all():
                            self.canvas.itemconfigure(fid, text=f"Flow: {flow_text} m3/hr")
                            updated = True
                        else:
                            # stale id, remove key
                            lab.pop("flow_id", None)
                    except Exception:
                        lab.pop("flow_id", None)

                if not updated:
                    # remove any stray flow texts near the area to avoid duplicates
                    try:
                        x, y = self.canvas.coords(lab["area_id"])
                        # small bbox around area text
                        bx1, by1 = x - 10, y
                        bx2, by2 = x + 10, y + 28
                        for item in self.canvas.find_overlapping(bx1, by1, bx2, by2):
                            try:
                                if self.canvas.type(item) == 'text':
                                    txt = self.canvas.itemcget(item, 'text')
                                    if isinstance(txt, str) and txt.strip().startswith('Flow:'):
                                        self.canvas.delete(item)
                            except Exception:
                                continue
                    except Exception:
                        pass

                    # create new flow text and tag it
                    try:
                        x, y = self.canvas.coords(lab["area_id"])
                        fid = self.canvas.create_text(x, y + 14, text=f"Flow: {flow_text} m3/hr",
                                                      fill="purple", font=("Arial", 10), tags=("flow",))
                        lab["flow_id"] = fid
                        # distribute the numeric supply flow among Supply diffusers if present
                        try:
                            if float(lab.get("supply_flow_value", 0)) > 0:
                                try:
                                    self._distribute_supply_for_lab(lab)
                                except Exception:
                                    pass
                        except Exception:
                            pass
                    except Exception:
                        pass
            except Exception:
                continue

        return total_flow

    def _distribute_supply_for_lab(self, lab: dict):
        """Distribute lab['supply_flow_value'] equally among supply diffusers in lab.
        Create/update small text labels near each supply diffuser and store numeric mapping
        on lab['diffuser_flows'] keyed by diffuser id.
        """
        try:
            total = float(lab.get("supply_flow_value", 0.0))
        except Exception:
            return
        if total <= 0:
            return
        # collect diffusers and split into supply / return groups
        supply_ids = []
        return_ids = []
        for did in lab.get("diffuser_ids", []):
            try:
                tags = self.canvas.gettags(did)
            except Exception:
                tags = ()
            try:
                if 'supply' in tags:
                    supply_ids.append(did)
                elif 'return' in tags:
                    return_ids.append(did)
                else:
                    # if neither tag present, treat as supply by default
                    supply_ids.append(did)
            except Exception:
                # fallback: treat as supply
                try:
                    supply_ids.append(did)
                except Exception:
                    continue

        # ensure mapping exists
        lab.setdefault("diffuser_flows", {})

        # if no diffusers at all, clear mapping and return
        if not supply_ids and not return_ids:
            lab["diffuser_flows"].clear()
            return

        # distribute total among supply diffusers (if any)
        try:
            if supply_ids:
                per_supply = round(float(total) / len(supply_ids), 2)
                for did in supply_ids:
                    try:
                        lab["diffuser_flows"][did] = per_supply
                    except Exception:
                        continue
        except Exception:
            pass

        # distribute total among return diffusers (if any)
        try:
            if return_ids:
                per_return = round(float(total) / len(return_ids), 2)
                for did in return_ids:
                    try:
                        lab["diffuser_flows"][did] = per_return
                    except Exception:
                        continue
        except Exception:
            pass

    # -------- 디퓨저 자동 배치 로직 --------

    def _decide_grid_rc(self, N: int, width: float, height: float):
        """N개의 점을 width x height 영역에 배치할 때 행(r), 열(c) 결정"""
        if N <= 0:
            return 0, 0
        if N == 1:
            return 1, 1

        best_r, best_c = 1, N
        target_ratio = (width / height) if height > 1e-6 else 1.0
        best_diff = None

        # 행을 1부터 N까지 변화시키며 최적 비율 찾기
        for r in range(1, N + 1):
            c = ceil(N / r)
            if r * c < N:
                continue
            grid_ratio = c / r
            diff = abs(grid_ratio - target_ratio)
            if best_diff is None or diff < best_diff:
                best_diff = diff
                best_r, best_c = r, c

        return best_r, best_c

    def _select_points_greedy_maxmin(self, points, k: int):
        """Select k points from list 'points' using greedy max-min (farthest-first)"""
        if k <= 0 or not points:
            return []
        pts = list(points)
        # start with point farthest from centroid
        cx = sum(p[0] for p in pts) / len(pts)
        cy = sum(p[1] for p in pts) / len(pts)
        dists = [((p[0]-cx)**2 + (p[1]-cy)**2, i) for i, p in enumerate(pts)]
        dists.sort(reverse=True)
        sel = [pts[dists[0][1]]]
        used = {dists[0][1]}
        while len(sel) < k and len(used) < len(pts):
            best_i = None
            best_min = -1
            for i, p in enumerate(pts):
                if i in used:
                    continue
                # distance to nearest selected
                min_d = min((p[0]-q[0])**2 + (p[1]-q[1])**2 for q in sel)
                if min_d > best_min:
                    best_min = min_d
                    best_i = i
            if best_i is None:
                break
            used.add(best_i)
            sel.append(pts[best_i])
        return sel

    def _select_with_min_separation(self, points, k: int, min_px: float):
        """Greedy selection ensuring each new point is at least min_px from existing picks.
        If full k can't be satisfied, the function will try to relax the min_px gradually.
        """
        if k <= 0 or not points:
            return []
        pts = list(points)
        # try with decreasing thresholds until we get k points or threshold reaches 0
        thr = float(min_px)
        while thr >= 0:
            sel = []
            # start with farthest-from-centroid seed
            cx = sum(p[0] for p in pts) / len(pts)
            cy = sum(p[1] for p in pts) / len(pts)
            dists = [((p[0]-cx)**2 + (p[1]-cy)**2, i) for i, p in enumerate(pts)]
            dists.sort(reverse=True)
            used_idx = set()
            sel.append(pts[dists[0][1]])
            used_idx.add(dists[0][1])
            for i, p in enumerate(pts):
                if len(sel) >= k:
                    break
                if i in used_idx:
                    continue
                min_d2 = min((p[0]-q[0])**2 + (p[1]-q[1])**2 for q in sel)
                if min_d2 >= thr*thr:
                    sel.append(p)
                    used_idx.add(i)
            if len(sel) >= k:
                return sel[:k]
            # relax threshold
            thr *= 0.8
            if thr < 1e-6:
                break
        # fallback: use greedy max-min to fill
        fallback = self._select_points_greedy_maxmin(pts, k)
        return fallback

    def _generate_diffuser_points_for_poly(self, poly, N: int):
        if N <= 0:
            return []

        # 1. Fix topology and compute safe interior area
        poly = poly.buffer(0)
        margin_m = 0.5
        margin_px = self.meter_to_pixel(margin_m)
        safe_poly = poly.buffer(-margin_px)
        if safe_poly.is_empty:
            safe_poly = poly

        # 2. Bounding box (pixel coordinates)
        minx, miny, maxx, maxy = poly.bounds
        width = maxx - minx
        height = maxy - miny
        if width <= 0 or height <= 0:
            rep = poly.representative_point()
            return [(rep.x, rep.y)]

        # 3. Grid spacing (0.5m) in pixels
        spacing = max(1.0, self.meter_to_pixel(0.5))

        import math

        # 4. Anchor grid to same reference used by draw_grid (first shape or origin)
        try:
            if self.shapes:
                anchor_x = float(self.shapes[0].coords[0])
                anchor_y = float(self.shapes[0].coords[1])
            else:
                anchor_x = 0.0
                anchor_y = 0.0
        except Exception:
            anchor_x = 0.0
            anchor_y = 0.0

        rem_x = anchor_x - math.floor(anchor_x / spacing) * spacing
        rem_y = anchor_y - math.floor(anchor_y / spacing) * spacing

        # 5. Grid indices covering bbox
        kmin = math.floor((minx - rem_x) / spacing)
        kmax = math.ceil((maxx - rem_x) / spacing)
        hmin = math.floor((miny - rem_y) / spacing)
        hmax = math.ceil((maxy - rem_y) / spacing)

        # 6. Build list of grid intersection points that lie inside safe_poly
        from shapely.geometry import Point as ShapelyPoint
        intersections = []
        for k in range(kmin, kmax + 1):
            x = k * spacing + rem_x
            for j in range(hmin, hmax + 1):
                y = j * spacing + rem_y
                pt = ShapelyPoint(x, y)
                if safe_poly.contains(pt):
                    intersections.append((x, y))

        # If no intersections, fallback to representative point
        if not intersections:
            rep = poly.representative_point()
            return [(rep.x, rep.y)] * min(N, 1)

        # Remove duplicates (round to int pixels)
        uniq = []
        seen = set()
        for (x, y) in intersections:
            key = (round(x, 3), round(y, 3))
            if key in seen:
                continue
            seen.add(key)
            uniq.append((x, y))
        intersections = uniq

        # 7. Decide r x c layout to try to distribute N points in rows/cols
        r, c = self._decide_grid_rc(N, width, height)
        # create ideal cell centers (in bbox coordinates)
        ideal_points = []
        if r > 0 and c > 0:
            dx = width / (c + 1)
            dy = height / (r + 1)
            for irow in range(1, r + 1):
                for icol in range(1, c + 1):
                    px = minx + icol * dx
                    py = miny + irow * dy
                    ideal_points.append((px, py))
        else:
            # fallback to centroid-based selection
            cx = sum(p[0] for p in intersections) / len(intersections)
            cy = sum(p[1] for p in intersections) / len(intersections)
            ideal_points = [(cx, cy)]

        # 8. For each ideal point, choose nearest unused grid intersection (prefer within same cell radius)
        selected = []
        used_idx = set()
        for ip in ideal_points:
            best_i = None
            best_d2 = float('inf')
            # first try to find intersection within the surrounding cell radius (in pixel distance dx/2,dy/2)
            radius_px = max(spacing, min(width, height))
            for idx, pt in enumerate(intersections):
                if idx in used_idx:
                    continue
                d2 = (pt[0] - ip[0]) ** 2 + (pt[1] - ip[1]) ** 2
                if d2 < best_d2:
                    best_d2 = d2
                    best_i = idx
            if best_i is not None:
                used_idx.add(best_i)
                selected.append(intersections[best_i])
            if len(selected) >= N:
                break

        # 9. If still fewer than N, fill remaining by greedy selection with minimum separation
        if len(selected) < N:
            remaining = [p for i, p in enumerate(intersections) if i not in used_idx]
            min_sep_m = 1.0
            min_sep_px = self.meter_to_pixel(min_sep_m)
            more = self._select_with_min_separation(remaining, N - len(selected), min_sep_px)
            selected.extend(more)

        # 10. Final trim and ensure uniqueness
        out = []
        seen2 = set()
        for (x, y) in selected:
            key = (round(x, 3), round(y, 3))
            if key in seen2:
                continue
            seen2.add(key)
            out.append((x, y))
            if len(out) >= N:
                break

        return out

    # Diagnostic: check diffusers in a named room
    def check_diffusers_in_room(self, room_name: str):
        """Return (assigned_count, inside_count, outside_count, list_of_outside_item_ids) for given room_name.
        - assigned_count: number of diffuser item ids stored in this room's lab entry
        - inside_count / outside_count: counts of ALL diffuser items (from any lab) whose centers are inside/outside the room polygon
        This lets us detect when diffusers exist on the canvas but are not assigned to the target lab (or vice versa).
        """
        inside = 0
        outside = 0
        outside_ids = []
        # find matching label
        target_lab = None
        for lab in self.generated_space_labels:
            try:
                name = self.canvas.itemcget(lab["name_id"], "text")
            except Exception:
                name = ""
            if name == room_name:
                target_lab = lab
                break
        if not target_lab:
            return 0, 0, 0, []

        assigned_count = len(target_lab.get("diffuser_ids", []))
        poly = target_lab["polygon"]
        # check diffuser ids from all labs (spatial containment)
        for lab in self.generated_space_labels:
            for did in lab.get("diffuser_ids", []):
                coords = self.canvas.coords(did)
                if not coords or len(coords) < 4:
                    continue
                cx = (coords[0] + coords[2]) / 2.0
                cy = (coords[1] + coords[3]) / 2.0
                try:
                    pt = Point(cx, cy)
                    if poly.contains(pt):
                        inside += 1
                    else:
                        outside += 1
                        outside_ids.append(did)
                except Exception:
                    outside += 1
                    outside_ids.append(did)

        return assigned_count, inside, outside, outside_ids

    def auto_place_diffusers(self, area_per_diffuser: float):
        """각 실의 면적 기준으로 디퓨저 개수 산정 및 배치"""
        if not self.generated_space_labels:
            messagebox.showinfo("정보", "자동생성된 실(공간) 라벨이 없습니다.\n먼저 '자동생성'을 수행하세요.")
            return

        self.push_history()

        # 안전하게 기존의 모든 diffuser 및 diffuser_label 아이템을 삭제
        try:
            for item in list(self.canvas.find_withtag("diffuser")):
                try:
                    self.canvas.delete(item)
                except Exception:
                    pass
        except Exception:
            pass
        try:
            for item in list(self.canvas.find_withtag("diffuser_label")):
                try:
                    self.canvas.delete(item)
                except Exception:
                    pass
        except Exception:
            pass
        # remove any persistent per-diffuser flow labels (we'll only show flows in hover tooltip)
        try:
            for item in list(self.canvas.find_withtag("diffuser_flow")):
                try:
                    self.canvas.delete(item)
                except Exception:
                    pass
        except Exception:
            pass

        # 각 lab 내부의 ID 리스트들도 초기화
        for lab in self.generated_space_labels:
            lab["diffuser_ids"] = []
            lab["diffuser_label_ids"] = []

        # 각 실별 디퓨저 생성
        for lab in self.generated_space_labels:
            # process every room (remove temporary Room 6-only filter)
            poly = lab["polygon"]
            area_text = self.canvas.itemcget(lab["area_id"], "text")
            area_val = 0.0
            for tok in area_text.replace("m²", "").split():
                try:
                    area_val = float(tok)
                    break
                except Exception:
                    continue
            
            if area_val <= 0:
                lab["diffuser_ids"] = []
                continue

            # Only place diffusers for central HVAC (1. 중앙공조)
            hvac = int(lab.get("hvac_type", 1)) if lab.get("hvac_type", None) is not None else 1
            if hvac != 1:
                # ensure no diffusers/labels remain for non-central HVAC rooms
                lab["diffuser_ids"] = []
                lab["diffuser_label_ids"] = []
                continue

            # 개수 결정 로직: 몫(int) -> 홀수면 +1 (짝수화)
            n = int(area_val // area_per_diffuser)
            if n < 1:
                n = 1
            if n % 2 == 1:
                n += 1
            
            # 위치 계산 및 그리기
            pts = self._generate_diffuser_points_for_poly(poly, n)
            diffuser_ids = []
            diffuser_label_ids = []
            radius = 3
            # cluster pts into rows by y coordinate
            spacing_px = max(1.0, self.meter_to_pixel(0.5))
            row_thresh = max(2.0, spacing_px * 0.5)
            pts_sorted = sorted(pts, key=lambda p: (p[1], p[0]))
            rows = []
            for (x, y) in pts_sorted:
                if not rows:
                    rows.append([(x, y)])
                    continue
                last_row = rows[-1]
                # compare to median y of last_row
                ys = [pt[1] for pt in last_row]
                med_y = sum(ys) / len(ys)
                if abs(y - med_y) <= row_thresh:
                    last_row.append((x, y))
                else:
                    rows.append([(x, y)])

            # sort each row by x (left to right)
            for i in range(len(rows)):
                rows[i].sort(key=lambda p: p[0])

            # assign Supply/Return alternating starting with (1,1)=Supply
            for ri, row in enumerate(rows):
                for ci, (x, y) in enumerate(row):
                    # parity: supply if (ri + ci) % 2 == 0
                    is_supply = ((ri + ci) % 2 == 0)
                    color = "green" if is_supply else "skyblue"
                    tag2 = "supply" if is_supply else "return"
                    # assemble tags: diffuser, supply/return tag, and hvac tag if available
                    tgs = ["diffuser", tag2]
                    try:
                        hv_txt = lab.get('hvac_text') if lab else None
                        if hv_txt:
                            tgs.append(f'hvac:{hv_txt}')
                    except Exception:
                        pass
                    did = self.canvas.create_oval(
                        x - radius, y - radius, x + radius, y + radius,
                        fill=color, outline="", tags=tuple(tgs)
                    )
                    try:
                        # bind item-level enter/leave for reliable hover
                        self.canvas.tag_bind(did, '<Enter>', lambda e, rc=self: rc._diffuser_enter(e))
                        self.canvas.tag_bind(did, '<Leave>', lambda e, rc=self: rc._diffuser_leave(e))
                    except Exception:
                        pass
                    # create label next to the diffuser
                    try:
                        tid = self.canvas.create_text(x + radius + 4, y,
                                                      text=("S" if is_supply else "R"),
                                                      anchor=tk.W,
                                                      fill=color,
                                                      font=("Arial", 8, "bold"),
                                                      tags=("diffuser_label", tag2))
                    except Exception:
                        tid = None
                    diffuser_ids.append(did)
                    if tid:
                        diffuser_label_ids.append(tid)

            lab["diffuser_ids"] = diffuser_ids
            lab["diffuser_label_ids"] = diffuser_label_ids
            # after placing diffusers, if we have a numeric supply total for the room,
            # distribute it equally among the Supply diffusers and create small flow labels
            try:
                self._distribute_supply_for_lab(lab)
            except Exception:
                pass
            # create small persistent flow labels next to each diffuser so users can
            # immediately see assigned per-diffuser flows
            try:
                df_map = lab.get('diffuser_flows', {}) if lab else {}
                for did in list(diffuser_ids):
                    try:
                        coords = self.canvas.coords(did)
                        if not coords or len(coords) < 4:
                            continue
                        cx = (coords[0] + coords[2]) / 2.0
                        cy = (coords[1] + coords[3]) / 2.0
                        # determine color from supply/return tag on the diffuser
                        try:
                            tags = self.canvas.gettags(did)
                        except Exception:
                            tags = ()
                        if 'supply' in tags:
                            fcol = 'darkgreen'
                        elif 'return' in tags:
                            fcol = 'darkblue'
                        else:
                            fcol = 'black'
                        # fetch flow value (fallback to 0)
                        qval = 0.0
                        try:
                            qval = float(df_map.get(did, df_map.get(int(did), 0.0) or 0.0))
                        except Exception:
                            try:
                                qval = float(str(df_map.get(did) or df_map.get(int(did) or 0)))
                            except Exception:
                                qval = 0.0
                        # formatted text
                        try:
                            txt = f"{qval:,.0f} m3/h"
                        except Exception:
                            txt = f"{qval:.0f} m3/h"
                        # build tags: keep generic 'diffuser_flow' and include hvac tag if present
                        tgs = ['diffuser_flow']
                        try:
                            hv = lab.get('hvac_text')
                            if hv:
                                tgs.append(f'hvac:{hv}')
                        except Exception:
                            pass
                        # place label just right of diffuser
                        try:
                            self.canvas.create_text(cx + radius + 6, cy, text=txt, anchor=tk.W, fill=fcol, font=("Arial", 8), tags=tuple(tgs))
                        except Exception:
                            try:
                                self.canvas.create_text(cx + radius + 6, cy, text=txt, anchor=tk.W, fill=fcol, font=("Arial", 8))
                            except Exception:
                                pass
                    except Exception:
                        continue
            except Exception:
                pass

    # -------- 저장/불러오기용 직렬화 --------

    def to_dict(self):
        """현재 Palette 상태를 JSON 직렬화용 dict로 반환"""
        data = {
            "scale": self.scale,
            "shapes": [],
            "labels": []
        }
        for s in self.shapes:
            data["shapes"].append({
                "coords": list(s.coords),
                "editable": s.editable,
                "color": s.color
            })

        for lab in self.generated_space_labels:
            # 텍스트와 위치
            name_x, name_y = self.canvas.coords(lab["name_id"])
            norm_x, norm_y = self.canvas.coords(lab["heat_norm_id"])
            equip_x, equip_y = self.canvas.coords(lab["heat_equip_id"])
            area_x, area_y = self.canvas.coords(lab["area_id"])
            
            # 디퓨저 위치 저장
            diffuser_coords = []
            if "diffuser_ids" in lab:
                for did in lab["diffuser_ids"]:
                    coords = self.canvas.coords(did)
                    if coords:
                        cx = (coords[0] + coords[2]) / 2
                        cy = (coords[1] + coords[3]) / 2
                        diffuser_coords.append([cx, cy])

            data["labels"].append({
                "polygon_coords": list(lab["polygon"].exterior.coords),
                "name_text": self.canvas.itemcget(lab["name_id"], "text"),
                "heat_norm_text": self.canvas.itemcget(lab["heat_norm_id"], "text"),
                "heat_equip_text": self.canvas.itemcget(lab["heat_equip_id"], "text"),
                "area_text": self.canvas.itemcget(lab["area_id"], "text"),
                "name_pos": [name_x, name_y],
                "heat_norm_pos": [norm_x, norm_y],
                "heat_equip_pos": [equip_x, equip_y],
                "area_pos": [area_x, area_y],
                "diffuser_coords": diffuser_coords
                ,
                "hvac_type": int(lab.get("hvac_type", 1)),
                "hvac_detail": int(lab.get("hvac_detail", 1)) if lab.get("hvac_detail", None) is not None else 0,
                "hvac_text": lab.get("hvac_text", None),
                # persist edited quantity and detail text if present
                "hvac_qty": int(lab.get("hvac_qty")) if lab.get("hvac_qty", None) is not None else None,
                "hvac_detail_text": lab.get("hvac_detail_text", None)
            })
        # save grid visibility
        data["show_grid"] = bool(getattr(self, 'show_grid', False))
        return data

    def load_from_dict(self, data: dict):
        """JSON dict로부터 Palette 상태 복원"""
        self.canvas.delete("all")
        self.shapes.clear()
        self.generated_space_labels.clear()
        self.highlight_line_id = None
        self.tooltip_id = None
        self.corner_highlight_id = None

        self.scale = data.get("scale", 20.0)
        self.next_shape_id = 1

        # 도형 복원
        for info in data.get("shapes", []):
            coords = info.get("coords", [0, 0, 0, 0])
            editable = info.get("editable", True)
            color = info.get("color", "black")
            s = self.create_rect_shape(
                coords[0], coords[1], coords[2], coords[3],
                editable=editable, color=color, push_to_history=False
            )

        # 라벨 복원
        for lab in data.get("labels", []):
            poly = Polygon(lab["polygon_coords"])

            name_x, name_y = lab["name_pos"]
            norm_x, norm_y = lab["heat_norm_pos"]
            equip_x, equip_y = lab["heat_equip_pos"]
            area_x, area_y = lab["area_pos"]

            name_id = self.canvas.create_text(
                name_x, name_y,
                text=lab["name_text"], fill="blue", font=("Arial", 11, "bold"),
                tags=("space_name",)
            )
            heat_norm_id = self.canvas.create_text(
                norm_x, norm_y,
                text=lab["heat_norm_text"], fill="darkred", font=("Arial", 10),
                tags=("space_heat_norm",)
            )
            heat_equip_id = self.canvas.create_text(
                equip_x, equip_y,
                text=lab["heat_equip_text"], fill="darkred", font=("Arial", 10),
                tags=("space_heat_equip",)
            )
            area_id = self.canvas.create_text(
                area_x, area_y,
                text=lab["area_text"], fill="green", font=("Arial", 10)
            )
            
            # 디퓨저 복원
            diffuser_ids = []
            diffuser_coords = lab.get("diffuser_coords", [])
            r = 3
            for (cx, cy) in diffuser_coords:
                did = self.canvas.create_oval(
                    cx - r, cy - r, cx + r, cy + r,
                    fill="green", outline=""
                )
                diffuser_ids.append(did)

            # hvac_detail stored as 0 when missing; convert back to None
            stored_detail = lab.get("hvac_detail", 0)
            if stored_detail == 0:
                stored_detail = None
            self.generated_space_labels.append({
                "polygon": poly,
                "name_id": name_id,
                "heat_norm_id": heat_norm_id,
                "heat_equip_id": heat_equip_id,
                "area_id": area_id,
                "diffuser_ids": diffuser_ids,
                "hvac_type": int(lab.get("hvac_type", 1)),
                "hvac_detail": int(stored_detail) if stored_detail is not None else None,
                "hvac_text": lab.get("hvac_text", None),
                # restore persisted quantity and detail text if present
                "hvac_qty": int(lab.get("hvac_qty")) if lab.get("hvac_qty", None) is not None else None,
                "hvac_detail_text": lab.get("hvac_detail_text", None)
            })

        # 태그 바인딩 복원
        self.canvas.tag_bind("dim_width", "<Button-1>", self.on_dim_width_click)
        self.canvas.tag_bind("dim_height", "<Button-1>", self.on_dim_height_click)
        self.canvas.tag_bind("space_name", "<Button-1>", self.on_space_name_click)
        self.canvas.tag_bind("space_heat_norm", "<Button-1>", self.on_space_heat_norm_click)
        self.canvas.tag_bind("space_heat_equip", "<Button-1>", self.on_space_heat_equip_click)

        self.active_shape = None
        self.active_side_name = None
        self.app.update_selected_area_label(self)
        # restore grid visibility
        self.show_grid = bool(data.get("show_grid", False))
        if getattr(self, 'show_grid', False):
            try:
                self.draw_grid()
            except Exception:
                pass

    # -------- 줌 / 팬 --------

    def on_mouse_wheel(self, event):
        zoom_in = event.delta > 0
        self.apply_zoom(zoom_in, event.x, event.y)

    def on_mouse_wheel_linux(self, event):
        zoom_in = (event.num == 4)
        self.apply_zoom(zoom_in, event.x, event.y)

    def apply_zoom(self, zoom_in, cx, cy):
        factor = 1.1 if zoom_in else 1 / 1.1
        new_scale = self.scale * factor
        if new_scale < 2.0 or new_scale > 200.0:
            return

        self.push_history()

        self.canvas.scale("all", cx, cy, factor, factor)
        for shape in self.shapes:
            x1, y1, x2, y2 = shape.coords
            x1 = cx + (x1 - cx) * factor
            y1 = cy + (y1 - cy) * factor
            x2 = cx + (x2 - cx) * factor
            y2 = cy + (y2 - cy) * factor
            shape.coords = (x1, y1, x2, y2)

        self.scale = new_scale
        self.app.update_selected_area_label(self)
        # redraw grid to match new scale
        try:
            self.clear_grid()
            if getattr(self, 'show_grid', False):
                self.draw_grid()
        except Exception:
            pass

    def on_middle_button_down(self, event):
        self.push_history()
        self.panning = True
        self.pan_last_pos = (event.x, event.y)

    def on_middle_button_drag(self, event):
        if not self.panning or self.pan_last_pos is None:
            return
        last_x, last_y = self.pan_last_pos
        dx = event.x - last_x
        dy = event.y - last_y

        self.canvas.move("all", dx, dy)
        for shape in self.shapes:
            x1, y1, x2, y2 = shape.coords
            shape.coords = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)
        self.pan_last_pos = (event.x, event.y)

    def on_middle_button_up(self, event):
        self.panning = False
        self.pan_last_pos = None
        # after panning, redraw grid for the new viewport
        try:
            if getattr(self, 'show_grid', False):
                # clear any old grid items and draw fresh
                self.clear_grid()
                self.draw_grid()
        except Exception:
            pass


# ================= 상위 App =================

# Backward compatibility: previous code used the name RectCanvas
RectCanvas = Palette

class ResizableRectApp:
    def __init__(self, root):
        self.root = root
        self.root.title("도형 편집기 (디퓨저 배치 기능 추가됨)")

        # left-side control panel (wider so controls are not clipped)
        left_panel = tk.Frame(self.root, width=280)
        left_panel.pack(side=tk.LEFT, fill=tk.Y)
        left_panel.pack_propagate(False)

        # Left-side notebook hosting Room Design as a tab
        self.left_notebook = ttk.Notebook(left_panel)
        self.left_notebook.pack(fill=tk.BOTH, expand=False, padx=6, pady=6)

        # Room Design tab/frame inside left_notebook
        tab_frame = tk.Frame(self.left_notebook)
        self.left_notebook.add(tab_frame, text="Room Design")

        # Duct Design tab with simple runtime rename controls
        self.duct_tab = tk.Frame(self.left_notebook)
        self.left_notebook.add(self.duct_tab, text="Duct")

        duct_rename_frame = tk.Frame(self.duct_tab)
        duct_rename_frame.pack(side=tk.TOP, fill=tk.X, pady=(4, 4), padx=6)
        tk.Label(duct_rename_frame, text="탭 이름:").pack(side=tk.LEFT)
        self.duct_tab_name_entry = tk.Entry(duct_rename_frame, width=14)
        self.duct_tab_name_entry.insert(0, "Duct")
        self.duct_tab_name_entry.pack(side=tk.LEFT, padx=(4, 6))
        # rename button with validation
        duct_rename_btn = tk.Button(duct_rename_frame, text="이름 변경", command=self._rename_duct_tab)
        duct_rename_btn.pack(side=tk.LEFT, padx=(2, 4))

    # (기본 복원 버튼 제거됨)

        # --- Nested notebook inside Duct tab for sub-sections (사이징/두께/검사) ---
        try:
            self.duct_sub_notebook = ttk.Notebook(self.duct_tab)
            self.duct_sub_notebook.pack(fill=tk.BOTH, expand=True, padx=6, pady=(6, 6))

            # 사이징 sub-tab
            self.duct_main_tab = tk.Frame(self.duct_sub_notebook)
            self.duct_sub_notebook.add(self.duct_main_tab, text="사이징")

            # 두께 sub-tab
            self.duct_branches_tab = tk.Frame(self.duct_sub_notebook)
            self.duct_sub_notebook.add(self.duct_branches_tab, text="두께")

            # 검사 sub-tab (next to 두께)
            self.duct_check_tab = tk.Frame(self.duct_sub_notebook)
            self.duct_sub_notebook.add(self.duct_check_tab, text="검사")

            # 사이징 UI: controls on the left, scrolled output box on the right
            sizing_outer = tk.Frame(self.duct_main_tab)
            sizing_outer.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)

            left_col = tk.Frame(sizing_outer)
            left_col.pack(side=tk.LEFT, fill=tk.Y, padx=(0,8))

            # Inputs
            tk.Label(left_col, text="풍량 (m³/h):").grid(row=0, column=0, sticky='w')
            self.sizing_flow_entry = tk.Entry(left_col, width=12)
            self.sizing_flow_entry.insert(0, "50000")
            self.sizing_flow_entry.grid(row=0, column=1, pady=2, sticky='w')

            tk.Label(left_col, text="정압값 (mmAq/m):").grid(row=1, column=0, sticky='w')
            self.sizing_pressure_entry = tk.Entry(left_col, width=12)
            self.sizing_pressure_entry.insert(0, "0.1")
            self.sizing_pressure_entry.grid(row=1, column=1, pady=2, sticky='w')

            tk.Label(left_col, text="종횡비 (b/a):").grid(row=2, column=0, sticky='w')
            self.sizing_ratio_cb = ttk.Combobox(left_col, values=["1","1.5","2","2.5","3"], width=10)
            self.sizing_ratio_cb.set("2")
            self.sizing_ratio_cb.grid(row=2, column=1, pady=2, sticky='w')

            self.fix_once_var = tk.IntVar(value=0)
            self.fix_once_cb = tk.Checkbutton(left_col, text="한 번 고정(mm):", variable=self.fix_once_var)
            self.fix_once_cb.grid(row=3, column=0, columnspan=2, sticky='w', pady=(6,2))
            self.fix_once_entry = tk.Entry(left_col, width=12)
            self.fix_once_entry.grid(row=3, column=1, sticky='e')

            # Buttons in two columns
            btn_frame = tk.Frame(left_col)
            btn_frame.grid(row=4, column=0, columnspan=2, pady=(8,0))

            b_calc = tk.Button(btn_frame, text="계산하기", width=12, command=lambda: self._sizing_calc())
            b_equal = tk.Button(btn_frame, text="균등 풍량 배분", width=12, command=lambda: self._sizing_equal_distribute())
            b_composite = tk.Button(btn_frame, text="종합 사이징", width=12, command=lambda: self._sizing_composite())
            b_clear = tk.Button(btn_frame, text="전체 지우기", width=12, command=lambda: self._sizing_clear())
            b_fence = tk.Button(btn_frame, text="펜슬 모드", width=12, command=lambda: self._sizing_pencil_mode())
            b_auto = tk.Button(btn_frame, text="자동완성", width=12, command=lambda: self._sizing_auto())

            # arrange buttons in grid 3x2 (matching screenshot style)
            b_calc.grid(row=0, column=0, padx=4, pady=4)
            b_equal.grid(row=0, column=1, padx=4, pady=4)
            b_composite.grid(row=1, column=0, padx=4, pady=4)
            b_clear.grid(row=1, column=1, padx=4, pady=4)
            b_fence.grid(row=2, column=0, padx=4, pady=4)
            b_auto.grid(row=2, column=1, padx=4, pady=4)

            # Bottom area: scrolled text output placed under the buttons
            bottom_area = tk.Frame(self.duct_main_tab)
            # Do not allow bottom area to expand vertically to avoid pushing
            # HVAC list and controls down; keep a modest fixed text height.
            bottom_area.pack(side=tk.TOP, fill=tk.X, expand=False, padx=6, pady=(6,6))

            # limit text widget height so it doesn't consume the full window
            try:
                import tkinter.font as tkfont
                _sizing_font = tkfont.Font(size=8)
            except Exception:
                _sizing_font = None
            self.sizing_text = tk.Text(bottom_area, wrap='word', height=10, font=_sizing_font)
            self.sizing_scroll = tk.Scrollbar(bottom_area, orient=tk.VERTICAL, command=self.sizing_text.yview)
            self.sizing_text.config(yscrollcommand=self.sizing_scroll.set)
            self.sizing_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            self.sizing_scroll.pack(side=tk.LEFT, fill=tk.Y)

            # --- 두께(Thickness) tab UI ---
            tab = self.duct_branches_tab
            try:
                # Label/font helpers
                tk.Label(tab, text="두께 규칙 설정", font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=3, sticky='w', padx=6, pady=(6,4))

                # Low-pressure rules (저압 규칙)
                tk.Label(tab, text="저압 규칙:").grid(row=1, column=0, columnspan=3, sticky='w', padx=6)
                low_defaults = [(0.6, 350), (0.8, 750), (1.0, 1500), (1.2, None)]
                self._thk_low_pairs = []
                prev_max = -1
                for i, (thk, max_def) in enumerate(low_defaults):
                    r = 2 + i
                    l_thk = tk.Label(tab, text=f"{thk:.2f} mm", font=("Arial", 9))
                    l_thk.grid(row=r, column=0, pady=2, sticky='w', padx=6)
                    min_txt = "0~" if i == 0 else f"{int(prev_max)+1}~"
                    l_min = tk.Label(tab, text=min_txt, width=8, font=("Arial", 9))
                    l_min.grid(row=r, column=1, padx=4, pady=2, sticky='w')
                    e_max = tk.Entry(tab, width=10)
                    e_max.grid(row=r, column=2, pady=2, sticky='w')
                    if max_def:
                        e_max.insert(0, str(max_def))
                        prev_max = max_def
                    self._thk_low_pairs.append((l_thk, l_min, e_max))

                # High-pressure rules (고압 규칙)
                high_row = 2 + len(low_defaults)
                tk.Label(tab, text="고압 규칙:").grid(row=high_row, column=0, columnspan=3, sticky='w', padx=6)
                high_defaults = [(0.8, 450), (1.0, 1200), (1.2, None)]
                self._thk_high_pairs = []
                prev_max_h = -1
                for i, (thk, max_def) in enumerate(high_defaults):
                    r = high_row + 1 + i
                    l_thk = tk.Label(tab, text=f"{thk:.2f} mm", font=("Arial", 9))
                    l_thk.grid(row=r, column=0, pady=2, sticky='w', padx=6)
                    min_txt = "0~" if i == 0 else f"{int(prev_max_h)+1}~"
                    l_min = tk.Label(tab, text=min_txt, width=8, font=("Arial", 9))
                    l_min.grid(row=r, column=1, padx=4, pady=2, sticky='w')
                    e_max = tk.Entry(tab, width=10)
                    e_max.grid(row=r, column=2, pady=2, sticky='w')
                    if max_def:
                        e_max.insert(0, str(max_def))
                        prev_max_h = max_def
                    self._thk_high_pairs.append((l_thk, l_min, e_max))

                btn_row = high_row + 1 + len(high_defaults)
                tk.Button(tab, text="두께별 소요량 계산", command=lambda: self._compute_thickness_breakdown()).grid(row=btn_row, column=0, columnspan=3, pady=8, sticky='w', padx=6)
            except Exception:
                # Fallback simple placeholder if grid fails for any reason
                tk.Label(self.duct_branches_tab, text="두께 관련 설정이 여기에 들어갑니다.").pack(padx=8, pady=8)
            tk.Label(self.duct_check_tab, text="검사 관련 도구 및 결과가 여기에 표시됩니다.").pack(padx=8, pady=8)
        except Exception:
            # If ttk.Notebook not available for some reason, fallback to single area
            try:
                tk.Label(self.duct_tab, text="(서브 탭을 생성할 수 없습니다)").pack(padx=6, pady=6)
            except Exception:
                pass

        # HVAC systems list for Duct tab
        hvac_frame = tk.Frame(self.duct_tab)
        hvac_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=False, padx=6, pady=(6, 4))
        tk.Label(hvac_frame, text="공조 시스템 목록:").pack(anchor='w')
        listbox_frame = tk.Frame(hvac_frame)
        listbox_frame.pack(fill=tk.BOTH, expand=False)
        self.hvac_listbox = tk.Listbox(listbox_frame, height=6)
        self.hvac_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        # currently active hvac name (set when listbox selection changes)
        self._active_hvac_name = None
        # mapping from hvac name -> set of canvas item ids (points and diffusers)
        self.hvac_map = {}
        # currently highlighted ids for HVAC selection
        self._hvac_highlighted = set()
        self.hvac_scroll = tk.Scrollbar(listbox_frame, orient=tk.VERTICAL, command=self.hvac_listbox.yview)
        self.hvac_scroll.pack(side=tk.LEFT, fill=tk.Y)
        self.hvac_listbox.config(yscrollcommand=self.hvac_scroll.set)
        # right-click popup menu for deleting an HVAC item
        self._hvac_menu = tk.Menu(self.hvac_listbox, tearoff=0)
        self._hvac_menu.add_command(label="삭제", command=self._delete_selected_hvac)
        # platform-independent right-click binding
        self.hvac_listbox.bind("<Button-3>", self._on_hvac_right_click)
        # when a hvac is selected in the listbox, highlight related items
        self.hvac_listbox.bind('<<ListboxSelect>>', lambda e: self._on_hvac_select())
        # sample entries
        for item in ["AHU-1", "AHU-2", "FCU-1", "VAV-1"]:
            self.hvac_listbox.insert(tk.END, item)

        # controls: entry + add + apply
        hvac_ctrl = tk.Frame(hvac_frame)
        hvac_ctrl.pack(fill=tk.X, pady=(6, 2))
        tk.Label(hvac_ctrl, text="새 시스템:").pack(side=tk.LEFT)
        self.hvac_new_entry = tk.Entry(hvac_ctrl, width=16)
        self.hvac_new_entry.pack(side=tk.LEFT, padx=(4, 6))
        add_btn = tk.Button(hvac_ctrl, text="추가", command=lambda: self._add_hvac())
        add_btn.pack(side=tk.LEFT, padx=(0, 6))
        apply_btn = tk.Button(hvac_ctrl, text="적용", command=lambda: self._apply_hvac())
        apply_btn.pack(side=tk.LEFT)

        # label showing number of selected diffusers (updated by Palette)
        self.duct_selected_label_var = tk.StringVar()
        self.duct_selected_label_var.set("선택 디퓨저: 0")
        sel_label = tk.Label(self.duct_tab, textvariable=self.duct_selected_label_var, anchor='w')
        sel_label.pack(fill=tk.X, padx=6, pady=(4, 2))

        # area controls at top of Room Design
        area_ctrl = tk.Frame(tab_frame)
        area_ctrl.pack(side=tk.TOP, fill=tk.X, pady=(2, 4))
        tk.Label(area_ctrl, text="면적 (m²):").pack(side=tk.LEFT)
        self.area_entry = tk.Entry(area_ctrl, width=10)
        self.area_entry.pack(side=tk.LEFT, padx=5)
        draw_btn = tk.Button(area_ctrl, text="정사각형 그리기", command=self.draw_square_from_area_current)
        draw_btn.pack(side=tk.LEFT, padx=5)
        self.area_entry.bind("<Return>", lambda e: self.draw_square_from_area_current())

        # small top area in the room tab to host the Auto-generate button above the inputs
        top_ctrl = tk.Frame(tab_frame)
        top_ctrl.pack(side=tk.TOP, pady=(6, 4))
        ag_btn = tk.Button(top_ctrl, text="자동생성", width=18, command=self.auto_generate_current)
        ag_btn.pack()

        # control area inside Room Design
        control_frame = tk.Frame(tab_frame)
        control_frame.pack(fill=tk.BOTH, expand=False, padx=8, pady=4)

        # Temperature inputs
        tk.Label(control_frame, text="외기(°C):").grid(row=0, column=0, sticky="w")
        self.outdoor_temp_entry = tk.Entry(control_frame, width=8)
        self.outdoor_temp_entry.grid(row=0, column=1, padx=(6, 0), pady=2)
        self.outdoor_temp_entry.insert(0, "-5.0")

        tk.Label(control_frame, text="실내(°C):").grid(row=1, column=0, sticky="w")
        self.indoor_temp_entry = tk.Entry(control_frame, width=8)
        self.indoor_temp_entry.grid(row=1, column=1, padx=(6, 0), pady=2)
        self.indoor_temp_entry.insert(0, "23.0")

        tk.Label(control_frame, text="급기(°C):").grid(row=2, column=0, sticky="w")
        self.supply_temp_entry = tk.Entry(control_frame, width=8)
        self.supply_temp_entry.grid(row=2, column=1, padx=(6, 0), pady=2)
        self.supply_temp_entry.insert(0, "14.0")

        # Heat norm/equip with apply buttons and Enter bindings
        tk.Label(control_frame, text="일반 발열량\n(W/m²):").grid(row=3, column=0, sticky="w")
        self.heat_norm_entry = tk.Entry(control_frame, width=8)
        self.heat_norm_entry.grid(row=3, column=1, padx=(6, 0), pady=2)
        self.heat_norm_entry.insert(0, "400.00")
        norm_apply_btn = tk.Button(control_frame, text="적용", width=6, command=lambda: self._on_apply_norm())
        norm_apply_btn.grid(row=3, column=2, padx=(6, 0), pady=2)
        self.heat_norm_entry.bind("<Return>", lambda e: self._on_apply_norm())

        tk.Label(control_frame, text="장비 발열량\n(W/m²):").grid(row=4, column=0, sticky="w")
        self.heat_equip_entry = tk.Entry(control_frame, width=8)
        self.heat_equip_entry.grid(row=4, column=1, padx=(6, 0), pady=2)
        self.heat_equip_entry.insert(0, "0.00")
        equip_apply_btn = tk.Button(control_frame, text="적용", width=6, command=lambda: self._on_apply_equip())
        equip_apply_btn.grid(row=4, column=2, padx=(6, 0), pady=2)
        self.heat_equip_entry.bind("<Return>", lambda e: self._on_apply_equip())

        # 급기 풍량 산정 버튼
        supply_calc_btn = tk.Button(control_frame, text="급기 풍량 산정", width=12,
            command=lambda: self._on_calc_supply_flow())
        supply_calc_btn.grid(row=5, column=0, columnspan=3, pady=(8, 2))

        # 결과 표시용 텍스트 박스
        tk.Label(control_frame, text="총 급기 풍량 (m3/hr):").grid(row=6, column=0, columnspan=3, sticky="w", pady=(6, 0))
        self.supply_result_text = tk.Text(control_frame, height=4, width=24)
        self.supply_result_text.grid(row=7, column=0, columnspan=3, pady=(2, 0))

        # --- 디퓨저 관련 UI 추가 ---
        tk.Label(control_frame, text="디퓨저\n담당면적(m²):").grid(row=8, column=0, sticky="w", pady=(8, 2))
        self.diffuser_area_entry = tk.Entry(control_frame, width=8)
        self.diffuser_area_entry.grid(row=8, column=1, padx=(6, 0), pady=2)
        self.diffuser_area_entry.insert(0, "10.0")

        diffuser_btn = tk.Button(control_frame, text="디퓨저 자동 배치", width=14,
                 command=lambda: self._on_place_diffusers())
        diffuser_btn.grid(row=9, column=0, columnspan=2, pady=(4, 2))
        # Reset diffusers button next to auto-place
        reset_btn = tk.Button(control_frame, text="디퓨져 초기화", width=10,
                  command=lambda: self._on_reset_diffusers())
        reset_btn.grid(row=9, column=2, pady=(4, 2))

        # Diagnostic button: count diffusers inside/outside a room
        check_btn = tk.Button(control_frame, text="디퓨저 점검", width=14,
                  command=lambda: self._on_check_diffusers())
        check_btn.grid(row=10, column=0, columnspan=3, pady=(2, 6))

        # top_frame for remaining main toolbar buttons
        top_frame = tk.Frame(self.root)
        top_frame.pack(side=tk.TOP, fill=tk.X, padx=10, pady=5)

        self.area_label_var = tk.StringVar()
        self.area_label_var.set("선택 도형 면적: - m²")
        area_label = tk.Label(top_frame, textvariable=self.area_label_var, fg="blue")
        area_label.pack(side=tk.LEFT, padx=20)

        undo_btn = tk.Button(top_frame, text="되돌리기 (Ctrl+Z)", command=self.undo_current)
        undo_btn.pack(side=tk.LEFT, padx=10)

        add_tab_btn = tk.Button(top_frame, text="팔레트 추가", command=self.add_new_tab)
        add_tab_btn.pack(side=tk.LEFT, padx=10)

        delete_tab_btn = tk.Button(top_frame, text="팔레트 삭제", command=self.delete_current_tab)
        delete_tab_btn.pack(side=tk.LEFT, padx=5)

        clear_palette_btn = tk.Button(top_frame, text="팔레트 지우기", command=self.clear_current_palette)
        clear_palette_btn.pack(side=tk.LEFT, padx=5)

        save_btn = tk.Button(top_frame, text="저장하기", command=self.save_current)
        save_btn.pack(side=tk.LEFT, padx=5)

        load_btn = tk.Button(top_frame, text="불러오기", command=self.load_current)
        load_btn.pack(side=tk.LEFT, padx=5)
        
        # Cloud storage buttons
        cloud_upload_btn = tk.Button(top_frame, text="클라우드 업로드", command=self.cloud_upload_current)
        cloud_upload_btn.pack(side=tk.LEFT, padx=5)
        
        cloud_browser_btn = tk.Button(top_frame, text="클라우드 브라우저", command=self.cloud_browser)
        cloud_browser_btn.pack(side=tk.LEFT, padx=5)
        
        # CSV preview/load button: opens a CSV and shows it in a new window as a table
        csv_btn = tk.Button(top_frame, text="CSV로드 (C)", command=self.load_csv_preview)
        csv_btn.pack(side=tk.LEFT, padx=5)
        equip_btn = tk.Button(top_frame, text="장비일람표 추출", command=self.extract_equipment_list)
        equip_btn.pack(side=tk.LEFT, padx=5)

        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill=tk.BOTH, expand=True)

        self.palettes = []
        self.add_new_tab()

        self.root.bind_all("<Control-z>", lambda e: self.undo_current())

    # ---------- 버튼 콜백 ----------
    def _on_apply_norm(self):
        try:
            v = float(self.heat_norm_entry.get())
        except Exception:
            messagebox.showerror("입력 오류", "일반 발열량에 숫자를 입력하세요.")
            return
        rc = self.get_current_palette()
        if rc:
            rc.apply_norm_to_all(v)

    def _on_apply_equip(self):
        try:
            v = float(self.heat_equip_entry.get())
        except Exception:
            messagebox.showerror("입력 오류", "장비 발열량에 숫자를 입력하세요.")
            return
        rc = self.get_current_palette()
        if rc:
            rc.apply_equip_to_all(v)
    
    # --- Sizing tab handlers ---
    def _sizing_calc(self):
        # 계산식: ROUND(((3.295*10^-10*풍량^1.9/저항)^0.199*1000),0)
        try:
            flow = float(self.sizing_flow_entry.get())
        except Exception:
            self.sizing_text.insert(tk.END, "계산 오류: 풍량을 숫자로 입력하세요.\n")
            return
        try:
            resistance = float(self.sizing_pressure_entry.get())
        except Exception:
            self.sizing_text.insert(tk.END, "계산 오류: 정압값(저항)을 숫자로 입력하세요.\n")
            return

        # resistance (저항) must be positive to avoid division by zero/negative base
        if resistance <= 0:
            self.sizing_text.insert(tk.END, "계산 오류: 정압값(저항)은 0보다 커야 합니다.\n")
            return

        try:
            base = 3.295e-10 * (flow ** 1.9) / resistance
            if base <= 0:
                raise ValueError("내부 계산 값이 0 이하입니다.")
            raw_val = (base ** 0.199) * 1000
            rounded = float(raw_val)
            rounded_int = int(round(rounded, 0))

            # We'll build the final three-line output after rectangle rounding logic

            # Convert to rectangular duct using the empirical formula and apply 50mm steps
            try:
                r_raw = (self.sizing_ratio_cb.get() or "2")
                r = float(r_raw)
                if r <= 0:
                    raise ValueError("종횡비는 0보다 커야 합니다.")
            except Exception:
                self.sizing_text.insert(tk.END, f"종횡비 입력 오류: '{self.sizing_ratio_cb.get()}'\n")
                return

            # continuous a,b
            D = rounded
            try:
                a_cont = (D / 1.3) * ((1.0 + r) ** 0.25) / (r ** 0.625)
                b_cont = r * a_cont
            except Exception as e:
                self.sizing_text.insert(tk.END, f"사각 환산 실패: {e}\n")
                return

            # ensure width (w) is the larger dimension
            w_cont = max(a_cont, b_cont)
            h_cont = min(a_cont, b_cont)

            import math
            def floor50(x):
                v = math.floor(x / 50.0) * 50
                return int(max(50, v))
            def ceil50(x):
                v = math.ceil(x / 50.0) * 50
                return int(max(50, v))

            # candidate 1: both floor to 50 (economic)
            w1 = floor50(w_cont)
            h1 = floor50(h_cont)

            def rect_to_circle(a_rect, b_rect):
                # D = 1.3 * ((a*b)^0.625 / (a+b)^0.25)
                try:
                    return 1.3 * (((a_rect * b_rect) ** 0.625) / ((a_rect + b_rect) ** 0.25))
                except Exception:
                    return 0.0

            D1 = rect_to_circle(w1, h1)
            # If the rectangle rounded down still yields >= required circular D, accept it
            if D1 >= D:
                w_final, h_final = w1, h1
                reason = f"floor both (경제적): {w1}x{h1} gives D({D1:.1f}) >= required({D:.1f})"
            else:
                # candidate 2: increase width to ceil (keep height floored)
                w2 = ceil50(w_cont)
                h2 = h1
                D2 = rect_to_circle(w2, h2)
                if D2 >= D:
                    w_final, h_final = w2, h2
                    reason = f"width up: {w2}x{h2} gives D({D2:.1f}) >= required({D:.1f})"
                else:
                    # otherwise increase height as well (ceil) and accept
                    h3 = ceil50(h_cont)
                    w3 = w2
                    D3 = rect_to_circle(w3, h3)
                    w_final, h_final = w3, h3
                    reason = f"width up & height up: {w3}x{h3} gives D({D3:.1f}) (forced since previous < required)"

            # Helper: format numbers with thousand separators and trim decimals
            import math
            def fmt_num(x, decimals=3):
                try:
                    v = float(x)
                except Exception:
                    return str(x)
                if math.isfinite(v):
                    if abs(v - round(v)) < 1e-9:
                        return f"{int(round(v)):,}"
                    s = f"{v:,.{decimals}f}".rstrip('0').rstrip('.')
                    return s
                return str(x)

            flow_str = fmt_num(flow, decimals=0)
            res_str = fmt_num(resistance, decimals=3)
            circ_str = fmt_num(rounded_int, decimals=0)
            w_str = fmt_num(w_final, decimals=0)
            h_str = fmt_num(h_final, decimals=0)

            line1 = f"[풍량 : {flow_str} m3/h, 정압값 : {res_str} mmAq/m]\n"
            line2 = f"원형덕트 [mm] : {circ_str}\n"
            line3 = f"사각덕트 [mm] : {w_str} x {h_str}\n"

            # if the result box already has content, insert a single blank line
            try:
                existing = self.sizing_text.get('1.0', tk.END).strip()
                if existing:
                    self.sizing_text.insert(tk.END, "\n")
            except Exception:
                pass

            self.sizing_text.insert(tk.END, line1)
            self.sizing_text.insert(tk.END, line2)
            self.sizing_text.insert(tk.END, line3)
        except Exception as e:
            self.sizing_text.insert(tk.END, f"계산 오류: {e}\n")
        except Exception as e:
            self.sizing_text.insert(tk.END, f"계산 오류: {e}\n")

    def _sizing_equal_distribute(self):
        rc = self.get_current_palette()
        if not rc:
            self.sizing_text.insert(tk.END, "오류: 활성 팔레트가 없습니다.\n")
            return

        # Show AHU capacity dialog before performing equal distribution
        try:
            ok = self._show_ahu_capacity_dialog()
        except Exception:
            ok = False

        if not ok:
            # user cancelled or dialog failed
            self.sizing_text.insert(tk.END, "균등 배분 취소됨.\n")
            return

        # reuse existing equal distribution: call palette helper
        try:
            rc.compute_and_apply_supply_flow()
            self.sizing_text.insert(tk.END, "균등 배분 수행 완료.\n")
        except Exception as e:
            self.sizing_text.insert(tk.END, f"균등 배분 실패: {e}\n")

    def _sizing_composite(self):
        # clear previous results so only current 종합 사이징 outputs remain
        try:
            self.sizing_text.delete('1.0', tk.END)
        except Exception:
            pass
        # Before running routing, normalize hvac_map so that no canvas id
        # appears in more than one mapping. This prevents cross-system mixing
        # caused by duplicated ids in multiple hvac entries.
        try:
            assigned_global = set()
            for name in list(self.hvac_map.keys()):
                try:
                    mapping = self.hvac_map.get(name)
                    if not mapping or not isinstance(mapping, dict):
                        continue
                    orig_ids = set(mapping.get('ids', set()) or set())
                    new_ids = set()
                    removed = []
                    for iid in orig_ids:
                        try:
                            iid_int = int(iid)
                        except Exception:
                            iid_int = iid
                        if iid_int in assigned_global:
                            removed.append(iid_int)
                            continue
                        new_ids.add(iid_int)
                        assigned_global.add(iid_int)
                    if removed:
                        # cleanup log disabled in UI result pane; enable for debugging by changing to print()
                        try:
                            pass
                        except Exception:
                            pass
                    mapping['ids'] = new_ids
                    self.hvac_map[name] = mapping
                except Exception:
                    continue
        except Exception:
            pass

            # Additional normalization: ensure ids in each mapping are present and
            # actually belong to that HVAC (either located on the mapping's palette
            # or explicitly tagged with hvac:<name>). Clean up inconsistent hvac tags
            # from items that were moved/removed to avoid ghost associations.
            try:
                for name in list(self.hvac_map.keys()):
                    try:
                        mapping = self.hvac_map.get(name)
                        if not mapping or not isinstance(mapping, dict):
                            continue
                        pal = mapping.get('palette')
                        orig_ids = set(mapping.get('ids', set()) or set())
                        keep_ids = set()
                        for iid in orig_ids:
                            try:
                                iid_int = int(iid)
                            except Exception:
                                iid_int = iid
                            # locate item on any palette
                            found_pal = None
                            for p in getattr(self, 'palettes', []):
                                try:
                                    if iid_int in p.canvas.find_all():
                                        found_pal = p
                                        break
                                except Exception:
                                    continue
                            # if not found on any palette, skip
                            if not found_pal:
                                # also remove any hvac tag lingering elsewhere
                                try:
                                    for p in getattr(self, 'palettes', []):
                                        try:
                                            if iid_int in p.canvas.find_all():
                                                try:
                                                    p.canvas.dtag(iid_int, f'hvac:{name}')
                                                except Exception:
                                                    pass
                                        except Exception:
                                            continue
                                except Exception:
                                    pass
                                continue
                            try:
                                tags = found_pal.canvas.gettags(iid_int)
                            except Exception:
                                tags = ()
                            # Accept if explicitly tagged for this hvac, or if it lives on the mapping palette
                            if f'hvac:{name}' in tags or (pal is not None and found_pal is pal):
                                keep_ids.add(iid_int)
                            else:
                                # item belongs elsewhere and is not tagged for this hvac; remove any hvac tag for this name
                                try:
                                    found_pal.canvas.dtag(iid_int, f'hvac:{name}')
                                except Exception:
                                    pass
                                # do not keep
                                continue
                        mapping['ids'] = keep_ids
                        self.hvac_map[name] = mapping
                    except Exception:
                        continue
            except Exception:
                pass

        # run router for every HVAC system recorded
        try:
            for name in list(self.hvac_map.keys()):
                try:
                    self.auto_route_ducts(name)
                    # per-HVAC status messages suppressed in result text
                except Exception as e:
                    # suppressed: routing failure message
                    pass
        except Exception as e:
            # suppressed: overall sizing error message (logged to console instead)
            try:
                print("종합 사이징 오류:", e)
            except Exception:
                pass

        # After routing, ensure supply duct items (darkgreen) and their labels are visible
        try:
            for name in list(self.hvac_map.keys()):
                try:
                    hv_tag = f'hvac:{name}'
                    for p in getattr(self, 'palettes', []):
                        try:
                            # iterate over items tagged with hvac tag and set visible if supply-colored
                            for iid in p.canvas.find_withtag(hv_tag):
                                try:
                                    tags = p.canvas.gettags(iid)
                                except Exception:
                                    tags = ()
                                try:
                                    ctype = p.canvas.type(iid)
                                except Exception:
                                    ctype = None
                                try:
                                    fill = p.canvas.itemcget(iid, 'fill') if ctype in ('oval', 'line', 'text') else ''
                                except Exception:
                                    fill = ''
                                try:
                                    if (('duct' in tags) and (fill in ('darkgreen', 'green'))):
                                        p.canvas.itemconfigure(iid, state='normal')
                                    if ctype == 'text' and fill in ('darkgreen', 'green'):
                                        p.canvas.itemconfigure(iid, state='normal')
                                except Exception:
                                    pass
                        except Exception:
                            pass
                except Exception:
                    pass
        except Exception:
            pass

    def auto_route_ducts(self, hvac_name, max_add_steiner=30):
        """Auto-route ducts for the HVAC system named `hvac_name`.

        Uses a simple MST + iterative 1-Steiner heuristic (I1S) and L-shaped
        routing between grid indices; draws horizontal/vertical segments on
        the associated palettes and tags them with ('duct', f'hvac:{hvac_name}').
        """
        # collect mapping
        mapping = self.hvac_map.get(hvac_name)
        if not mapping:
            raise ValueError('해당 HVAC 매핑이 없습니다.')
        # collect terminals: inlets (main supply points) and outlets (diffusers)
        terminals = []  # list of (ix, iy) grid indices
        terminal_items = []  # parallel list of (palette, iid, kind)

        # collect candidate ids (mapping['ids'] contains diffuser/main ids and labels)
        ids = set(mapping.get('ids', set()) or set())
        # also include any items tagged diffuser in the stored palette
        pal = mapping.get('palette')
        if pal is None:
            raise ValueError('매핑된 팔레트가 없습니다.')

        # use a common world grid (meters) so terminals on different palettes align
        grid_m = 0.5  # grid spacing in meters

        # iterate palette(s) belonging to this hvac mapping and collect terminals
        # only collect items that belong to this hvac mapping (by id list and hvac tag or mapping palette)
        # diag output disabled by default; enable for debugging by changing to `if True:` below
        if False:
            try:
                # diagnostic: list mapping ids and where they live (palette and tags)
                try:
                    self.sizing_text.insert(tk.END, f"[DIAG] hvac mapping '{hvac_name}' ids (count={len(ids)}):\n")
                    for did in list(ids):
                        try:
                            did_int = int(did)
                        except Exception:
                            did_int = did
                        found_pal = None
                        found_name = None
                        try:
                            for p in getattr(self, 'palettes', []):
                                try:
                                    if did_int in p.canvas.find_all():
                                        found_pal = p
                                        found_name = getattr(p, 'name', None) or repr(p)
                                        break
                                except Exception:
                                    continue
                        except Exception:
                            pass
                        try:
                            tags = found_pal.canvas.gettags(did_int) if found_pal is not None else ()
                        except Exception:
                            tags = ()
                        try:
                            self.sizing_text.insert(tk.END, f"  id={did_int} on={found_name} tags={tags}\n")
                        except Exception:
                            pass
                except Exception:
                    pass
            except Exception:
                pass
        for did in list(ids):
            try:
                did_int = int(did)
            except Exception:
                did_int = did
            # find palette that contains this id
            found_pal = None
            for p in getattr(self, 'palettes', []):
                try:
                    if did_int in p.canvas.find_all():
                        found_pal = p
                        break
                except Exception:
                    continue
            if not found_pal:
                continue
            try:
                tags = found_pal.canvas.gettags(did_int)
            except Exception:
                tags = ()
            # ensure this item actually belongs to this hvac mapping: either found in the mapping's palette
            # or explicitly tagged with hvac:<hvac_name>
            try:
                if found_pal is not pal and (f'hvac:{hvac_name}' not in tags):
                    # skip items that are not part of this hvac mapping
                    continue
            except Exception:
                pass
            # compute center pixel coords
            try:
                c = found_pal.canvas.coords(did_int)
                if not c or len(c) < 4:
                    continue
                cx = (c[0] + c[2]) / 2.0
                cy = (c[1] + c[3]) / 2.0
            except Exception:
                continue
            # determine kind: inlet if main_point and supply tag, outlet if diffuser without main_point
            is_main = 'main_point' in tags
            is_supply = ('supply' in tags) or any(t.startswith('diffuser_type:') and 'supply' in t for t in tags)
            is_diffuser = 'diffuser' in tags
            if is_main and is_supply:
                terminal_type = 'inlet'
            elif is_diffuser and not is_main:
                terminal_type = 'outlet'
            else:
                # include anything tagged as diffuser as outlet
                if is_diffuser:
                    terminal_type = 'outlet'
                else:
                    terminal_type = 'outlet'

            # convert pixel coords to world meters using the palette's scale (pixels per meter)
            try:
                if hasattr(found_pal, 'pixel_to_meter'):
                    wx = found_pal.pixel_to_meter(cx)
                    wy = found_pal.pixel_to_meter(cy)
                else:
                    # fallback: use stored scale (pixels per meter)
                    scale_px_per_m = getattr(found_pal, 'scale', None) or 1.0
                    wx = float(cx) / float(scale_px_per_m)
                    wy = float(cy) / float(scale_px_per_m)
            except Exception:
                scale_px_per_m = getattr(found_pal, 'scale', None) or 1.0
                wx = float(cx) / float(scale_px_per_m)
                wy = float(cy) / float(scale_px_per_m)

            # grid indices in unified meter grid
            ix = int(round(wx / grid_m))
            iy = int(round(wy / grid_m))
            terminals.append((ix, iy))
            terminal_items.append((found_pal, did_int, terminal_type, cx, cy))

        if len(terminals) < 2:
            raise ValueError('라우팅할 터미널이 충분하지 않습니다 (최소 2개 필요).')

        # reuse internal routines: prim MST + I1S + L-route choice
        def manhattan(a, b):
            return abs(a[0] - b[0]) + abs(a[1] - b[1])

        def prim_mst(pts):
            n = len(pts)
            if n <= 1:
                return []
            in_tree = [False] * n
            dist = [10**18] * n
            parent = [-1] * n
            dist[0] = 0
            for _ in range(n):
                u = -1
                best = 10**18
                for i in range(n):
                    if not in_tree[i] and dist[i] < best:
                        best = dist[i]
                        u = i
                if u == -1:
                    break
                in_tree[u] = True
                for v in range(n):
                    if in_tree[v] or v == u:
                        continue
                    w = manhattan(pts[u], pts[v])
                    if w < dist[v]:
                        dist[v] = w
                        parent[v] = u
            edges = []
            for v in range(1, n):
                if parent[v] != -1:
                    edges.append((v, parent[v]))
            return edges

        def mst_length(pts, edges):
            total = 0
            for i, j in edges:
                total += manhattan(pts[i], pts[j])
            return total

        def hanan_candidates(terms):
            xs = sorted(set([p[0] for p in terms]))
            ys = sorted(set([p[1] for p in terms]))
            cands = []
            for x in xs:
                for y in ys:
                    cands.append((x, y))
            return cands

        def iterated_1_steiner(terminals, max_add=30, min_improve=1):
            P = list(terminals)
            for _ in range(max_add):
                base_edges = prim_mst(P)
                base_L = mst_length(P, base_edges)
                best_s = None
                best_L = base_L
                cand_points = hanan_candidates(terminals)
                existing = set(P)
                for s in cand_points:
                    if s in existing:
                        continue
                    testP = P + [s]
                    test_edges = prim_mst(testP)
                    test_L = mst_length(testP, test_edges)
                    if test_L < best_L:
                        best_L = test_L
                        best_s = s
                if best_s is None:
                    break
                if (base_L - best_L) < min_improve:
                    break
                P.append(best_s)
            edges = prim_mst(P)
            return P, edges

        # Partition terminals by supply/return and run router per partition so
        # supply main-point(s) form the trunk that branches to supply diffusers
        # and similarly for return. This prevents mixing supply and return networks.
        duct_segments = set()
        seg_flow_map = {}

        def norm_seg(x1, y1, x2, y2):
            if x1 == x2 and y1 == y2:
                return None
            if x1 == x2:
                a, b = sorted([y1, y2])
                return ('V', x1, a, b)
            if y1 == y2:
                a, b = sorted([x1, x2])
                return ('H', y1, a, b)
            raise ValueError('세그먼트는 수평/수직이어야 합니다.')

        def l_route_opts(a, b):
            x1, y1 = a
            x2, y2 = b
            s1 = norm_seg(x1, y1, x2, y1)
            s2 = norm_seg(x2, y1, x2, y2)
            opt1 = [s for s in (s1, s2) if s is not None]
            t1 = norm_seg(x1, y1, x1, y2)
            t2 = norm_seg(x1, y2, x2, y2)
            opt2 = [s for s in (t1, t2) if s is not None]
            return opt1, opt2

        def process_terminals(terminals_local, terminal_items_local, root_did=None):
            """Run I1S + L-routing on a subset of terminals and return (segments, seg_flow_map).
            """
            if not terminals_local or len(terminals_local) < 2:
                return set(), {}

            # compute Steiner-augmented MST
            P_local, edges_local = iterated_1_steiner(terminals_local, max_add=max_add_steiner, min_improve=1)

            local_segments = set()

            def add_seg_local(sg):
                if sg is None:
                    return
                local_segments.add(sg)

            def route_edge_local(a, b):
                opt1, opt2 = l_route_opts(a, b)
                # prefer options that overlap existing global duct_segments to align trunks
                def score_opts(opts):
                    s = 0
                    for seg in opts:
                        if seg in duct_segments or seg in local_segments:
                            s += 1
                    return s
                chosen = opt1 if score_opts(opt1) >= score_opts(opt2) else opt2
                for s in chosen:
                    add_seg_local(s)

            for i, j in edges_local:
                route_edge_local(P_local[i], P_local[j])

            # Determine terminal flows (m3/h) for the original terminals (first T entries of P_local)
            T_local = len(terminals_local)
            terminal_flows_local = [0.0] * T_local
            try:
                total_known = 0.0
                outlet_count = 0
                for t_idx in range(T_local):
                    try:
                        pal_t, did_t, ttype, cx_t, cy_t = terminal_items_local[t_idx]
                    except Exception:
                        pal_t = None
                        did_t = None
                        ttype = 'outlet'
                    q = 0.0
                    if ttype == 'outlet' and pal_t is not None and did_t is not None:
                        try:
                            for lab in getattr(pal_t, 'generated_space_labels', []):
                                try:
                                    if did_t in (lab.get('diffuser_ids') or []):
                                        q = float(lab.get('diffuser_flows', {}).get(did_t, 0.0) or 0.0)
                                        break
                                except Exception:
                                    continue
                        except Exception:
                            q = 0.0
                    if ttype == 'inlet' and pal_t is not None and did_t is not None:
                        try:
                            mp = mapping.get('main_point_flows', {}) if mapping else {}
                            qcand = None
                            if isinstance(mp, dict):
                                qcand = mp.get(did_t)
                                if qcand is None:
                                    try:
                                        qcand = mp.get(int(did_t))
                                    except Exception:
                                        qcand = None
                            if qcand is not None:
                                try:
                                    q = float(qcand)
                                except Exception:
                                    try:
                                        q = float(str(qcand))
                                    except Exception:
                                        q = float(q or 0.0)
                        except Exception:
                            pass

                    terminal_flows_local[t_idx] = float(q or 0.0)
                    if ttype == 'outlet':
                        outlet_count += 1
                        total_known += terminal_flows_local[t_idx]
            except Exception:
                terminal_flows_local = [0.0] * T_local
                total_known = 0.0
                outlet_count = max(1, T_local)

            # fallback equal distribution if needed
            try:
                if total_known <= 0.0:
                    q_total = float(self.sizing_flow_entry.get() or 0.0)
                    if q_total <= 0.0:
                        q_total = sum(terminal_flows_local) or 0.0
                    if q_total <= 0.0:
                        q_total = 100.0 * max(1, outlet_count)
                    per = q_total / max(1, outlet_count)
                    for ti in range(T_local):
                        try:
                            if terminal_items_local[ti][2] == 'outlet':
                                terminal_flows_local[ti] = per
                        except Exception:
                            terminal_flows_local[ti] = per
            except Exception:
                pass

            # compute per-edge flows by rooting the tree at root_did (if provided)
            adj_local = {k: set() for k in range(len(P_local))}
            for (a, b) in edges_local:
                adj_local[a].add(b)
                adj_local[b].add(a)

            # find root index in P_local (must correspond to an original terminal)
            root_idx = None
            if root_did is not None:
                try:
                    # terminals_local correspond to the first T_local entries in P_local
                    for ti in range(T_local):
                        try:
                            if terminal_items_local[ti][1] == root_did:
                                root_idx = ti
                                break
                        except Exception:
                            continue
                except Exception:
                    root_idx = None

            # If no valid root found, fall back to the previous undirected component sum method
            local_seg_map = {}
            if root_idx is None:
                def dfs_collect_local(start, blocked_a, blocked_b):
                    seen = set()
                    stack = [start]
                    while stack:
                        u = stack.pop()
                        if u in seen:
                            continue
                        seen.add(u)
                        for v in adj_local.get(u, ()): 
                            if (u == blocked_a and v == blocked_b) or (u == blocked_b and v == blocked_a):
                                continue
                            if v not in seen:
                                stack.append(v)
                    return seen

                for (i, j) in edges_local:
                    comp = dfs_collect_local(i, i, j)
                    f = 0.0
                    for node in comp:
                        if 0 <= node < T_local:
                            try:
                                f += float(terminal_flows_local[node])
                            except Exception:
                                pass
                    edge_flow = float(f)
                    a_pt = P_local[i]
                    b_pt = P_local[j]
                    opt1, opt2 = l_route_opts(a_pt, b_pt)
                    def score(opts):
                        s = 0
                        for seg in opts:
                            if seg in duct_segments or seg in local_segments:
                                s += 1
                        return s
                    chosen = opt1 if score(opt1) >= score(opt2) else opt2
                    for seg in chosen:
                        local_seg_map[seg] = local_seg_map.get(seg, 0.0) + edge_flow
            else:
                # directionally compute subtree sums from root
                # build parent-child tree by BFS from root_idx
                parent = {root_idx: None}
                order = [root_idx]
                stack = [root_idx]
                while stack:
                    u = stack.pop(0)
                    for v in adj_local.get(u, ()): 
                        if v in parent:
                            continue
                        parent[v] = u
                        order.append(v)
                        stack.append(v)

                # compute subtree sums bottom-up; initialize node_flow for terminals
                node_flow = {i: 0.0 for i in range(len(P_local))}
                for i in range(len(P_local)):
                    if 0 <= i < T_local:
                        try:
                            node_flow[i] = float(terminal_flows_local[i])
                        except Exception:
                            node_flow[i] = 0.0
                    else:
                        node_flow[i] = 0.0

                # process nodes in reverse BFS order to accumulate child flows
                for u in reversed(order):
                    p = parent.get(u)
                    if p is not None:
                        node_flow[p] = node_flow.get(p, 0.0) + node_flow.get(u, 0.0)

                # for each edge (p <- c), assign c's subtree sum as edge flow
                for (a, b) in edges_local:
                    # determine orientation: parent-child
                    if parent.get(b) == a:
                        child = b
                    elif parent.get(a) == b:
                        child = a
                    else:
                        # fallback: choose smaller index as child (shouldn't happen)
                        child = b
                    edge_flow = float(node_flow.get(child, 0.0))
                    a_pt = P_local[a]
                    b_pt = P_local[b]
                    opt1, opt2 = l_route_opts(a_pt, b_pt)
                    def score(opts):
                        s = 0
                        for seg in opts:
                            if seg in duct_segments or seg in local_segments:
                                s += 1
                        return s
                    chosen = opt1 if score(opt1) >= score(opt2) else opt2
                    for seg in chosen:
                        local_seg_map[seg] = local_seg_map.get(seg, 0.0) + edge_flow

            return local_segments, local_seg_map

        # build supply and return partitions based on canvas tags
        supply_idxs = []
        return_idxs = []
        # compute global terminal_flows (aligned with `terminals`) for later debug/fallback
        terminal_flows = [0.0] * len(terminals)
        try:
            total_known = 0.0
            outlet_count = 0
            for t_idx in range(len(terminals)):
                try:
                    pal_t, did_t, ttype, cx_t, cy_t = terminal_items[t_idx]
                except Exception:
                    pal_t = None
                    did_t = None
                    ttype = 'outlet'
                q = 0.0
                if ttype == 'outlet' and pal_t is not None and did_t is not None:
                    try:
                        for lab in getattr(pal_t, 'generated_space_labels', []):
                            try:
                                if did_t in (lab.get('diffuser_ids') or []):
                                    q = float(lab.get('diffuser_flows', {}).get(did_t, 0.0) or 0.0)
                                    break
                            except Exception:
                                continue
                    except Exception:
                        q = 0.0
                if ttype == 'inlet' and pal_t is not None and did_t is not None:
                    try:
                        mp = mapping.get('main_point_flows', {}) if mapping else {}
                        qcand = None
                        if isinstance(mp, dict):
                            qcand = mp.get(did_t)
                            if qcand is None:
                                try:
                                    qcand = mp.get(int(did_t))
                                except Exception:
                                    qcand = None
                        if qcand is not None:
                            try:
                                q = float(qcand)
                            except Exception:
                                try:
                                    q = float(str(qcand))
                                except Exception:
                                    q = float(q or 0.0)
                    except Exception:
                        pass

                terminal_flows[t_idx] = float(q or 0.0)
                if ttype == 'outlet':
                    outlet_count += 1
                    total_known += terminal_flows[t_idx]
        except Exception:
            terminal_flows = [0.0] * len(terminals)
            total_known = 0.0
            outlet_count = max(1, len(terminals))

        try:
            if total_known <= 0.0:
                q_total = float(self.sizing_flow_entry.get() or 0.0)
                if q_total <= 0.0:
                    q_total = sum(terminal_flows) or 0.0
                if q_total <= 0.0:
                    q_total = 100.0 * max(1, outlet_count)
                per = q_total / max(1, outlet_count)
                for ti in range(len(terminals)):
                    try:
                        if terminal_items[ti][2] == 'outlet':
                            terminal_flows[ti] = per
                    except Exception:
                        terminal_flows[ti] = per
        except Exception:
            pass
        for idx, (pal_t, did_t, ttype, cx_t, cy_t) in enumerate(terminal_items):
            try:
                tags = pal_t.canvas.gettags(did_t)
            except Exception:
                tags = ()
            is_supply_tag = ('supply' in tags) or any(t.startswith('diffuser_type:') and 'supply' in t for t in tags)
            is_return_tag = ('return' in tags) or any(t.startswith('diffuser_type:') and 'return' in t for t in tags)
            # classify: prefer explicit supply/return tags, else use terminal type
            if is_supply_tag or (ttype == 'inlet' and is_supply_tag):
                supply_idxs.append(idx)
            if is_return_tag or (ttype == 'inlet' and is_return_tag):
                return_idxs.append(idx)
            # if neither tag found, classify outlets according to ttype as outlets and include in both partitions by default
            if not is_supply_tag and not is_return_tag:
                if ttype == 'outlet':
                    # infer supply/return by presence of 'supply'/'return' in diffuser labels is absent; default to supply
                    supply_idxs.append(idx)

        # prepare terminal sublists
        def pick_by_idxs(idxs):
            return [terminals[i] for i in idxs], [terminal_items[i] for i in idxs]

        ts_supply, ti_supply = pick_by_idxs(supply_idxs)
        ts_return, ti_return = pick_by_idxs(return_idxs)

        # run router for supply only (do not draw return network)
        try:
            # choose a single supply main-point as root (prefer an 'inlet' in the supply terminal items)
            root_did = None
            try:
                for pal_t, did_t, ttype, cx_t, cy_t in ti_supply:
                    try:
                        if ttype == 'inlet':
                            root_did = did_t
                            break
                    except Exception:
                        continue
            except Exception:
                root_did = None
            # fallback: if no inlet found among supply terminals, use the first supply terminal id
            try:
                if root_did is None and ti_supply:
                    root_did = ti_supply[0][1]
            except Exception:
                root_did = None

            s_segs, s_map = process_terminals(ts_supply, ti_supply, root_did=root_did)
            # also run router for return partition (if any terminals)
            try:
                # choose a return root (prefer an 'inlet' among return terminals)
                root_return_did = None
                try:
                    # prefer an explicit main_point tagged item for the return root
                    for pal_t, did_t, ttype, cx_t, cy_t in ti_return:
                        try:
                            tags = pal_t.canvas.gettags(did_t)
                        except Exception:
                            tags = ()
                        try:
                            if 'main_point' in tags:
                                root_return_did = did_t
                                break
                        except Exception:
                            continue
                except Exception:
                    root_return_did = None
                if root_return_did is None:
                    try:
                        for pal_t, did_t, ttype, cx_t, cy_t in ti_return:
                            try:
                                if ttype == 'inlet':
                                    root_return_did = did_t
                                    break
                            except Exception:
                                continue
                    except Exception:
                        root_return_did = None
                try:
                    if root_return_did is None and ti_return:
                        root_return_did = ti_return[0][1]
                except Exception:
                    root_return_did = None

                r_segs, r_map = process_terminals(ts_return, ti_return, root_did=root_return_did)
            except Exception:
                r_segs, r_map = [], {}
            # combine segments for deletion/drawing, but keep maps separate for coloring
            duct_segments = set(s_segs) | set(r_segs)
            seg_flow_map_supply = dict(s_map)
            seg_flow_map_return = dict(r_map)
        except Exception:
            # on error fallback to empty
            duct_segments = set()
            seg_flow_map_supply = {}
            seg_flow_map_return = {}

        # sizing function (circular equivalent) - copy of calc formula
        def calc_circular_diameter_mm(q_m3h, dp_mm_per_m):
            try:
                q = float(q_m3h)
                dp = float(dp_mm_per_m)
                if q <= 0 or dp <= 0:
                    return 0.0
                C = 3.295e-10
                D = ((C * (q ** 1.9) / dp) ** 0.199) * 1000.0
                return float(D)
            except Exception:
                return 0.0

        def round_step_up(x, step=50.0):
            import math
            return math.ceil(x / step) * step

        # Before drawing anything, remove any previous duct items for this hvac.
        # Only remove items that are actual duct annotations/drawings (tagged 'duct')
        # so that other hvac-scoped labels (e.g., 'main_point_flow', 'diffuser_flow') are preserved.
        try:
            for p in getattr(self, 'palettes', []):
                try:
                    # iterate items already tagged as 'duct'
                    # delete segments that belong to this hvac (have matching hvac tag)
                    # and also remove legacy untagged duct segments (no hvac:* tag)
                    for iid in p.canvas.find_withtag('duct'):
                        try:
                            tags = p.canvas.gettags(iid)
                        except Exception:
                            tags = ()
                        try:
                            # delete if explicitly belonging to this hvac
                            if f'hvac:{hvac_name}' in tags:
                                p.canvas.delete(iid)
                                continue
                            # also delete legacy duct segments that have no hvac: tag at all
                            has_hvac_tag = any(str(t).startswith('hvac:') for t in tags)
                            if not has_hvac_tag:
                                # legacy untagged duct - remove to avoid cross-system connections
                                try:
                                    p.canvas.delete(iid)
                                except Exception:
                                    pass
                        except Exception:
                            pass
                except Exception:
                    pass
        except Exception:
            pass

        # draw size annotations for each segment (with readable background)
        try:
            for seg, q in list(seg_flow_map.items()):
                try:
                    orient, fixed, a, b = seg
                    # compute pixel positions on mapping palette
                    if hasattr(pal, 'meter_to_pixel'):
                        spacing_px = pal.meter_to_pixel(grid_m)
                    else:
                        spacing_px = grid_m * getattr(pal, 'scale', 1.0)
                    if orient == 'H':
                        y = fixed * spacing_px
                        x1, x2 = a * spacing_px, b * spacing_px
                        mx = (x1 + x2) / 2.0
                        my = y
                    else:
                        x = fixed * spacing_px
                        y1, y2 = a * spacing_px, b * spacing_px
                        mx = x
                        my = (y1 + y2) / 2.0
                    # compute D (mm) using default dp from UI
                    try:
                        dp_val = float(self.sizing_pressure_entry.get() or 0.1)
                    except Exception:
                        dp_val = 0.1
                    D_exact = calc_circular_diameter_mm(max(0.0, q), max(1e-6, dp_val))
                    # Convert circular D to rectangular W x H using chosen aspect ratio from sizing tab
                    try:
                        r_raw = (self.sizing_ratio_cb.get() or "2")
                        r = float(r_raw)
                        if r <= 0:
                            r = 2.0
                    except Exception:
                        r = 2.0

                    if D_exact > 0:
                        try:
                            a_cont = (D_exact / 1.3) * ((1.0 + r) ** 0.25) / (r ** 0.625)
                            b_cont = r * a_cont
                        except Exception:
                            a_cont = D_exact / 1.3
                            b_cont = a_cont * r

                        # ensure width is larger
                        w_cont = max(a_cont, b_cont)
                        h_cont = min(a_cont, b_cont)

                        import math
                        def floor50(x):
                            v = math.floor(x / 50.0) * 50
                            return int(max(50, v))
                        def ceil50(x):
                            v = math.ceil(x / 50.0) * 50
                            return int(max(50, v))

                        w1 = floor50(w_cont)
                        h1 = floor50(h_cont)

                        def rect_to_circle(a_rect, b_rect):
                            try:
                                return 1.3 * (((a_rect * b_rect) ** 0.625) / ((a_rect + b_rect) ** 0.25))
                            except Exception:
                                return 0.0

                        D1 = rect_to_circle(w1, h1)
                        if D1 >= D_exact:
                            w_final, h_final = w1, h1
                        else:
                            w2 = ceil50(w_cont)
                            h2 = h1
                            D2 = rect_to_circle(w2, h2)
                            if D2 >= D_exact:
                                w_final, h_final = w2, h2
                            else:
                                h3 = ceil50(h_cont)
                                w3 = w2
                                w_final, h_final = w3, h3
                        W_lbl = int(w_final)
                        H_lbl = int(h_final)
                    else:
                        W_lbl = 0
                        H_lbl = 0

                    label = f"{q:.0f} m3/h\n{W_lbl} x {H_lbl} mm"
                    try:
                        # draw a small leader/tick and place label offset to minimize occlusion
                        tick_len = max(6, int(spacing_px * 0.08))
                        text_pad = 6
                        # prepare formatted spec and flow text (spec on top, flow below)
                        try:
                            spec_txt = f"{int(W_lbl):,} x {int(H_lbl):,} mm"
                        except Exception:
                            spec_txt = f"{W_lbl} x {H_lbl} mm"
                        try:
                            flow_txt = f"{q:,.0f} m3/h"
                        except Exception:
                            flow_txt = f"{q:.0f} m3/h"
                        full_txt = f"{spec_txt}\n{flow_txt}"
                        # default label color is darkgreen (supply); for return we'll redraw with skyblue below
                        lbl_color = 'darkgreen'
                        if orient == 'H':
                            # horizontal segment: draw short vertical tick above midpoint and place text above
                            x_tick = mx
                            y_base = my
                            y_tick = my - tick_len
                            pal.canvas.create_line(x_tick, y_base, x_tick, y_tick, fill=lbl_color, width=1, tags=('duct', f'hvac:{hvac_name}'))
                            pal.canvas.create_text(x_tick, y_tick - text_pad, text=full_txt, fill=lbl_color, font=('Arial', 9), anchor='s', tags=('duct', f'hvac:{hvac_name}'))
                        else:
                            # vertical segment: draw short horizontal tick to the right of midpoint and place text to the right
                            y_tick = my
                            x_base = mx
                            x_tick = mx + tick_len
                            pal.canvas.create_line(x_base, y_tick, x_tick, y_tick, fill=lbl_color, width=1, tags=('duct', f'hvac:{hvac_name}'))
                            pal.canvas.create_text(x_tick + text_pad, y_tick, text=full_txt, fill=lbl_color, font=('Arial', 9), anchor='w', tags=('duct', f'hvac:{hvac_name}'))
                    except Exception:
                        try:
                            pal.canvas.create_text(mx, my, text=label, fill='navy', font=('Arial', 10))
                        except Exception:
                            pass
                except Exception:
                    continue
        except Exception:
            pass

        # compute total duct surface area for supply and return and write only quantities to result box
        try:
            def compute_rect_wh_mm(q_val):
                try:
                    dp_val_local = float(self.sizing_pressure_entry.get() or 0.1)
                except Exception:
                    dp_val_local = 0.1
                D_exact_local = calc_circular_diameter_mm(max(0.0, q_val), max(1e-6, dp_val_local))
                try:
                    r_raw_local = (self.sizing_ratio_cb.get() or "2")
                    r_local = float(r_raw_local)
                    if r_local <= 0:
                        r_local = 2.0
                except Exception:
                    r_local = 2.0
                if D_exact_local <= 0:
                    return 0, 0
                try:
                    a_cont_l = (D_exact_local / 1.3) * ((1.0 + r_local) ** 0.25) / (r_local ** 0.625)
                    b_cont_l = r_local * a_cont_l
                except Exception:
                    a_cont_l = D_exact_local / 1.3
                    b_cont_l = a_cont_l * r_local
                w_cont_l = max(a_cont_l, b_cont_l)
                h_cont_l = min(a_cont_l, b_cont_l)
                import math
                def _floor50(x):
                    v = math.floor(x / 50.0) * 50
                    return int(max(50, v))
                def _ceil50(x):
                    v = math.ceil(x / 50.0) * 50
                    return int(max(50, v))
                w1_l = _floor50(w_cont_l)
                h1_l = _floor50(h_cont_l)
                def rect_to_circle(a_rect, b_rect):
                    try:
                        return 1.3 * (((a_rect * b_rect) ** 0.625) / ((a_rect + b_rect) ** 0.25))
                    except Exception:
                        return 0.0
                D1_l = rect_to_circle(w1_l, h1_l)
                if D1_l >= D_exact_local:
                    return int(w1_l), int(h1_l)
                else:
                    w2_l = _ceil50(w_cont_l)
                    h2_l = h1_l
                    D2_l = rect_to_circle(w2_l, h2_l)
                    if D2_l >= D_exact_local:
                        return int(w2_l), int(h2_l)
                    else:
                        h3_l = _ceil50(h_cont_l)
                        w3_l = w2_l
                        return int(w3_l), int(h3_l)

            supply_area = 0.0
            for seg, qv in seg_flow_map_supply.items():
                try:
                    orient, fixed, a, b = seg
                    W_mm, H_mm = compute_rect_wh_mm(qv)
                    if W_mm <= 0 or H_mm <= 0:
                        continue
                    W_m = float(W_mm) / 1000.0
                    H_m = float(H_mm) / 1000.0
                    length_m = abs(b - a) * grid_m
                    supply_area += (W_m + H_m) * 2.0 * length_m
                except Exception:
                    continue

            return_area = 0.0
            for seg, qv in seg_flow_map_return.items():
                try:
                    orient, fixed, a, b = seg
                    W_mm, H_mm = compute_rect_wh_mm(qv)
                    if W_mm <= 0 or H_mm <= 0:
                        continue
                    W_m = float(W_mm) / 1000.0
                    H_m = float(H_mm) / 1000.0
                    length_m = abs(b - a) * grid_m
                    return_area += (W_m + H_m) * 2.0 * length_m
                except Exception:
                    continue

            try:
                # only write quantities to the result text area
                self.sizing_text.insert(tk.END, f"[QUANTITY] Supply total duct area: {supply_area:,.2f} m2 (segments={len(seg_flow_map_supply)})\n")
                self.sizing_text.insert(tk.END, f"[QUANTITY] Return total duct area: {return_area:,.2f} m2 (segments={len(seg_flow_map_return)})\n")
            except Exception:
                try:
                    print(f"Supply area: {supply_area:.2f} m2, Return area: {return_area:.2f} m2")
                except Exception:
                    pass
        except Exception:
            pass

        # If no per-segment flows were computed, show per-terminal flow labels so user sees values
        try:
            if not seg_flow_map:
                for ti, tf in enumerate(terminal_flows):
                    try:
                        pal_t, did_t, ttype, cx_t, cy_t = terminal_items[ti]
                    except Exception:
                        continue
                    try:
                        # compute rectangle size for terminal using sizing inputs
                        try:
                            dp_val_t = float(self.sizing_pressure_entry.get() or 0.1)
                        except Exception:
                            dp_val_t = 0.1
                        # treat per-terminal flow similarly
                        D_t = calc_circular_diameter_mm(max(0.0, tf), max(1e-6, dp_val_t))
                        try:
                            r_raw = (self.sizing_ratio_cb.get() or "2")
                            r = float(r_raw)
                            if r <= 0:
                                r = 2.0
                        except Exception:
                            r = 2.0
                        if D_t > 0:
                            try:
                                a_cont_t = (D_t / 1.3) * ((1.0 + r) ** 0.25) / (r ** 0.625)
                                b_cont_t = r * a_cont_t
                            except Exception:
                                a_cont_t = D_t / 1.3
                                b_cont_t = a_cont_t * r
                            w_cont_t = max(a_cont_t, b_cont_t)
                            h_cont_t = min(a_cont_t, b_cont_t)
                            import math
                            def floor50(x):
                                v = math.floor(x / 50.0) * 50
                                return int(max(50, v))
                            def ceil50(x):
                                v = math.ceil(x / 50.0) * 50
                                return int(max(50, v))
                            w1t = floor50(w_cont_t)
                            h1t = floor50(h_cont_t)
                            def rect_to_circle(a_rect, b_rect):
                                try:
                                    return 1.3 * (((a_rect * b_rect) ** 0.625) / ((a_rect + b_rect) ** 0.25))
                                except Exception:
                                    return 0.0
                            D1t = rect_to_circle(w1t, h1t)
                            if D1t >= D_t:
                                w_final_t, h_final_t = w1t, h1t
                            else:
                                w2t = ceil50(w_cont_t)
                                h2t = h1t
                                D2t = rect_to_circle(w2t, h2t)
                                if D2t >= D_t:
                                    w_final_t, h_final_t = w2t, h2t
                                else:
                                    h3t = ceil50(h_cont_t)
                                    w3t = w2t
                                    w_final_t, h_final_t = w3t, h3t
                            labtxt = f"{tf:.0f} m3/h\n{int(w_final_t)} x {int(h_final_t)} mm"
                        else:
                            labtxt = f"{tf:.0f} m3/h"
                        # draw text with white background rectangle for visibility
                        try:
                            # draw small tick and offset text to avoid covering diffuser/line
                            tick = 6
                            pad = 6
                            # place vertical tick up from terminal point and text above
                            x0 = cx_t
                            y0 = cy_t
                            # labtxt currently already contains both lines when available; ensure ordering spec on top
                            try:
                                # If labtxt has 'm3/h' first, reorder
                                if '\n' in labtxt and labtxt.strip().split('\n')[0].strip().endswith('m3/h'):
                                    parts = labtxt.split('\n')
                                    labtxt = parts[1] + '\n' + parts[0]
                            except Exception:
                                pass
                            pal_t.canvas.create_line(x0, y0, x0, y0 - tick, fill='darkgreen', width=1, tags=('duct', f'hvac:{hvac_name}'))
                            pal_t.canvas.create_text(x0, y0 - tick - pad, text=labtxt, fill='darkgreen', font=('Arial', 9), anchor='s', tags=('duct', f'hvac:{hvac_name}'))
                        except Exception:
                            pal_t.canvas.create_text(cx_t + 8, cy_t - 10, text=labtxt, fill='darkgreen', font=('Arial', 10))
                    except Exception:
                        try:
                            pal_t.canvas.create_text(cx_t + 8, cy_t - 10, text=str(tf), fill='darkgreen', font=('Arial', 8))
                        except Exception:
                            pass
        except Exception:
            pass

    # draw onto palettes (convert grid indices back to pixel coords)

        # draw segments (convert grid indices back to pixel coords on the mapping palette)
        try:
            # determine pixel spacing for grid_m on the mapping palette
            try:
                if hasattr(pal, 'meter_to_pixel'):
                    spacing_px = pal.meter_to_pixel(grid_m)
                else:
                    spacing_px = grid_m * getattr(pal, 'scale', 1.0)
            except Exception:
                spacing_px = grid_m * getattr(pal, 'scale', 1.0)
        except Exception:
            spacing_px = grid_m * getattr(pal, 'scale', 1.0)

        # draw supply segments first (base coords)
        try:
            for seg, q in list(seg_flow_map_supply.items()):
                try:
                    orient, fixed, a, b = seg
                    if orient == 'H':
                        y = fixed * spacing_px
                        x1, x2 = a * spacing_px, b * spacing_px
                        try:
                            pal.canvas.create_line(x1, y, x2, y, fill='darkgreen', width=max(2, int(2 * getattr(pal, 'canvas_scale', 1.0))), tags=('duct', f'hvac:{hvac_name}'))
                        except Exception:
                            try:
                                pal.canvas.create_line(x1, y, x2, y, fill='darkgreen', width=2, tags=('duct', f'hvac:{hvac_name}'))
                            except Exception:
                                pass
                    else:
                        x = fixed * spacing_px
                        y1, y2 = a * spacing_px, b * spacing_px
                        try:
                            pal.canvas.create_line(x, y1, x, y2, fill='darkgreen', width=max(2, int(2 * getattr(pal, 'canvas_scale', 1.0))), tags=('duct', f'hvac:{hvac_name}'))
                        except Exception:
                            try:
                                pal.canvas.create_line(x, y1, x, y2, fill='darkgreen', width=2, tags=('duct', f'hvac:{hvac_name}'))
                            except Exception:
                                pass
                except Exception:
                    continue
        except Exception:
            pass

        # draw supply labels (spec + flow) in darkgreen at midpoint
        try:
            for seg, q in list(seg_flow_map_supply.items()):
                try:
                    orient, fixed, a, b = seg
                    if hasattr(pal, 'meter_to_pixel'):
                        spacing_px = pal.meter_to_pixel(grid_m)
                    else:
                        spacing_px = grid_m * getattr(pal, 'scale', 1.0)
                    if orient == 'H':
                        y = fixed * spacing_px
                        x1, x2 = a * spacing_px, b * spacing_px
                        mx = (x1 + x2) / 2.0
                        my = y
                    else:
                        x = fixed * spacing_px
                        y1, y2 = a * spacing_px, b * spacing_px
                        mx = x
                        my = (y1 + y2) / 2.0

                    # compute sizing for display (reuse same logic)
                    try:
                        dp_val = float(self.sizing_pressure_entry.get() or 0.1)
                    except Exception:
                        dp_val = 0.1
                    D_exact = calc_circular_diameter_mm(max(0.0, q), max(1e-6, dp_val))
                    try:
                        r_raw = (self.sizing_ratio_cb.get() or "2")
                        r = float(r_raw)
                        if r <= 0:
                            r = 2.0
                    except Exception:
                        r = 2.0
                    if D_exact > 0:
                        try:
                            a_cont = (D_exact / 1.3) * ((1.0 + r) ** 0.25) / (r ** 0.625)
                            b_cont = r * a_cont
                        except Exception:
                            a_cont = D_exact / 1.3
                            b_cont = a_cont * r
                        w_cont = max(a_cont, b_cont)
                        h_cont = min(a_cont, b_cont)
                        import math
                        def _floor50(x):
                            v = math.floor(x / 50.0) * 50
                            return int(max(50, v))
                        def _ceil50(x):
                            v = math.ceil(x / 50.0) * 50
                            return int(max(50, v))
                        w1 = _floor50(w_cont)
                        h1 = _floor50(h_cont)
                        def rect_to_circle(a_rect, b_rect):
                            try:
                                return 1.3 * (((a_rect * b_rect) ** 0.625) / ((a_rect + b_rect) ** 0.25))
                            except Exception:
                                return 0.0
                        D1 = rect_to_circle(w1, h1)
                        if D1 >= D_exact:
                            w_final, h_final = w1, h1
                        else:
                            w2 = _ceil50(w_cont)
                            h2 = h1
                            D2 = rect_to_circle(w2, h2)
                            if D2 >= D_exact:
                                w_final, h_final = w2, h2
                            else:
                                h3 = _ceil50(h_cont)
                                w3 = w2
                                w_final, h_final = w3, h3
                        W_lbl = int(w_final)
                        H_lbl = int(h_final)
                    else:
                        W_lbl = 0
                        H_lbl = 0

                    try:
                        spec_txt = f"{int(W_lbl):,} x {int(H_lbl):,} mm"
                    except Exception:
                        spec_txt = f"{W_lbl} x {H_lbl} mm"
                    try:
                        flow_txt = f"{q:,.0f} m3/h"
                    except Exception:
                        flow_txt = f"{q:.0f} m3/h"
                    full_txt = f"{spec_txt}\n{flow_txt}"

                    # draw tick and text
                    try:
                        tick_len = max(6, int(spacing_px * 0.08))
                        text_pad = 6
                        lbl_color = 'darkgreen'
                        if orient == 'H':
                            x_tick = mx
                            y_base = my
                            y_tick = my - tick_len
                            pal.canvas.create_line(x_tick, y_base, x_tick, y_tick, fill=lbl_color, width=1, tags=('duct', f'hvac:{hvac_name}'))
                            pal.canvas.create_text(x_tick, y_tick - text_pad, text=full_txt, fill=lbl_color, font=('Arial', 9), anchor='s', tags=('duct', f'hvac:{hvac_name}'))
                        else:
                            y_tick = my
                            x_base = mx
                            x_tick = mx + tick_len
                            pal.canvas.create_line(x_base, y_tick, x_tick, y_tick, fill=lbl_color, width=1, tags=('duct', f'hvac:{hvac_name}'))
                            pal.canvas.create_text(x_tick + text_pad, y_tick, text=full_txt, fill=lbl_color, font=('Arial', 9), anchor='w', tags=('duct', f'hvac:{hvac_name}'))
                    except Exception:
                        try:
                            pal.canvas.create_text(mx, my, text=full_txt, fill='darkgreen', font=('Arial', 10))
                        except Exception:
                            pass
                except Exception:
                    continue
        except Exception:
            pass

        # helper to check interval overlap on grid indices
        def _intervals_overlap(a1, b1, a2, b2):
            try:
                lo = max(min(a1, b1), min(a2, b2))
                hi = min(max(a1, b1), max(a2, b2))
                return lo < hi
            except Exception:
                return False

        # draw return segments, offset if they overlap any supply segment on same line
        try:
            offset_px = max(4, int(spacing_px * 0.08))
            for seg, q in list(seg_flow_map_return.items()):
                try:
                    orient, fixed, a, b = seg
                    # detect overlap with any supply segment of same orient and fixed
                    overlaps = False
                    for sseg in seg_flow_map_supply.keys():
                        try:
                            sorient, sfixed, sa, sb = sseg
                            if sorient == orient and sfixed == fixed:
                                if _intervals_overlap(a, b, sa, sb):
                                    overlaps = True
                                    break
                        except Exception:
                            continue
                    if orient == 'H':
                        y = fixed * spacing_px
                        x1, x2 = a * spacing_px, b * spacing_px
                        y_draw = y + (offset_px if overlaps else 0)
                        try:
                            pal.canvas.create_line(x1, y_draw, x2, y_draw, fill='skyblue', width=max(2, int(2 * getattr(pal, 'canvas_scale', 1.0))), tags=('duct', f'hvac:{hvac_name}'))
                        except Exception:
                            try:
                                pal.canvas.create_line(x1, y_draw, x2, y_draw, fill='skyblue', width=2, tags=('duct', f'hvac:{hvac_name}'))
                            except Exception:
                                pass
                        # if offset, add short vertical connectors at both ends to preserve connectivity
                        if overlaps:
                            try:
                                pal.canvas.create_line(x1, y, x1, y_draw, fill='skyblue', width=max(2, int(2 * getattr(pal, 'canvas_scale', 1.0))), tags=('duct', f'hvac:{hvac_name}'))
                            except Exception:
                                try:
                                    pal.canvas.create_line(x1, y, x1, y_draw, fill='skyblue', width=2, tags=('duct', f'hvac:{hvac_name}'))
                                except Exception:
                                    pass
                            try:
                                pal.canvas.create_line(x2, y, x2, y_draw, fill='skyblue', width=max(2, int(2 * getattr(pal, 'canvas_scale', 1.0))), tags=('duct', f'hvac:{hvac_name}'))
                            except Exception:
                                try:
                                    pal.canvas.create_line(x2, y, x2, y_draw, fill='skyblue', width=2, tags=('duct', f'hvac:{hvac_name}'))
                                except Exception:
                                    pass
                    else:
                        x = fixed * spacing_px
                        y1, y2 = a * spacing_px, b * spacing_px
                        x_draw = x + (offset_px if overlaps else 0)
                        try:
                            pal.canvas.create_line(x_draw, y1, x_draw, y2, fill='skyblue', width=max(2, int(2 * getattr(pal, 'canvas_scale', 1.0))), tags=('duct', f'hvac:{hvac_name}'))
                        except Exception:
                            try:
                                pal.canvas.create_line(x_draw, y1, x_draw, y2, fill='skyblue', width=2, tags=('duct', f'hvac:{hvac_name}'))
                            except Exception:
                                pass
                        # if offset, add short horizontal connectors at both ends to preserve connectivity
                        if overlaps:
                            try:
                                pal.canvas.create_line(x, y1, x_draw, y1, fill='skyblue', width=max(2, int(2 * getattr(pal, 'canvas_scale', 1.0))), tags=('duct', f'hvac:{hvac_name}'))
                            except Exception:
                                try:
                                    pal.canvas.create_line(x, y1, x_draw, y1, fill='skyblue', width=2, tags=('duct', f'hvac:{hvac_name}'))
                                except Exception:
                                    pass
                            try:
                                pal.canvas.create_line(x, y2, x_draw, y2, fill='skyblue', width=max(2, int(2 * getattr(pal, 'canvas_scale', 1.0))), tags=('duct', f'hvac:{hvac_name}'))
                            except Exception:
                                try:
                                    pal.canvas.create_line(x, y2, x_draw, y2, fill='skyblue', width=2, tags=('duct', f'hvac:{hvac_name}'))
                                except Exception:
                                    pass
                except Exception:
                    continue
        except Exception:
            pass

        # draw return labels (spec + flow) in skyblue at midpoint/offset
        try:
            for seg, q in list(seg_flow_map_return.items()):
                try:
                    orient, fixed, a, b = seg
                    if hasattr(pal, 'meter_to_pixel'):
                        spacing_px = pal.meter_to_pixel(grid_m)
                    else:
                        spacing_px = grid_m * getattr(pal, 'scale', 1.0)
                    if orient == 'H':
                        y = fixed * spacing_px
                        x1, x2 = a * spacing_px, b * spacing_px
                        mx = (x1 + x2) / 2.0
                        # determine if this seg was offset (check against supply overlap)
                        overlaps = False
                        for sseg in seg_flow_map_supply.keys():
                            try:
                                sorient, sfixed, sa, sb = sseg
                                if sorient == orient and sfixed == fixed and _intervals_overlap(a, b, sa, sb):
                                    overlaps = True
                                    break
                            except Exception:
                                continue
                        y_draw = y + (max(4, int(spacing_px * 0.08)) if overlaps else 0)
                        my = y_draw
                    else:
                        x = fixed * spacing_px
                        y1, y2 = a * spacing_px, b * spacing_px
                        mx = x
                        my = (y1 + y2) / 2.0
                        overlaps = False
                        for sseg in seg_flow_map_supply.keys():
                            try:
                                sorient, sfixed, sa, sb = sseg
                                if sorient == orient and sfixed == fixed and _intervals_overlap(a, b, sa, sb):
                                    overlaps = True
                                    break
                            except Exception:
                                continue
                        x_draw = x + (max(4, int(spacing_px * 0.08)) if overlaps else 0)
                        mx = x_draw

                    # compute sizing for display
                    try:
                        dp_val = float(self.sizing_pressure_entry.get() or 0.1)
                    except Exception:
                        dp_val = 0.1
                    D_exact = calc_circular_diameter_mm(max(0.0, q), max(1e-6, dp_val))
                    try:
                        r_raw = (self.sizing_ratio_cb.get() or "2")
                        r = float(r_raw)
                        if r <= 0:
                            r = 2.0
                    except Exception:
                        r = 2.0
                    if D_exact > 0:
                        try:
                            a_cont = (D_exact / 1.3) * ((1.0 + r) ** 0.25) / (r ** 0.625)
                            b_cont = r * a_cont
                        except Exception:
                            a_cont = D_exact / 1.3
                            b_cont = a_cont * r
                        w_cont = max(a_cont, b_cont)
                        h_cont = min(a_cont, b_cont)
                        import math
                        def _floor50(x):
                            v = math.floor(x / 50.0) * 50
                            return int(max(50, v))
                        def _ceil50(x):
                            v = math.ceil(x / 50.0) * 50
                            return int(max(50, v))
                        w1 = _floor50(w_cont)
                        h1 = _floor50(h_cont)
                        def rect_to_circle(a_rect, b_rect):
                            try:
                                return 1.3 * (((a_rect * b_rect) ** 0.625) / ((a_rect + b_rect) ** 0.25))
                            except Exception:
                                return 0.0
                        D1 = rect_to_circle(w1, h1)
                        if D1 >= D_exact:
                            w_final, h_final = w1, h1
                        else:
                            w2 = _ceil50(w_cont)
                            h2 = h1
                            D2 = rect_to_circle(w2, h2)
                            if D2 >= D_exact:
                                w_final, h_final = w2, h2
                            else:
                                h3 = _ceil50(h_cont)
                                w3 = w2
                                w_final, h_final = w3, h3
                        W_lbl = int(w_final)
                        H_lbl = int(h_final)
                    else:
                        W_lbl = 0
                        H_lbl = 0

                    try:
                        spec_txt = f"{int(W_lbl):,} x {int(H_lbl):,} mm"
                    except Exception:
                        spec_txt = f"{W_lbl} x {H_lbl} mm"
                    try:
                        flow_txt = f"{q:,.0f} m3/h"
                    except Exception:
                        flow_txt = f"{q:.0f} m3/h"
                    full_txt = f"{spec_txt}\n{flow_txt}"

                    # draw tick and text
                    try:
                        tick_len = max(6, int(spacing_px * 0.08))
                        text_pad = 6
                        lbl_color = 'skyblue'
                        if orient == 'H':
                            x_tick = mx
                            y_base = my
                            y_tick = my - tick_len
                            pal.canvas.create_line(x_tick, y_base, x_tick, y_tick, fill=lbl_color, width=1, tags=('duct', f'hvac:{hvac_name}'))
                            pal.canvas.create_text(x_tick, y_tick - text_pad, text=full_txt, fill=lbl_color, font=('Arial', 9), anchor='s', tags=('duct', f'hvac:{hvac_name}'))
                        else:
                            y_tick = my
                            x_base = mx
                            x_tick = mx + tick_len
                            pal.canvas.create_line(x_base, y_tick, x_tick, y_tick, fill=lbl_color, width=1, tags=('duct', f'hvac:{hvac_name}'))
                            pal.canvas.create_text(x_tick + text_pad, y_tick, text=full_txt, fill=lbl_color, font=('Arial', 9), anchor='w', tags=('duct', f'hvac:{hvac_name}'))
                    except Exception:
                        try:
                            pal.canvas.create_text(mx, my, text=full_txt, fill='skyblue', font=('Arial', 10))
                        except Exception:
                            pass
                except Exception:
                    continue
        except Exception:
            pass

        return True

    def _sizing_clear(self):
        try:
            self.sizing_text.delete('1.0', tk.END)
        except Exception:
            pass

    def _sizing_pencil_mode(self):
        self.sizing_text.insert(tk.END, "펜슬 모드 토글(플레이스홀더)\n")

    def _sizing_auto(self):
        self.sizing_text.insert(tk.END, "자동완성 수행(플레이스홀더)\n")
    
    def _compute_thickness_breakdown(self):
        # Read the low/high pressure rule entries and display a simple summary
        try:
            # Build a table of duct segments: HVAC | Line Type | Size WxH | Length (m) | Area (m2)
            rows = []
            try:
                for pal in getattr(self, 'palettes', []):
                    try:
                        canvas = pal.canvas
                        # collect duct items on this palette
                        duct_items = list(canvas.find_withtag('duct'))
                        # separate lines and texts for matching
                        line_items = [iid for iid in duct_items if canvas.type(iid) == 'line']
                        text_items = [iid for iid in duct_items if canvas.type(iid) == 'text']

                        # helper: parse size from a text string like '1,000 x 500 mm' or '1,000 x 500 mm\n123 m3/h'
                        import re
                        def parse_size(txt):
                            try:
                                # take first line and normalize common variants
                                first = str(txt).split('\n', 1)[0]
                                # normalize multiplication sign variants and remove NBSPs
                                first = first.replace('\u00D7', 'x').replace('×', 'x').replace('\u00A0', ' ')
                                # allow comma thousand separators and optional decimals
                                m = re.search(r"([\d,]+(?:\.[\d]+)?)\s*[xX]\s*([\d,]+(?:\.[\d]+)?)\s*mm", first)
                                if m:
                                    g1 = m.group(1).replace(',', '')
                                    g2 = m.group(2).replace(',', '')
                                    try:
                                        w = float(g1)
                                        h = float(g2)
                                    except Exception:
                                        return None, None, None
                                    # present as integer mm where possible
                                    try:
                                        w_int = int(round(w))
                                        h_int = int(round(h))
                                        size_out = f"{w_int:,} x {h_int:,} mm"
                                    except Exception:
                                        size_out = f"{w} x {h} mm"
                                    return size_out, float(w) / 1000.0, float(h) / 1000.0
                            except Exception:
                                pass
                            return None, None, None

                        # precompute text coords and parsed sizes
                        text_info = {}
                        for tid in text_items:
                            try:
                                ttext = canvas.itemcget(tid, 'text')
                                tags = canvas.gettags(tid)
                                coords = canvas.coords(tid)
                                size_str, w_m, h_m = parse_size(ttext)
                                text_info[tid] = {'text': ttext, 'tags': tags, 'coords': coords, 'size_str': size_str, 'w_m': w_m, 'h_m': h_m}
                            except Exception:
                                continue

                        # for each line, find matching text (same hvac tag) nearest to midpoint
                        for lid in line_items:
                            try:
                                coords = canvas.coords(lid)
                                if not coords or len(coords) < 4:
                                    continue
                                x1, y1, x2, y2 = coords[0], coords[1], coords[-2], coords[-1]
                                mx = (x1 + x2) / 2.0
                                my = (y1 + y2) / 2.0
                                # length in pixels -> meters
                                import math
                                length_px = math.hypot(x2 - x1, y2 - y1)
                                try:
                                    length_m = pal.pixel_to_meter(length_px)
                                except Exception:
                                    length_m = length_px / getattr(pal, 'scale', 1.0)
                                tags = canvas.gettags(lid)
                                hv_tags = [t for t in tags if isinstance(t, str) and t.startswith('hvac:')]
                                hv_name = hv_tags[0].split(':', 1)[1] if hv_tags else '<unknown>'
                                # determine line type by fill color
                                try:
                                    fill = canvas.itemcget(lid, 'fill')
                                except Exception:
                                    fill = ''
                                if fill in ('darkgreen', 'green'):
                                    line_type = 'Supply'
                                elif fill in ('skyblue', 'lightblue'):
                                    line_type = 'Return'
                                else:
                                    line_type = 'Duct'

                                # Prefer texts tagged for the same HVAC, but fall back to any nearby text
                                candidates = []
                                if hv_name == '<unknown>':
                                    candidates = list(text_info.items())
                                else:
                                    candidates = [(tid, info) for tid, info in text_info.items() if f'hvac:{hv_name}' in (info.get('tags') or ())]
                                    if not candidates:
                                        # fallback to all texts when no hvac-tagged texts exist
                                        candidates = list(text_info.items())

                                best = None
                                best_d = None
                                for tid, info in candidates:
                                    try:
                                        tcoords = info.get('coords') or []
                                        if not tcoords or len(tcoords) < 2:
                                            continue
                                        # compute text center
                                        if len(tcoords) >= 4:
                                            tx = (tcoords[0] + tcoords[2]) / 2.0
                                            ty = (tcoords[1] + tcoords[3]) / 2.0
                                        else:
                                            tx = tcoords[0]
                                            ty = tcoords[1]

                                        # compute perpendicular distance from (tx,ty) to line segment (x1,y1)-(x2,y2)
                                        vx = x2 - x1
                                        vy = y2 - y1
                                        wx = tx - x1
                                        wy = ty - y1
                                        seg_len2 = vx*vx + vy*vy
                                        if seg_len2 == 0:
                                            proj = 0.0
                                        else:
                                            proj = (wx*vx + wy*vy) / seg_len2
                                        if proj < 0.0:
                                            closest_x, closest_y = x1, y1
                                        elif proj > 1.0:
                                            closest_x, closest_y = x2, y2
                                        else:
                                            closest_x = x1 + proj * vx
                                            closest_y = y1 + proj * vy
                                        dx = tx - closest_x
                                        dy = ty - closest_y
                                        dist = (dx*dx + dy*dy) ** 0.5
                                        if best_d is None or dist < best_d:
                                            best_d = dist
                                            best = info
                                    except Exception:
                                        continue

                                size_str = ''
                                w_m = None
                                h_m = None
                                # threshold: within 0.2m or 20px whichever is larger
                                try:
                                    thresh_px = max(20.0, pal.meter_to_pixel(0.2))
                                except Exception:
                                    thresh_px = 20.0
                                if best and best_d is not None and best_d <= thresh_px:
                                    size_str = best.get('size_str') or ''
                                    w_m = best.get('w_m')
                                    h_m = best.get('h_m')

                                # compute area (m2) as perimeter * length: (W + H) * 2 * length
                                area_m2 = None
                                if w_m and h_m and length_m is not None:
                                    try:
                                        area_m2 = (w_m + h_m) * 2.0 * float(length_m)
                                    except Exception:
                                        area_m2 = None

                                # store palette and line id along with display values for precise mapping
                                rows.append((hv_name, line_type, size_str or 'N/A', round(length_m, 3), round(area_m2 or 0.0, 3), pal, lid))
                            except Exception:
                                continue
                    except Exception:
                        continue
            except Exception:
                rows = []

            # create popup window with Treeview
            try:
                # ensure any transient overlay is removed so the dialog is visible
                try:
                    self._destroy_total_overlay()
                except Exception:
                    pass
                win = tk.Toplevel(self.root)
                try:
                    win.lift()
                    try:
                        win.wm_attributes('-topmost', True)
                        win.after(60, lambda: win.wm_attributes('-topmost', False))
                    except Exception:
                        pass
                except Exception:
                    pass
                win.title('덕트 물량 상세')
                win.geometry('800x400')
                cols = ('HVAC', 'Line', 'Size', 'Length(m)', 'Area(m2)')
                tv = ttk.Treeview(win, columns=cols, show='headings')
                for c in cols:
                    tv.heading(c, text=c)
                    tv.column(c, width=120 if c != 'Size' else 160, anchor=tk.W)
                tv.pack(fill=tk.BOTH, expand=True)
                # insert rows and remember mapping from tree item -> (palette, line id)
                row_map = {}
                for r in rows:
                    try:
                        # rows entries were appended as (hv_name, line_type, size_str, length_m, area_m2, pal, lid)
                        hv, ltype, size_s, length_v, area_v, pal_obj, lid_obj = r
                        display_vals = (hv, ltype, size_s, length_v, area_v)
                        iid = tv.insert('', tk.END, values=display_vals)
                        row_map[iid] = (pal_obj, lid_obj)
                    except Exception:
                        continue
                # add simple close button
                # highlight state
                current_highlight = {'pal': None, 'item': None, 'orig_opts': None}

                def clear_highlight():
                    hp = current_highlight.get('pal')
                    hi = current_highlight.get('item')
                    orig = current_highlight.get('orig_opts')
                    if hp and hi and orig:
                        try:
                            # restore original options
                            try:
                                hp.canvas.itemconfigure(hi, fill=orig.get('fill', ''), width=orig.get('width', 1))
                            except Exception:
                                pass
                        except Exception:
                            pass
                    current_highlight['pal'] = None
                    current_highlight['item'] = None
                    current_highlight['orig_opts'] = None

                def on_select(event):
                    try:
                        sel = tv.selection()
                        if not sel:
                            clear_highlight()
                            return
                        iid = sel[0]
                        pair = row_map.get(iid)
                        if not pair:
                            clear_highlight()
                            return
                        pal, lid = pair
                        if pal is None or lid is None:
                            clear_highlight()
                            return
                        # clear previous
                        clear_highlight()
                        try:
                            orig_fill = pal.canvas.itemcget(lid, 'fill')
                        except Exception:
                            orig_fill = ''
                        try:
                            orig_width = pal.canvas.itemcget(lid, 'width')
                        except Exception:
                            orig_width = 1
                        current_highlight['pal'] = pal
                        current_highlight['item'] = lid
                        current_highlight['orig_opts'] = {'fill': orig_fill, 'width': orig_width}
                        try:
                            pal.canvas.itemconfigure(lid, fill='orange', width=max(3, int(float(orig_width) * 2)))
                            # bring to front
                            pal.canvas.tag_raise(lid)
                        except Exception:
                            pass
                    except Exception:
                        pass

                tv.bind('<<TreeviewSelect>>', on_select)
                btn = tk.Button(win, text='닫기', command=lambda: (clear_highlight(), win.destroy()))
                btn.pack(pady=6)
            except Exception as e:
                try:
                    self.sizing_text.insert(tk.END, f"두께별 창 생성 오류: {e}\n")
                except Exception:
                    print("두께별 창 생성 오류:", e)
        except Exception as e:
            try:
                self.sizing_text.insert(tk.END, f"두께 계산 오류: {e}\n")
            except Exception:
                print("두께 계산 오류:", e)
        
    def _on_calc_supply_flow(self):
        rc = self.get_current_palette()
        if not rc:
            messagebox.showinfo("정보", "활성화된 팔레트가 없습니다.")
            return

        total = rc.compute_and_apply_supply_flow()

        try:
            self.supply_result_text.delete("1.0", tk.END)
            self.supply_result_text.insert(tk.END, f"Total supply flow: {total:.1f} m3/hr")
        except Exception:
            messagebox.showinfo("결과", f"총 급기 풍량: {total:.1f} m3/hr")
            
    def _on_place_diffusers(self):
        rc = self.get_current_palette()
        if not rc:
            messagebox.showinfo("정보", "활성화된 팔레트가 없습니다.")
            return
        try:
            a = float(self.diffuser_area_entry.get())
            if a <= 0:
                raise ValueError
        except Exception:
            messagebox.showerror("입력 오류", "디퓨저 담당면적에 양의 숫자를 입력하세요.")
            return
        # Before auto-placing diffusers, clear any Duct-tab actions (main points, labels,
        # highlights and hvac_map) so auto-placement starts from a clean state.
        try:
            self._clear_duct_state()
        except Exception:
            pass
        rc.auto_place_diffusers(a)

    def _clear_duct_state(self):
        """Clear all Duct-related transient state: main_point markers, text labels,
        highlighted outlines, and hvac_map entries. This does not delete diffuser ovals.
        """
        try:
            # iterate all stored hvac mappings and remove main_point/text items from their palettes
            keys = list(self.hvac_map.keys())
            for key in keys:
                try:
                    mapping = self.hvac_map.get(key)
                    if not mapping or not isinstance(mapping, dict):
                        try:
                            del self.hvac_map[key]
                        except Exception:
                            pass
                        continue
                    pal = mapping.get('palette')
                    ids = set(mapping.get('ids', set()) or set())
                    if pal:
                        for iid in list(ids):
                            try:
                                iid_int = int(iid)
                            except Exception:
                                iid_int = iid
                            try:
                                if iid_int in pal.canvas.find_all():
                                    try:
                                        tags = pal.canvas.gettags(iid_int)
                                    except Exception:
                                        tags = ()
                                    try:
                                        ctype = pal.canvas.type(iid_int)
                                    except Exception:
                                        ctype = None
                                    # delete only main_point markers or text labels
                                    if 'main_point' in tags or ctype == 'text':
                                        try:
                                            pal.canvas.delete(iid_int)
                                        except Exception:
                                            pass
                                    # delete items tagged with this hvac key (includes this system's flow labels)
                                    try:
                                        hv_tag = f'hvac:{key}'
                                        for it in list(pal.canvas.find_withtag(hv_tag)):
                                            try:
                                                pal.canvas.delete(it)
                                            except Exception:
                                                pass
                                    except Exception:
                                        pass
                            except Exception:
                                # ignore errors when querying/deleting this item
                                pass
                        # clear highlighted outlines on this palette, but keep supply-assigned persistent
                        try:
                            try:
                                supply_assigned = set(getattr(self, '_supply_assigned', set()) or set())
                            except Exception:
                                supply_assigned = set()
                            for hid in list(getattr(self, '_hvac_highlighted', set())):
                                try:
                                    if hid in pal.canvas.find_all() and hid not in supply_assigned:
                                        pal.canvas.itemconfigure(hid, outline='')
                                except Exception:
                                    pass
                            # keep any supply-assigned ids in _hvac_highlighted
                            try:
                                self._hvac_highlighted = set(x for x in getattr(self, '_hvac_highlighted', set()) if x in supply_assigned)
                            except Exception:
                                try:
                                    self._hvac_highlighted.clear()
                                except Exception:
                                    self._hvac_highlighted = set()
                        except Exception:
                            pass
                except Exception:
                    pass
            # finally clear the hvac_map entirely
            try:
                self.hvac_map.clear()
            except Exception:
                self.hvac_map = {}
            try:
                if getattr(self, 'duct_selected_label_var', None) is not None:
                    self.duct_selected_label_var.set("선택 디퓨저: 0")
            except Exception:
                pass
        except Exception:
            pass

    def _show_ahu_capacity_dialog(self):
        """Modal dialog to input AHU capacity parameters used before equal distribution.

        Fields:
        - 전체현열량 (kcal/hr)
        - 전체잠열량 (kcal/hr)
        - 현열비 (sensible fraction) (자동계산, 기본 비활성)
        - 실내온도 (℃)
        - 실내상대습도 (%RH)
        - 코일통과 후 지정상대습도 (%RH)

        Behavior:
        - If totals entered, 현열비 auto-calculated = sens/(sens+lat) and shown (disabled).
        - User may check '현열비 수동입력' to enable manual editing of 현열비.
          If manual 현열비 != 0, disable total sensible/latent inputs.
        Returns True if user confirmed (OK), False if cancelled.
        Stores values in self.ahu_capacity dict on OK.
        """
        try:
            # ensure any transient overlay is removed so the dialog is visible
            try:
                self._destroy_total_overlay()
            except Exception:
                pass
            dlg = tk.Toplevel(self.root)
            try:
                dlg.lift()
                try:
                    dlg.wm_attributes('-topmost', True)
                    dlg.after(60, lambda: dlg.wm_attributes('-topmost', False))
                except Exception:
                    pass
            except Exception:
                pass
            dlg.transient(self.root)
            dlg.title('공조기계산')
            dlg.geometry('1400x800')  # 창 크기를 더 크게 설정
            dlg.grab_set()
            # 외기조건 프레임박스 (최상단)
            topframe = tk.LabelFrame(dlg, text='외기조건')
            topframe.pack(fill=tk.X, padx=10, pady=(10,0))
            # winter/summer outdoor inputs with defaults
            win_db_var = tk.StringVar(value='-12')
            win_rh_var = tk.StringVar(value='90')
            sum_db_var = tk.StringVar(value='32')
            sum_rh_var = tk.StringVar(value='60')
            # touched flags: if defaults present, mark touched so values compute on open
            win_touched = bool(str(win_db_var.get()).strip() or str(win_rh_var.get()).strip())
            sum_touched = bool(str(sum_db_var.get()).strip() or str(sum_rh_var.get()).strip())
            # output vars for enthalpy (kcal/kg) and absolute humidity (g/kg)
            win_h_var = tk.StringVar()
            win_abs_var = tk.StringVar()
            sum_h_var = tk.StringVar()
            sum_abs_var = tk.StringVar()
            tk.Label(topframe, text='겨울철 건구온도 (℃):').grid(row=0, column=0, sticky='w', padx=4, pady=2)
            win_db_entry = tk.Entry(topframe, textvariable=win_db_var, width=10)
            win_db_entry.grid(row=0, column=1, sticky='w', padx=4, pady=2)
            tk.Label(topframe, text='겨울철 상대습도 (%RH):').grid(row=0, column=2, sticky='w', padx=4, pady=2)
            win_rh_entry = tk.Entry(topframe, textvariable=win_rh_var, width=10)
            win_rh_entry.grid(row=0, column=3, sticky='w', padx=4, pady=2)
            tk.Label(topframe, text='엔탈피 (kcal/kg):').grid(row=0, column=4, sticky='w', padx=4, pady=2)
            tk.Entry(topframe, textvariable=win_h_var, width=12, state='readonly').grid(row=0, column=5, sticky='w', padx=4, pady=2)
            tk.Label(topframe, text='절대습도 (g/kg):').grid(row=0, column=6, sticky='w', padx=4, pady=2)
            tk.Entry(topframe, textvariable=win_abs_var, width=12, state='readonly').grid(row=0, column=7, sticky='w', padx=4, pady=2)
            tk.Label(topframe, text='여름철 건구온도 (℃):').grid(row=1, column=0, sticky='w', padx=4, pady=2)
            sum_db_entry = tk.Entry(topframe, textvariable=sum_db_var, width=10)
            sum_db_entry.grid(row=1, column=1, sticky='w', padx=4, pady=2)
            tk.Label(topframe, text='여름철 상대습도 (%RH):').grid(row=1, column=2, sticky='w', padx=4, pady=2)
            sum_rh_entry = tk.Entry(topframe, textvariable=sum_rh_var, width=10)
            sum_rh_entry.grid(row=1, column=3, sticky='w', padx=4, pady=2)
            tk.Label(topframe, text='엔탈피 (kcal/kg):').grid(row=1, column=4, sticky='w', padx=4, pady=2)
            tk.Entry(topframe, textvariable=sum_h_var, width=12, state='readonly').grid(row=1, column=5, sticky='w', padx=4, pady=2)
            tk.Label(topframe, text='절대습도 (g/kg):').grid(row=1, column=6, sticky='w', padx=4, pady=2)
            tk.Entry(topframe, textvariable=sum_abs_var, width=12, state='readonly').grid(row=1, column=7, sticky='w', padx=4, pady=2)
            
            # 버튼 프레임을 먼저 하단에 고정 배치 (항상 보이도록)
            btnf = tk.Frame(dlg)
            btnf.pack(side='bottom', fill='x', padx=10, pady=8)
            
            # layout
            # content frame holds the main form on the left and the chart area on the right
            content = tk.Frame(dlg)
            # fill remaining space but leave room for bottom button frame
            content.pack(padx=10, pady=(10,0), fill=tk.BOTH, expand=True)

            frm = tk.Frame(content)
            frm.pack(side='left', fill=tk.BOTH, expand=False)

            # chart container on the right (initially empty - will draw a psychrometric chart)
            chart_frame = tk.Frame(content, width=700, height=650)
            chart_frame.pack_propagate(False)
            chart_frame.pack(side='right', padx=(10,0), fill='both', expand=True)

            def labeled_entry(parent, row, label_text, var, width=18):
                tk.Label(parent, text=label_text).grid(row=row, column=0, sticky='w', padx=4, pady=4)
                ent = tk.Entry(parent, textvariable=var, width=width)
                ent.grid(row=row, column=1, sticky='w', padx=4, pady=4)
                return ent

            # default sens/lat values
            total_sens_var = tk.StringVar(value='120,000')
            total_lat_var = tk.StringVar(value='12,000')
            sens_frac_var = tk.StringVar()
            indoor_t_var = tk.StringVar(value='23.0')
            indoor_rh_var = tk.StringVar(value='50')
            # 동절기(겨울) 입력값 — 초기값은 하절기와 동일
            indoor_w_t_var = tk.StringVar(value=indoor_t_var.get())
            indoor_w_rh_var = tk.StringVar(value=indoor_rh_var.get())
            coil_rh_var = tk.StringVar(value='95')
            # LAT display variable
            lat_var = tk.StringVar()
            # Delta T display variable (indoor temp - LAT)
            delta_var = tk.StringVar()
            manual_frac_var = tk.IntVar(value=0)

            ent_sens = labeled_entry(frm, 0, '전체현열량 (kcal/hr):', total_sens_var)
            ent_lat = labeled_entry(frm, 1, '전체잠열량 (kcal/hr):', total_lat_var)
            
            # Add FocusOut handler to latent entry: if empty, set to 0
            def on_lat_focus_out(event=None):
                try:
                    val = total_lat_var.get().strip()
                    if val == '':
                        total_lat_var.set('0')
                except Exception:
                    pass
            ent_lat.bind('<FocusOut>', on_lat_focus_out)
            
            ent_frac = labeled_entry(frm, 2, '현열비 (0~1):', sens_frac_var)
            # default: fraction entry disabled (auto-calculated)
            try:
                ent_frac.configure(state='disabled')
            except Exception:
                ent_frac.configure(state='readonly')

            chk = tk.Checkbutton(frm, text='수동입력', variable=manual_frac_var)
            # Do not change grid positions of the label and entry for 현열비.
            # Instead place the checkbox visually between them after layout using absolute placement.
            def place_manual_chk():
                try:
                    # find the label and entry widgets placed by labeled_entry at row=2
                    lbls = frm.grid_slaves(row=2, column=0)
                    ents = frm.grid_slaves(row=2, column=1)
                    if not lbls or not ents:
                        # try again shortly if geometry not ready
                        frm.after(50, place_manual_chk)
                        return
                    lbl = lbls[0]
                    ent_widget = ents[0]
                    # compute x as right edge of label + small gap
                    x = lbl.winfo_x() + lbl.winfo_width() + 6
                    # align vertically with the entry widget
                    y = ent_widget.winfo_y()
                    chk.place(x=x, y=y)
                except Exception:
                    try:
                        frm.after(50, place_manual_chk)
                    except Exception:
                        pass

            # schedule placement after geometry is calculated
            frm.after(50, place_manual_chk)

            # 실내난방부하 (kcal/hr) - insert after 현열비 and before 실내온도
            indoor_heat_load_var = tk.StringVar(value='50000')
            ent_indoor_heat = labeled_entry(frm, 3, '실내난방부하 (kcal/hr):', indoor_heat_load_var)
            # live-format for indoor heat load
            def live_format_heat(event=None):
                try:
                    s = indoor_heat_load_var.get()
                    if not s:
                        return
                    st = str(s).replace(',', '').replace('\u00A0', '').strip()
                    if st == '':
                        return
                    v = float(st)
                    indoor_heat_load_var.set(f"{int(round(v)):,.0f}")
                except Exception:
                    return

            ent_indoor_heat.bind('<KeyRelease>', live_format_heat)

            # create an Indoor Conditions frame right above the main form
            # 체크된 상태가 기본 (동절기조건 동일)
            indoor_same_winter_var = tk.IntVar(value=1)
            indoor_frame = tk.LabelFrame(dlg, text='실내조건')
            # entries inside indoor_frame
            tk.Label(indoor_frame, text='(하절기)건구온도 (℃):').grid(row=0, column=0, sticky='w', padx=4, pady=2)
            ent_indoor_t_entry = tk.Entry(indoor_frame, textvariable=indoor_t_var, width=10)
            ent_indoor_t_entry.grid(row=0, column=1, sticky='w', padx=4, pady=2)
            tk.Label(indoor_frame, text='(하절기)상대습도 (%RH):').grid(row=0, column=2, sticky='w', padx=4, pady=2)
            ent_indoor_rh_entry = tk.Entry(indoor_frame, textvariable=indoor_rh_var, width=10)
            ent_indoor_rh_entry.grid(row=0, column=3, sticky='w', padx=4, pady=2)
            # absolute humidity next to RH (read-only, g/kg)
            indoor_abs_var = tk.StringVar()
            tk.Label(indoor_frame, text='(하절기)절대습도 (g/kg):').grid(row=0, column=4, sticky='w', padx=4, pady=2)
            ent_indoor_abs = tk.Entry(indoor_frame, textvariable=indoor_abs_var, width=10, state='readonly')
            ent_indoor_abs.grid(row=0, column=5, sticky='w', padx=4, pady=2)
            # checkbox placed to the far right
            try:
                chk_same = tk.Checkbutton(indoor_frame, variable=indoor_same_winter_var, text='동절기 조건 동일')
                chk_same.grid(row=0, column=6, sticky='w', padx=4, pady=2)
            except Exception:
                pass

            # 동절기 입력창 (초기값은 하절기 값과 동일)
            tk.Label(indoor_frame, text='(동절기)건구온도 (℃):').grid(row=1, column=0, sticky='w', padx=4, pady=2)
            ent_indoor_w_t_entry = tk.Entry(indoor_frame, textvariable=indoor_w_t_var, width=10)
            ent_indoor_w_t_entry.grid(row=1, column=1, sticky='w', padx=4, pady=2)
            tk.Label(indoor_frame, text='(동절기)상대습도 (%RH):').grid(row=1, column=2, sticky='w', padx=4, pady=2)
            ent_indoor_w_rh_entry = tk.Entry(indoor_frame, textvariable=indoor_w_rh_var, width=10)
            ent_indoor_w_rh_entry.grid(row=1, column=3, sticky='w', padx=4, pady=2)
            # absolute humidity for winter
            indoor_w_abs_var = tk.StringVar()
            tk.Label(indoor_frame, text='(동절기)절대습도 (g/kg):').grid(row=1, column=4, sticky='w', padx=4, pady=2)
            ent_indoor_w_abs = tk.Entry(indoor_frame, textvariable=indoor_w_abs_var, width=10, state='readonly')
            ent_indoor_w_abs.grid(row=1, column=5, sticky='w', padx=4, pady=2)

            # handlers: toggle enable/disable and sync values from 하절기 -> 동절기 when checked
            def on_same_toggle(*_a):
                same = bool(indoor_same_winter_var.get())
                st = 'disabled' if same else 'normal'
                try:
                    ent_indoor_w_t_entry.configure(state=st)
                    ent_indoor_w_rh_entry.configure(state=st)
                except Exception:
                    pass
                if same:
                    # copy current 하절기 values into 동절기
                    indoor_w_t_var.set(indoor_t_var.get())
                    indoor_w_rh_var.set(indoor_rh_var.get())
                # when toggling, update mixed/coil calculations to reflect new state
                try:
                    update_mixed_props()
                except Exception:
                    try:
                        recompute_lat()
                    except Exception:
                        pass

            def sync_summer_to_winter(*_a):
                if indoor_same_winter_var.get():
                    indoor_w_t_var.set(indoor_t_var.get())
                    indoor_w_rh_var.set(indoor_rh_var.get())

            # attach traces
            try:
                indoor_same_winter_var.trace('w', lambda *a: on_same_toggle())
                indoor_t_var.trace('w', lambda *a: sync_summer_to_winter())
                indoor_rh_var.trace('w', lambda *a: sync_summer_to_winter())
                # update absolute humidity displays when indoor temp or RH change
                def update_indoor_abs(*_a):
                    try:
                        t = to_float(indoor_t_var.get())
                        rh = to_float(indoor_rh_var.get())
                        if t is None or rh is None:
                            indoor_abs_var.set('')
                        else:
                            w = humidity_ratio(float(t), float(rh) / 100.0)
                            if w is None:
                                indoor_abs_var.set('')
                            else:
                                # convert kg/kg -> g/kg
                                indoor_abs_var.set(f"{w*1000.0:.2f}")
                    except Exception:
                        indoor_abs_var.set('')
                    # redraw chart
                    try:
                        draw_psychrometric()
                    except Exception:
                        pass

                def update_indoor_w_abs(*_a):
                    try:
                        t = to_float(indoor_w_t_var.get())
                        rh = to_float(indoor_w_rh_var.get())
                        if t is None or rh is None:
                            indoor_w_abs_var.set('')
                        else:
                            w = humidity_ratio(float(t), float(rh) / 100.0)
                            if w is None:
                                indoor_w_abs_var.set('')
                            else:
                                indoor_w_abs_var.set(f"{w*1000.0:.2f}")
                    except Exception:
                        indoor_w_abs_var.set('')
                    # redraw chart
                    try:
                        draw_psychrometric()
                    except Exception:
                        pass
                    except Exception:
                        indoor_w_abs_var.set('')

                indoor_t_var.trace_add('write', lambda *a: (sync_summer_to_winter(), update_indoor_abs()))
                indoor_rh_var.trace_add('write', lambda *a: (sync_summer_to_winter(), update_indoor_abs()))
                indoor_w_t_var.trace_add('write', lambda *a: update_indoor_w_abs())
                indoor_w_rh_var.trace_add('write', lambda *a: update_indoor_w_abs())
                
                # Note: initial absolute humidity values computed in _initial_recompute (after humidity_ratio defined)
            except Exception:
                pass

            # ensure initial state reflects "동절기 조건 동일"
            on_same_toggle()
            # pack the indoor frame before the main form frame
            try:
                indoor_frame.pack(fill=tk.X, padx=10, pady=(6,0), before=frm)
            except Exception:
                indoor_frame.pack(fill=tk.X, padx=10, pady=(6,0))

            # Add a canvas on the right to show a psychrometric chart
            chart_canvas = tk.Canvas(chart_frame, bg='#1a1a1a', bd=1, relief='sunken')
            # fill the chart_frame
            chart_canvas.pack(fill='both', expand=True)

            ent_coil_rh = labeled_entry(frm, 6, '코일통과 후 RH (%RH):', coil_rh_var)
            # LAT display (read-only)
            tk.Label(frm, text='LAT (℃):').grid(row=7, column=0, sticky='w', padx=4, pady=4)
            ent_lat_display = tk.Entry(frm, textvariable=lat_var, width=18, state='readonly')
            ent_lat_display.grid(row=7, column=1, sticky='w', padx=4, pady=4)
            # Coil-exit enthalpy at LAT (read-only)
            coil_ent_var = tk.StringVar()
            tk.Label(frm, text='코일 통과 후 엔탈피 (kcal/kg):').grid(row=8, column=0, sticky='w', padx=4, pady=4)
            ent_coil_ent = tk.Entry(frm, textvariable=coil_ent_var, width=18, state='readonly')
            ent_coil_ent.grid(row=8, column=1, sticky='w', padx=4, pady=4)
            # Delta T display (read-only)
            tk.Label(frm, text='ΔT (℃):').grid(row=9, column=0, sticky='w', padx=4, pady=4)
            ent_delta_display = tk.Entry(frm, textvariable=delta_var, width=18, state='readonly')
            ent_delta_display.grid(row=9, column=1, sticky='w', padx=4, pady=4)
            # AHU-design delta (ΔT - 0.3) display - placed between ΔT and 온도차 풍량
            calc_delta_var = tk.StringVar()
            tk.Label(frm, text='공조기 산정용 온도차(℃, △T - 0.3 )').grid(row=10, column=0, sticky='w', padx=4, pady=4)
            ent_calc_delta = tk.Entry(frm, textvariable=calc_delta_var, width=18, state='readonly')
            ent_calc_delta.grid(row=10, column=1, sticky='w', padx=4, pady=4)
            # AHU airflow display (read-only) computed from total sensible and delta T
            flow_var = tk.StringVar()
            tk.Label(frm, text='온도차(△T) 풍량 (m3/hr):').grid(row=11, column=0, sticky='w', padx=4, pady=4)
            ent_flow_display = tk.Entry(frm, textvariable=flow_var, width=18, state='readonly')
            ent_flow_display.grid(row=11, column=1, sticky='w', padx=4, pady=4)
            # AHU-design delta margin flow (supply flow)
            margin_flow_var = tk.StringVar()
            # rename to 급기풍량 (supply flow)
            tk.Label(frm, text='급기풍량 (m3/hr):').grid(row=13, column=0, sticky='w', padx=4, pady=4)
            ent_margin_flow = tk.Entry(frm, textvariable=margin_flow_var, width=18, state='readonly')
            ent_margin_flow.grid(row=13, column=1, sticky='w', padx=4, pady=4)
            # Outdoor air input (accept number or percent)
            outdoor_var = tk.StringVar(value='0')
            tk.Label(frm, text='외기량 (m3/hr 또는 % 입력 가능):').grid(row=14, column=0, sticky='w', padx=4, pady=4)
            ent_outdoor = tk.Entry(frm, textvariable=outdoor_var, width=18)
            ent_outdoor.grid(row=14, column=1, sticky='w', padx=4, pady=4)
            # inline note for outdoor conversion messages (non-modal)
            outdoor_note_var = tk.StringVar()
            outdoor_note_lbl = tk.Label(frm, textvariable=outdoor_note_var, fg='brown')
            outdoor_note_lbl.grid(row=14, column=2, sticky='w', padx=4, pady=4)
            # Return air (회수풍량) display (read-only)
            return_flow_var = tk.StringVar()
            tk.Label(frm, text='회수풍량 (m3/hr):').grid(row=15, column=0, sticky='w', padx=4, pady=4)
            ent_return_flow = tk.Entry(frm, textvariable=return_flow_var, width=18, state='readonly')
            ent_return_flow.grid(row=15, column=1, sticky='w', padx=4, pady=4)
            # Mixed temperature and enthalpy display
            mix_temp_var = tk.StringVar()
            mix_ent_var = tk.StringVar()
            tk.Label(frm, text='혼합온도 (℃):').grid(row=16, column=0, sticky='w', padx=4, pady=4)
            ent_mix_temp = tk.Entry(frm, textvariable=mix_temp_var, width=18, state='readonly')
            ent_mix_temp.grid(row=16, column=1, sticky='w', padx=4, pady=4)
            tk.Label(frm, text='혼합엔탈피 (kcal/kg):').grid(row=17, column=0, sticky='w', padx=4, pady=4)
            ent_mix_ent = tk.Entry(frm, textvariable=mix_ent_var, width=18, state='readonly')
            ent_mix_ent.grid(row=17, column=1, sticky='w', padx=4, pady=4)
            # Chilled coil capacity (kcal/hr) with 10% margin (label changed to 냉방코일용량)
            coil_cap_var = tk.StringVar()
            tk.Label(frm, text='냉방코일용량 (kcal/hr, 10%가산):').grid(row=18, column=0, sticky='w', padx=4, pady=4)
            ent_coil_cap = tk.Entry(frm, textvariable=coil_cap_var, width=18, state='readonly')
            ent_coil_cap.grid(row=18, column=1, sticky='w', padx=4, pady=4)
            # Heating coil capacity (kcal/hr) with 10% margin (placed below chilled water capacity)
            heat_cap_var = tk.StringVar()
            tk.Label(frm, text='난방코일용량 (kcal/hr, 10%가산):').grid(row=19, column=0, sticky='w', padx=4, pady=4)
            ent_heat_cap = tk.Entry(frm, textvariable=heat_cap_var, width=18, state='readonly')
            ent_heat_cap.grid(row=19, column=1, sticky='w', padx=4, pady=4)
            # Humidification capacity (kg/hr) - placed after heating coil capacity
            humid_cap_var = tk.StringVar()
            tk.Label(frm, text='가습용량 (kg/hr):').grid(row=20, column=0, sticky='w', padx=4, pady=4)
            ent_humid_cap = tk.Entry(frm, textvariable=humid_cap_var, width=18, state='readonly')
            ent_humid_cap.grid(row=20, column=1, sticky='w', padx=4, pady=4)
            
            # generic commit handler: when an entry is committed (Enter or focus lost)
            # IMPORTANT: Define this FIRST so other handlers can call it
            def process_entry_commit(event=None):
                # run the common recompute chain; swallowing exceptions to keep UI robust
                try:
                    recompute_outdoor_props()
                except Exception:
                    pass
                try:
                    recompute_frac()
                except Exception:
                    pass
                try:
                    update_return_air()
                except Exception:
                    pass
                try:
                    update_mixed_props()
                except Exception:
                    pass
                try:
                    recompute_lat()
                except Exception:
                    pass
                try:
                    compute_humid_capacity()
                except Exception:
                    pass
                try:
                    draw_psychrometric()
                except Exception:
                    pass

            # when focus leaves, if value contains % convert using margin_flow_var
            def process_outdoor_focusout(event=None):
                try:
                    raw = (outdoor_var.get() or '').strip()
                    if raw == '':
                        return
                    # percent input
                    if '%' in raw:
                        try:
                            p = raw.replace('%', '').strip()
                            p_num = to_float(p)
                            if p_num is None:
                                outdoor_var.set('')
                                return
                            p_frac = float(p_num) / 100.0
                            base = to_float(margin_flow_var.get())
                            if base is None:
                                # can't compute without margin flow
                                outdoor_var.set('')
                                return
                            val = float(base) * p_frac
                            # ceil to nearest 100
                            val_ceil = int(math.ceil(val / 100.0) * 100)
                            outdoor_var.set(f"{val_ceil:,}")
                            # update return air display
                            try:
                                update_return_air()
                            except Exception:
                                pass
                        except Exception:
                            outdoor_var.set('')
                    else:
                        # numeric input: format with commas, keep value as-is (no ceil)
                        try:
                            v = to_float(raw)
                            if v is None:
                                outdoor_var.set('')
                                return
                            vi = int(round(v))
                            outdoor_var.set(f"{vi:,}")
                            try:
                                update_return_air()
                            except Exception:
                                pass
                        except Exception:
                            outdoor_var.set('')
                except Exception:
                    try:
                        outdoor_var.set('')
                    except Exception:
                        pass

            try:
                ent_outdoor.bind('<FocusOut>', process_outdoor_focusout)
                # when Enter pressed in outdoor entry, first convert %->m3/hr then run full recompute
                def handle_outdoor_return(event=None):
                    # Run a full recompute first so margin_flow_var / flow_var may be available
                    try:
                        process_entry_commit()
                    except Exception:
                        pass

                    raw = (outdoor_var.get() or '').strip()
                    if not raw:
                        # nothing to do
                        return

                    # If the user entered a percent, try to convert to m3/hr
                    if '%' in raw:
                        try:
                            p = raw.replace('%', '').strip()
                            p_num = to_float(p)
                        except Exception:
                            p_num = None

                        if p_num is None:
                            # invalid percent, leave as-is but run recompute
                            process_entry_commit()
                            return

                        # Prefer margin_flow_var (design), fall back to AHU flow
                        base = to_float(margin_flow_var.get())
                        if base is None or float(base) <= 0:
                            base = to_float(flow_var.get())

                        if base is None or float(base) <= 0:
                            # Can't compute conversion: set inline note so user knows why
                            try:
                                outdoor_note_var.set('급기풍량이 계산되지 않아 % 변환 불가')
                            except Exception:
                                pass
                            # run recompute to ensure UI updated
                            try:
                                process_entry_commit()
                            except Exception:
                                pass
                            return

                        # perform conversion and update entry
                        try:
                            val = float(base) * (float(p_num) / 100.0)
                            val_ceil = int(math.ceil(val / 100.0) * 100)
                            outdoor_var.set(f"{val_ceil:,}")
                        except Exception:
                            # if conversion failed, leave value and let follow-up handlers run
                            try:
                                outdoor_note_var.set('외기 변환 중 오류')
                            except Exception:
                                pass
                            pass

                    # ensure follow-up recompute to refresh dependent fields
                    try:
                        process_entry_commit()
                    except Exception:
                        pass
                    # clear inline note if conversion succeeded or recompute ran
                    try:
                        # if the current outdoor_var value no longer contains '%', clear note
                        if '%' not in (outdoor_var.get() or ''):
                            outdoor_note_var.set('')
                    except Exception:
                        pass

                ent_outdoor.bind('<Return>', handle_outdoor_return)
            except Exception:
                pass

            # bind Enter and FocusOut on commonly edited entries so committing updates everything
            try:
                for ent in (win_db_entry, win_rh_entry, sum_db_entry, sum_rh_entry,
                            ent_sens, ent_lat, ent_indoor_heat,
                            ent_indoor_t_entry, ent_indoor_rh_entry,
                            ent_indoor_w_t_entry, ent_indoor_w_rh_entry,
                            ent_coil_rh):  # ent_outdoor removed - has custom handler
                    try:
                        ent.bind('<Return>', lambda e, fn=process_entry_commit: fn())
                    except Exception:
                        pass
                    try:
                        ent.bind('<FocusOut>', lambda e, fn=process_entry_commit: fn())
                    except Exception:
                        pass
                    try:
                        # realtime on any key change
                        ent.bind('<KeyRelease>', lambda e, fn=process_entry_commit: fn())
                    except Exception:
                        pass
            except Exception:
                pass

            def update_return_air():
                try:
                    # parse supply (급기풍량) from margin_flow_var
                    supply = to_float(margin_flow_var.get())
                    if supply is None:
                        return_flow_var.set('')
                        return
                    raw = (outdoor_var.get() or '').strip()
                    if raw == '':
                        return_flow_var.set('')
                        return
                    # if percent, compute outdoor from supply
                    if '%' in raw:
                        p = raw.replace('%', '').strip()
                        pnum = to_float(p)
                        if pnum is None:
                            return_flow_var.set('')
                            return
                        outdoor_m3 = float(supply) * (float(pnum) / 100.0)
                        outdoor_m3_ceil = int(math.ceil(outdoor_m3 / 100.0) * 100)
                    else:
                        v = to_float(raw.replace(',', ''))
                        if v is None:
                            return_flow_var.set('')
                            return
                        outdoor_m3_ceil = int(round(v))
                    # compute return = supply - outdoor
                    ret = float(supply) - float(outdoor_m3_ceil)
                    if ret <= 0:
                        # if non-positive, show 0
                        return_flow_var.set('0')
                    else:
                        ret_ceil = int(math.ceil(ret / 100.0) * 100)
                        return_flow_var.set(f"{ret_ceil:,}")
                    # update mixed properties after return updated
                    try:
                        update_mixed_props()
                    except Exception:
                        pass
                except Exception:
                    try:
                        return_flow_var.set('')
                    except Exception:
                        pass

            # bind key events to ensure recompute on typing (robust across platforms)
            try:
                # live-format 전체현열량 (total sensible) with thousand separators on key release
                def live_format_total(event=None):
                    try:
                        s = total_sens_var.get()
                        if not s:
                            return
                        st = str(s).replace(',', '').replace('\u00A0', '').strip()
                        if st == '':
                            return
                        v = float(st)
                        # set as integer with thousand separators
                        total_sens_var.set(f"{int(round(v)):,.0f}")
                        # update dependent values
                        try:
                            recompute_frac()
                        except Exception:
                            pass
                    except Exception:
                        return

                ent_sens.bind('<KeyRelease>', live_format_total)
                ent_lat.bind('<KeyRelease>', lambda e: recompute_frac())
                # live-format 전체잠열량 as well
                def live_format_lat(event=None):
                    try:
                        s = total_lat_var.get()
                        if not s:
                            return
                        st = str(s).replace(',', '').replace('\u00A0', '').strip()
                        if st == '':
                            return
                        v = float(st)
                        total_lat_var.set(f"{int(round(v)):,.0f}")
                        try:
                            recompute_frac()
                        except Exception:
                            pass
                    except Exception:
                        return

                ent_lat.bind('<KeyRelease>', live_format_lat)
                ent_sens.bind('<FocusOut>', lambda e: format_total_with_commas(total_sens_var))
                ent_lat.bind('<FocusOut>', lambda e: format_total_with_commas(total_lat_var))
            except Exception:
                pass
            try:
                ent_frac.bind('<KeyRelease>', lambda e: recompute_lat())
            except Exception:
                pass
            try:
                ent_indoor_t.bind('<KeyRelease>', lambda e: recompute_lat())
                ent_indoor_rh.bind('<KeyRelease>', lambda e: recompute_lat())
                ent_coil_rh.bind('<KeyRelease>', lambda e: recompute_lat())
                # also bind 동절기 inputs to recompute heating/cooling in real time
                try:
                    indoor_w_t_var.trace('w', lambda *a: (recompute_lat(), update_mixed_props()))
                    indoor_w_rh_var.trace('w', lambda *a: (recompute_lat(), update_mixed_props()))
                except Exception:
                    try:
                        indoor_w_t_var.trace_add('write', lambda *a: (recompute_lat(), update_mixed_props()))
                        indoor_w_rh_var.trace_add('write', lambda *a: (recompute_lat(), update_mixed_props()))
                    except Exception:
                        pass
                try:
                    ent_indoor_w_t_entry.bind('<KeyRelease>', lambda e: (recompute_lat(), update_mixed_props()))
                    ent_indoor_w_rh_entry.bind('<KeyRelease>', lambda e: (recompute_lat(), update_mixed_props()))
                except Exception:
                    pass
            except Exception:
                pass

            # helper parse (accept commas and NBSP)
            def to_float(s):
                try:
                    if s is None:
                        return None
                    st = str(s).strip()
                    st = st.replace(',', '').replace('\u00A0', '')
                    if st == '':
                        return None
                    return float(st)
                except Exception:
                    return None

            def format_total_with_commas(var):
                try:
                    v = to_float(var.get())
                    if v is None:
                        return
                    vi = int(round(v))
                    var.set(f"{vi:,}")
                except Exception:
                    pass

            def recompute_frac(*a):
                # if manual override is off, compute from totals
                if manual_frac_var.get():
                    return
                s = to_float(total_sens_var.get())
                l = to_float(total_lat_var.get())
                if s is None or l is None:
                    sens_frac_var.set('')
                    return
                denom = (s + l)
                if denom == 0:
                    sens_frac_var.set('')
                    return
                frac = s / denom
                try:
                    sens_frac_var.set(f"{frac:.3f}")
                except Exception:
                    sens_frac_var.set(str(frac))
                # update LAT when fraction updated from totals
                try:
                    recompute_lat()
                except Exception:
                    pass

            # helpers to compute enthalpy (kcal/kg) and absolute humidity (g/kg)
            def enthalpy_kcal_per_kg(T_C, w):
                # enthalpy_kJ_per_kg_dry returns kJ/kg; convert to kcal/kg (1 kJ = 0.239005736 kcal)
                try:
                    h_kj = enthalpy_kJ_per_kg_dry(T_C, w)
                    return h_kj * 0.239005736
                except Exception:
                    return None

            def abs_humidity_g_per_kg(T_C, RH_pct):
                try:
                    w = humidity_ratio(T_C, RH_pct / 100.0)
                    if w is None:
                        return None
                    # w is kg water vapor per kg dry air -> multiply by 1000 g/kg
                    return w * 1000.0
                except Exception:
                    return None

            def recompute_outdoor_props(*a):
                try:
                    # winter: compute/display if numeric inputs are present
                    try:
                        t_w = to_float(win_db_var.get())
                        rh_w = to_float(win_rh_var.get())
                        if t_w is None or rh_w is None:
                            win_h_var.set('')
                            win_abs_var.set('')
                        else:
                            w_w = humidity_ratio(t_w, float(rh_w) / 100.0)
                            h_w = enthalpy_kcal_per_kg(t_w, w_w) if w_w is not None else None
                            if h_w is None:
                                win_h_var.set('')
                            else:
                                win_h_var.set(f"{h_w:.2f}")
                            if w_w is None:
                                win_abs_var.set('')
                            else:
                                win_abs_var.set(f"{w_w*1000.0:.2f}")
                    except Exception:
                        win_h_var.set('')
                        win_abs_var.set('')
                    # summer: compute/display if numeric inputs are present
                    try:
                        t_s = to_float(sum_db_var.get())
                        rh_s = to_float(sum_rh_var.get())
                        if t_s is None or rh_s is None:
                            sum_h_var.set('')
                            sum_abs_var.set('')
                        else:
                            w_s = humidity_ratio(t_s, float(rh_s) / 100.0)
                            h_s = enthalpy_kcal_per_kg(t_s, w_s) if w_s is not None else None
                            if h_s is None:
                                sum_h_var.set('')
                            else:
                                sum_h_var.set(f"{h_s:.2f}")
                            if w_s is None:
                                sum_abs_var.set('')
                            else:
                                sum_abs_var.set(f"{w_s*1000.0:.2f}")
                    except Exception:
                        sum_h_var.set('')
                        sum_abs_var.set('')
                    # redraw psychrometric chart
                    try:
                        draw_psychrometric()
                    except Exception:
                        pass
                except Exception:
                    pass

            def compute_humid_capacity():
                try:
                    # parse outdoor (외기량) in m3/hr — accept numeric or percent (use margin_flow if percent)
                    raw = (outdoor_var.get() or '').strip()
                    outdoor_m3 = None
                    if raw == '':
                        outdoor_m3 = 0.0
                    elif '%' in raw:
                        # prefer margin_flow then flow
                        base = to_float(margin_flow_var.get())
                        if base is None or float(base) <= 0:
                            base = to_float(flow_var.get())
                        p = raw.replace('%', '').strip()
                        pnum = to_float(p)
                        if base is None or pnum is None:
                            outdoor_m3 = None
                        else:
                            outdoor_m3 = float(base) * (float(pnum) / 100.0)
                    else:
                        v = to_float(raw.replace(',', ''))
                        outdoor_m3 = float(v) if v is not None else None

                    # get abs humidity values in g/kg
                    indoor_w_abs_g = to_float(indoor_w_abs_var.get())
                    win_abs_g = to_float(win_abs_var.get())
                    if outdoor_m3 is None or indoor_w_abs_g is None or win_abs_g is None:
                        humid_cap_var.set('')
                        return

                    # convert g/kg diff to kg/kg
                    diff_kg_per_kg = (float(indoor_w_abs_g) - float(win_abs_g)) / 1000.0
                    # formula: 1.2 * outdoor_m3 * diff (kg/hr)
                    humid_kghr = 1.2 * float(outdoor_m3) * diff_kg_per_kg
                    humid_cap_var.set(f"{humid_kghr:.2f}")
                except Exception:
                    try:
                        humid_cap_var.set('')
                    except Exception:
                        pass

            # wire traces for outdoor condition inputs
            # wire traces for outdoor condition inputs
            try:
                # mark touched flags on key activity and recompute only when touched
                def _mark_win_touched(evt=None):
                    nonlocal win_touched
                    win_touched = True
                    recompute_outdoor_props()

                def _mark_sum_touched(evt=None):
                    nonlocal sum_touched
                    sum_touched = True
                    recompute_outdoor_props()

                win_db_entry.bind('<KeyRelease>', _mark_win_touched)
                win_rh_entry.bind('<KeyRelease>', _mark_win_touched)
                sum_db_entry.bind('<KeyRelease>', _mark_sum_touched)
                sum_rh_entry.bind('<KeyRelease>', _mark_sum_touched)
                # also support trace for programmatic changes
                win_db_var.trace('w', lambda *a: recompute_outdoor_props())
                win_rh_var.trace('w', lambda *a: recompute_outdoor_props())
                sum_db_var.trace('w', lambda *a: recompute_outdoor_props())
                sum_rh_var.trace('w', lambda *a: recompute_outdoor_props())
            except Exception:
                try:
                    win_db_var.trace_add('write', lambda *a: recompute_outdoor_props())
                    win_rh_var.trace_add('write', lambda *a: recompute_outdoor_props())
                    sum_db_var.trace_add('write', lambda *a: recompute_outdoor_props())
                    sum_rh_var.trace_add('write', lambda *a: recompute_outdoor_props())
                except Exception:
                    pass
            # compute once on open if defaults present; schedule after dialog appears
            try:
                # initial recompute chain after dialog appears: outdoor props, return air, mixed props, LAT
                def _initial_recompute():
                    try:
                        recompute_outdoor_props()
                    except Exception:
                        pass
                    try:
                        update_return_air()
                    except Exception:
                        pass
                    try:
                        update_mixed_props()
                    except Exception:
                        pass
                    try:
                        recompute_lat()
                    except Exception:
                        pass
                    # compute initial absolute humidity values for indoor conditions
                    try:
                        update_indoor_abs()
                    except Exception:
                        pass
                    try:
                        update_indoor_w_abs()
                    except Exception:
                        pass
                    try:
                        compute_humid_capacity()
                    except Exception:
                        pass
                    # draw psychrometric chart after all computations
                    try:
                        draw_psychrometric()
                    except Exception:
                        pass

                dlg.after(50, _initial_recompute)
            except Exception:
                try:
                    recompute_outdoor_props()
                except Exception:
                    pass
                try:
                    update_return_air()
                except Exception:
                    pass
                try:
                    update_mixed_props()
                except Exception:
                    pass
                try:
                    recompute_lat()
                except Exception:
                    pass

            # realtime bindings: when supply/outdoor change, update return/mixed/coils
            try:
                margin_flow_var.trace('w', lambda *a: (update_return_air(), update_mixed_props(), recompute_lat()))
                outdoor_var.trace('w', lambda *a: (update_return_air(), update_mixed_props(), recompute_lat()))
            except Exception:
                try:
                    margin_flow_var.trace_add('write', lambda *a: (update_return_air(), update_mixed_props(), recompute_lat()))
                    outdoor_var.trace_add('write', lambda *a: (update_return_air(), update_mixed_props(), recompute_lat()))
                except Exception:
                    pass

            def update_mixed_props():
                try:
                    # parse required values
                    supply = to_float(margin_flow_var.get())
                    # supply may be a formatted string like '1,200'
                    if supply is None:
                        supply = (stored_margin_flow if 'stored_margin_flow' in locals() else None)
                    if supply is None or supply == 0:
                        mix_temp_var.set('')
                        mix_ent_var.set('')
                        return
                    # outdoor volume: if percent provided, compute from supply; else numeric
                    outdoor_raw = (outdoor_var.get() or '').strip() if 'outdoor_var' in locals() else ''
                    outdoor_m3 = None
                    if outdoor_raw:
                        if '%' in outdoor_raw:
                            pnum = to_float(outdoor_raw.replace('%','').strip())
                            if pnum is not None:
                                outdoor_m3 = float(supply) * (float(pnum) / 100.0)
                        else:
                            outdoor_m3 = to_float(outdoor_raw.replace(',',''))
                    # if outdoor_m3 not given, try stored outdoor
                    if outdoor_m3 is None:
                        outdoor_m3 = self.ahu_capacity.get('outdoor_m3_hr') if hasattr(self,'ahu_capacity') else None
                    # return air numeric
                    ret_raw = return_flow_var.get() if return_flow_var.get() else None
                    return_m3 = None
                    if ret_raw:
                        return_m3 = to_float(str(ret_raw).replace(',',''))
                    elif 'return_flow_var' in locals():
                        return_m3 = None
                    # if we still lack outdoor or return, attempt compute: return = supply - outdoor
                    if outdoor_m3 is not None and (return_m3 is None):
                        return_m3 = float(supply) - float(outdoor_m3)
                    if outdoor_m3 is None or return_m3 is None:
                        mix_temp_var.set('')
                        mix_ent_var.set('')
                        return
                    # parse temps
                    summer_db = to_float(sum_db_var.get())
                    indoor_t = to_float(indoor_t_var.get())
                    if summer_db is None or indoor_t is None:
                        mix_temp_var.set('')
                        mix_ent_var.set('')
                        return
                    # mixed temperature formula: (outdoor*summer_db + return*indoor_t) / supply
                    try:
                        mixed_T = (float(outdoor_m3) * float(summer_db) + float(return_m3) * float(indoor_t)) / float(supply)
                        mix_temp_var.set(f"{mixed_T:.2f}")
                    except Exception:
                        mix_temp_var.set('')
                    # mixed enthalpy: mass-weighted enthalpy per kg dry air (assume same basis)
                    try:
                        # compute outdoor enthalpy (use summer_db and outdoor RH input)
                        out_rh = None
                        if '%' in (sum_rh_var.get() or ''):
                            out_rh = to_float(sum_rh_var.get().replace('%',''))
                        else:
                            out_rh = to_float(sum_rh_var.get())
                        if out_rh is None:
                            mix_ent_var.set('')
                            return
                        # compute outdoor w and h (kcal/kg)
                        w_out = humidity_ratio(float(summer_db), float(out_rh)/100.0)
                        h_out_kj = enthalpy_kJ_per_kg_dry(float(summer_db), w_out)
                        h_out_kcal = h_out_kj * 0.2388458966 if h_out_kj is not None else None
                        # compute return air enthalpy using indoor conditions
                        w_ret = humidity_ratio(float(indoor_t_var.get()), float(indoor_rh_var.get())/100.0)
                        h_ret_kj = enthalpy_kJ_per_kg_dry(float(indoor_t_var.get()), w_ret)
                        h_ret_kcal = h_ret_kj * 0.2388458966 if h_ret_kj is not None else None
                        if h_out_kcal is None or h_ret_kcal is None:
                            mix_ent_var.set('')
                            return
                        # mass-weighted average enthalpy (assuming volumetric flows proportional to mass flows)
                        mixed_h = (float(outdoor_m3) * float(h_out_kcal) + float(return_m3) * float(h_ret_kcal)) / float(supply)
                        mix_ent_var.set(f"{mixed_h:.3f}")
                        # compute chilled water coil capacity = 1.2 * supply * (mixed_ent - coil_ent)
                        try:
                            # supply (m3/hr)
                            supply_num = float(supply)
                            # mixed enthalpy (kcal/kg)
                            mixed_ent_val = float(mixed_h)
                            # coil exit enthalpy (kcal/kg) from coil_ent_var
                            coil_ent_val = None
                            try:
                                coil_ent_val = float(coil_ent_var.get()) if coil_ent_var.get() else None
                            except Exception:
                                coil_ent_val = None
                            if coil_ent_val is None:
                                coil_cap_var.set('')
                            else:
                                cap = 1.2 * supply_num * (mixed_ent_val - float(coil_ent_val))
                                # ensure non-negative
                                cap = max(0.0, cap)
                                # apply 10% margin (1.1x)
                                cap = cap * 1.1
                                # floor to nearest 1000 (내림천단위)
                                cap = math.floor(cap / 1000.0) * 1000.0
                                if cap <= 0:
                                    coil_cap_var.set('0')
                                else:
                                    coil_cap_var.set(f"{int(cap):,}")
                                # compute coil-through temperature from indoor heat load:
                                # coil_T = indoor_temp + (indoor_heat_load / 1.2 / 0.24 / supply)
                                try:
                                    # use 동절기 건구온도 for coil-through calculation
                                    indoor_temp = to_float(indoor_w_t_var.get())
                                    indoor_heat_load = to_float(indoor_heat_load_var.get())
                                    supply_val = float(supply)
                                    coil_T = None
                                    if indoor_temp is None or indoor_heat_load is None or supply_val == 0:
                                        coil_T = None
                                    else:
                                        coil_T = float(indoor_temp) + (float(indoor_heat_load) / 1.2 / 0.24 / float(supply_val))
                                except Exception:
                                    coil_T = None

                                # compute mixed winter temp (weighted) and heating coil capacity
                                try:
                                    winter_db = to_float(win_db_var.get())
                                    if winter_db is None or coil_T is None:
                                        heat_cap_var.set('')
                                    else:
                                        try:
                                            # mixed winter temp uses 동절기 indoor temp (indoor_w_t_var)
                                            mixed_winter_T = (float(outdoor_m3) * float(winter_db) + float(return_m3) * float(to_float(indoor_w_t_var.get()) if to_float(indoor_w_t_var.get()) is not None else 0.0)) / float(supply)
                                        except Exception:
                                            mixed_winter_T = None
                                        if mixed_winter_T is None:
                                            heat_cap_var.set('')
                                        else:
                                            heat_cap = 1.2 * 0.24 * float(supply) * (float(coil_T) - float(mixed_winter_T)) * 1.1
                                            heat_cap = max(0.0, heat_cap)
                                            heat_cap = math.floor(heat_cap / 1000.0) * 1000.0
                                            if heat_cap <= 0:
                                                heat_cap_var.set('0')
                                            else:
                                                heat_cap_var.set(f"{int(heat_cap):,}")
                                except Exception:
                                    heat_cap_var.set('')
                        except Exception:
                            coil_cap_var.set('')
                    except Exception:
                        mix_ent_var.set('')
                except Exception:
                    mix_temp_var.set('')
                    mix_ent_var.set('')

            def on_manual_toggle(*a):
                manual = bool(manual_frac_var.get())
                # enable or disable fraction entry
                try:
                    if manual:
                        ent_frac.configure(state='normal')
                    else:
                        ent_frac.configure(state='disabled')
                except Exception:
                    try:
                        if manual:
                            ent_frac.configure(state='normal')
                        else:
                            ent_frac.configure(state='readonly')
                    except Exception:
                        pass
                # When manual mode, sensible input stays enabled, latent is calculated
                # When auto mode, both sensible and latent inputs are enabled
                if manual:
                    # In manual SHR mode: enable sensible, disable latent (will be calculated)
                    try:
                        ent_sens.configure(state='normal')
                        ent_lat.configure(state='disabled')
                    except Exception:
                        pass
                    # Trigger calculation if SHR already has a value
                    try:
                        on_frac_change()
                    except Exception:
                        pass
                else:
                    # In auto mode: enable both sensible and latent
                    try:
                        ent_sens.configure(state='normal')
                        ent_lat.configure(state='normal')
                    except Exception:
                        pass
                # Update LAT calculation
                try:
                    recompute_lat()
                except Exception:
                    pass

            def on_frac_change(*a):
                if not manual_frac_var.get():
                    return
                f = to_float(sens_frac_var.get())
                if f is not None:
                    # When SHR is manually entered, calculate latent load from sensible and SHR
                    # Formula: SHR = Sensible / (Sensible + Latent)
                    # Therefore: Latent = Sensible * (1 - SHR) / SHR (when SHR != 0)
                    # If SHR = 1, then Latent = 0
                    try:
                        sens_val = to_float(total_sens_var.get())
                        if sens_val is not None:
                            if abs(f - 1.0) < 1e-9:  # SHR = 1
                                total_lat_var.set('0')
                            elif f > 1e-9:  # SHR > 0 and != 1
                                lat_calc = sens_val * (1.0 - f) / f
                                # Format with comma separator
                                total_lat_var.set(f"{int(round(lat_calc)):,}")
                            else:  # SHR = 0 or negative
                                total_lat_var.set('')
                    except Exception:
                        pass
                    
                    # Disable latent input when manual SHR is active
                    try:
                        ent_lat.configure(state='disabled')
                    except Exception:
                        pass
                else:
                    # No valid SHR: enable latent input
                    try:
                        ent_lat.configure(state='normal')
                    except Exception:
                        pass
                # ensure LAT updates when fraction changes
                try:
                    recompute_lat()
                except Exception:
                    pass

            # traces
            try:
                total_sens_var.trace('w', lambda *a: recompute_frac())
                total_lat_var.trace('w', lambda *a: recompute_frac())
                manual_frac_var.trace('w', lambda *a: on_manual_toggle())
                sens_frac_var.trace('w', lambda *a: on_frac_change())
                # When sensible load changes in manual SHR mode, recalculate latent
                total_sens_var.trace('w', lambda *a: on_frac_change() if manual_frac_var.get() else None)
                # also update LAT when temperature/RH fields change
                try:
                    indoor_t_var.trace('w', lambda *a: recompute_lat())
                    indoor_rh_var.trace('w', lambda *a: recompute_lat())
                    coil_rh_var.trace('w', lambda *a: recompute_lat())
                except Exception:
                    pass
            except Exception:
                try:
                    total_sens_var.trace_add('write', lambda *a: recompute_frac())
                    total_lat_var.trace_add('write', lambda *a: recompute_frac())
                    manual_frac_var.trace_add('write', lambda *a: on_manual_toggle())
                    sens_frac_var.trace_add('write', lambda *a: on_frac_change())
                    # When sensible load changes in manual SHR mode, recalculate latent
                    total_sens_var.trace_add('write', lambda *a: on_frac_change() if manual_frac_var.get() else None)
                    # update LAT when temperature/RH/fraction change
                    try:
                        indoor_t_var.trace_add('write', lambda *a: recompute_lat())
                        indoor_rh_var.trace_add('write', lambda *a: recompute_lat())
                        coil_rh_var.trace_add('write', lambda *a: recompute_lat())
                    except Exception:
                        try:
                            indoor_t_var.trace('w', lambda *a: recompute_lat())
                            indoor_rh_var.trace('w', lambda *a: recompute_lat())
                            coil_rh_var.trace('w', lambda *a: recompute_lat())
                        except Exception:
                            pass
                except Exception:
                    pass

            # local psychrometric helpers and LAT solver
            def p_ws_pa(T_C):
                # Buck (1981) equation for saturation vapor pressure over water (hPa), then to Pa
                # T_C expected in deg C
                try:
                    es_hpa = 6.1121 * math.exp((18.678 - T_C / 234.5) * (T_C / (257.14 + T_C)))
                    return es_hpa * 100.0
                except Exception:
                    return 0.0

            def humidity_ratio(T_C, RH_frac, p_pa=101325.0):
                # epsilon: ratio of molecular weights (water/vapor)
                eps = 0.621945
                try:
                    pv = RH_frac * p_ws_pa(T_C)
                    if pv >= p_pa:
                        return None
                    return eps * pv / (p_pa - pv)
                except Exception:
                    return None

            def enthalpy_kJ_per_kg_dry(T_C, w):
                # Enthalpy using constant latent heat (A안): L = 2501.0 kJ/kg
                cp_air = 1.005  # kJ/kg.K
                cp_v = 1.86     # kJ/kg.K
                L = 2501.0
                return cp_air * T_C + w * (L + cp_v * T_C)

            def compute_LAT_local(T1_C, RH1_pct, SHR, RH_target_pct, p_pa=101325.0, tol=1e-7):
                # Use bisection on T2 with improved thermodynamics
                try:
                    T1 = float(T1_C)
                    RHt = float(RH_target_pct) / 100.0
                except Exception:
                    return None
                w1 = humidity_ratio(T1, float(RH1_pct) / 100.0, p_pa)
                if w1 is None:
                    return None
                h1 = enthalpy_kJ_per_kg_dry(T1, w1)

                cp_air = 1.005

                def f(T2):
                    pv2 = RHt * p_ws_pa(T2)
                    if pv2 >= p_pa:
                        return 1.0
                    w2 = humidity_ratio(T2, RHt, p_pa)
                    if w2 is None:
                        return 1.0
                    h2 = enthalpy_kJ_per_kg_dry(T2, w2)
                    denom = (h1 - h2)
                    if denom <= 1e-12:
                        return 1.0
                    SHR_calc = cp_air * (T1 - T2) / denom
                    return SHR_calc - SHR

                lo = -40.0
                hi = T1 - 1e-9
                try:
                    f_lo = f(lo)
                    f_hi = f(hi)
                except Exception:
                    return None
                if f_lo * f_hi > 0:
                    return None
                for _ in range(300):
                    mid = 0.5 * (lo + hi)
                    f_mid = f(mid)
                    if abs(f_mid) < tol:
                        return mid
                    if f_lo * f_mid <= 0:
                        hi = mid
                        f_hi = f_mid
                    else:
                        lo = mid
                        f_lo = f_mid
                return 0.5 * (lo + hi)

            # draw comprehensive psychrometric chart on the canvas (Tkinter-only implementation)
            def draw_psychrometric():
                try:
                    cvs = chart_canvas
                    cvs.delete('all')
                    cvs.update_idletasks()
                    w = cvs.winfo_width()
                    h = cvs.winfo_height()
                    if w <= 1 or h <= 1:
                        w, h = 700, 650
                    
                    # dark background similar to professional chart
                    cvs.create_rectangle(0, 0, w, h, fill='#1a1a1a', outline='')
                    
                    margin_l, margin_r, margin_t, margin_b = 50, 30, 30, 40
                    plot_w = w - margin_l - margin_r
                    plot_h = h - margin_t - margin_b
                    
                    # chart range: temp -15~40°C, abs humidity 0~50 g/kg
                    xmin, xmax = -15.0, 40.0
                    ymin, ymax = 0.0, 40.0
                    
                    def xpix(T):
                        return margin_l + (T - xmin) / (xmax - xmin) * plot_w
                    def ypix(gpk):
                        return margin_t + (ymax - gpk) / (ymax - ymin) * plot_h
                    
                    # title
                    cvs.create_text(w/2, 15, text='습공기 선도', font=('Arial', 11, 'bold'), fill='white')
                    
                    # grid: vertical temperature lines (every 5°C)
                    for T in range(-15, 41, 5):
                        x = xpix(T)
                        cvs.create_line(x, margin_t, x, margin_t + plot_h, fill='#444444', width=1)
                        cvs.create_text(x, margin_t + plot_h + 10, text=str(T), fill='white', font=('Arial', 8))
                    cvs.create_text(margin_l + plot_w/2, h - 10, text='건구온도 (℃)', fill='white', font=('Arial', 9))
                    
                    # horizontal abs humidity lines (every 5 g/kg)
                    for gpk in range(0, 41, 5):
                        y = ypix(gpk)
                        cvs.create_line(margin_l, y, margin_l + plot_w, y, fill='#444444', width=1)
                        cvs.create_text(margin_l - 10, y, text=str(gpk), fill='white', font=('Arial', 8), anchor='e')
                    cvs.create_text(20, margin_t + plot_h/2, text='절대습도 (g/kg)', fill='white', font=('Arial', 9), angle=90)
                    
                    # saturation curve (100% RH) - bold
                    pts = []
                    T = xmin
                    while T <= xmax:
                        try:
                            w_sat = humidity_ratio(T, 1.0)
                            if w_sat is not None and w_sat * 1000.0 <= ymax:
                                pts.append((xpix(T), ypix(w_sat * 1000.0)))
                        except:
                            pass
                        T += 0.5
                    for i in range(len(pts) - 1):
                        cvs.create_line(pts[i][0], pts[i][1], pts[i+1][0], pts[i+1][1], fill='#00aaff', width=2)
                    
                    # RH curves (10%, 20%, ..., 90%)
                    for RH in [10, 20, 30, 40, 50, 60, 70, 80, 90]:
                        pts = []
                        T = xmin
                        while T <= xmax:
                            try:
                                w_rh = humidity_ratio(T, RH / 100.0)
                                if w_rh is not None and w_rh * 1000.0 <= ymax:
                                    pts.append((xpix(T), ypix(w_rh * 1000.0)))
                            except:
                                pass
                            T += 1.0
                        for i in range(len(pts) - 1):
                            cvs.create_line(pts[i][0], pts[i][1], pts[i+1][0], pts[i+1][1], fill='#666666', width=1)
                        # label RH curve
                        if len(pts) > len(pts)//2:
                            try:
                                mid = pts[len(pts)//2]
                                cvs.create_text(mid[0], mid[1]-8, text=f'{RH}%', fill='#aaaaaa', font=('Arial', 7))
                            except:
                                pass
                    
                    # enthalpy lines (diagonal lines) - approximate constant enthalpy as diagonal from top-left to bottom-right
                    # enthalpy h = cp*T + w*(L + cpv*T); for simplicity draw lines of constant h in kJ/kg
                    for h_kj in range(10, 100, 10):
                        pts = []
                        # solve for points: given h_kj, find (T, w) pairs
                        for T in range(-15, 41, 2):
                            try:
                                # h_kj = 1.005*T + w*(2501 + 1.86*T)
                                # solve for w: w = (h_kj - 1.005*T) / (2501 + 1.86*T)
                                denom = 2501.0 + 1.86 * T
                                if denom != 0:
                                    w_kg = (h_kj - 1.005 * T) / denom
                                    if w_kg >= 0 and w_kg * 1000.0 <= ymax:
                                        pts.append((xpix(T), ypix(w_kg * 1000.0)))
                            except:
                                pass
                        for i in range(len(pts) - 1):
                            cvs.create_line(pts[i][0], pts[i][1], pts[i+1][0], pts[i+1][1], fill='#555555', width=1, dash=(2, 2))
                    
                    # plot calculated points
                    def plot_point(T, gpk, label, color='red', size=5, rh=None):
                        try:
                            if T < xmin or T > xmax or gpk < ymin or gpk > ymax:
                                return
                            x, y = xpix(T), ypix(gpk)
                            cvs.create_oval(x-size, y-size, x+size, y+size, fill=color, outline='white', width=1)
                            cvs.create_text(x+15, y-10, text=label, fill=color, font=('Arial', 8, 'bold'), anchor='w')
                            # add temperature, RH, and absolute humidity info below the label
                            info_lines = []
                            info_lines.append(f'DB: {T:.1f}℃')
                            if rh is not None:
                                info_lines.append(f'RH: {rh:.0f}%')
                            info_lines.append(f'AH: {gpk:.1f}g/kg')
                            for i, line in enumerate(info_lines):
                                cvs.create_text(x+15, y+2+i*10, text=line, fill=color, font=('Arial', 7), anchor='w')
                        except:
                            pass
                    
                    # winter outdoor
                    try:
                        t_w = to_float(win_db_var.get())
                        w_w_g = to_float(win_abs_var.get())
                        rh_w = to_float(win_rh_var.get())
                        if t_w is not None and w_w_g is not None:
                            plot_point(float(t_w), float(w_w_g), '외기(동)', color='#00ccff', rh=rh_w)
                    except:
                        pass
                    
                    # summer outdoor
                    try:
                        t_s = to_float(sum_db_var.get())
                        w_s_g = to_float(sum_abs_var.get())
                        rh_s = to_float(sum_rh_var.get())
                        if t_s is not None and w_s_g is not None:
                            plot_point(float(t_s), float(w_s_g), '외기(하)', color='#ff6600', rh=rh_s)
                    except:
                        pass
                    # draw line from summer outdoor to summer indoor and plot mixed point
                    try:
                        # retrieve summer indoor and outdoor values
                        it = to_float(indoor_t_var.get())
                        iw = to_float(indoor_abs_var.get())
                        t_s = to_float(sum_db_var.get())
                        w_s_g = to_float(sum_abs_var.get())
                        if it is not None and iw is None:
                            # compute iw from indoor RH if necessary
                            irh = to_float(indoor_rh_var.get())
                            if irh is not None:
                                wtmp = humidity_ratio(float(it), float(irh) / 100.0)
                                if wtmp is not None:
                                    iw = wtmp * 1000.0
                        if it is not None and iw is not None and t_s is not None and w_s_g is not None:
                            # draw connecting line (summer outdoor -> summer indoor)
                            try:
                                x1, y1 = xpix(float(t_s)), ypix(float(w_s_g))
                                x2, y2 = xpix(float(it)), ypix(float(iw))
                                cvs.create_line(x1, y1, x2, y2, fill='#88ccff', width=2)
                            except Exception:
                                pass
                            # compute and plot mixed point using same logic as update_mixed_props
                            try:
                                # parse supply/outdoor/return volumes
                                supply = to_float(margin_flow_var.get())
                                if supply is None:
                                    supply = (stored_margin_flow if 'stored_margin_flow' in locals() else None)
                                outdoor_raw = (outdoor_var.get() or '').strip()
                                outdoor_m3 = None
                                if outdoor_raw:
                                    if '%' in outdoor_raw:
                                        pnum = to_float(outdoor_raw.replace('%','').strip())
                                        if pnum is not None and supply is not None:
                                            outdoor_m3 = float(supply) * (float(pnum) / 100.0)
                                    else:
                                        outdoor_m3 = to_float(outdoor_raw.replace(',',''))
                                if outdoor_m3 is None:
                                    outdoor_m3 = self.ahu_capacity.get('outdoor_m3_hr') if hasattr(self,'ahu_capacity') else None
                                return_m3 = None
                                try:
                                    ret_raw = return_flow_var.get() if return_flow_var.get() else None
                                    if ret_raw:
                                        return_m3 = to_float(str(ret_raw).replace(',',''))
                                except Exception:
                                    return_m3 = None
                                if outdoor_m3 is not None and return_m3 is None and supply is not None:
                                    return_m3 = float(supply) - float(outdoor_m3)
                                if outdoor_m3 is not None and return_m3 is not None and supply is not None and supply != 0:
                                    # compute outdoor and return absolute humidity in g/kg
                                    try:
                                        out_rh = to_float(sum_rh_var.get())
                                        if out_rh is None:
                                            out_rh = to_float(sum_rh_var.get().replace('%',''))
                                    except Exception:
                                        out_rh = None
                                    w_out = humidity_ratio(float(t_s), float(out_rh)/100.0) if out_rh is not None else None
                                    w_ret = humidity_ratio(float(indoor_t_var.get()), float(indoor_rh_var.get())/100.0) if (indoor_t_var.get() and indoor_rh_var.get()) else None
                                    if w_out is not None and w_ret is not None:
                                        # convert to g/kg
                                        w_out_g = w_out * 1000.0
                                        w_ret_g = w_ret * 1000.0
                                        mixed_w_g = (float(outdoor_m3) * float(w_out_g) + float(return_m3) * float(w_ret_g)) / float(supply)
                                        mixed_T = (float(outdoor_m3) * float(t_s) + float(return_m3) * float(it)) / float(supply)
                                        # compute RH at mixed point
                                        mixed_rh = None
                                        try:
                                            w_kg = mixed_w_g / 1000.0
                                            w_sat = humidity_ratio(mixed_T, 1.0)
                                            if w_sat is not None and w_sat > 0:
                                                mixed_rh = (w_kg / w_sat) * 100.0
                                        except Exception:
                                            pass
                                        # plot mixed point
                                        try:
                                            plot_point(float(mixed_T), float(mixed_w_g), '혼합', color='#ffff88', size=4, rh=mixed_rh)
                                            x_m = xpix(float(mixed_T))
                                            y_m = ypix(float(mixed_w_g))
                                        except Exception:
                                            pass
                                        # Draw horizontal line from mixed point to coil-exit RH curve (coil_rh_var),
                                        # then follow that RH curve to the LAT temperature point. Use sky-blue color.
                                        try:
                                            crh_val = to_float(coil_rh_var.get())
                                            lat_t = to_float(lat_var.get())
                                            if crh_val is not None and x_m is not None and y_m is not None:
                                                # find T on the coil-RH curve where absolute humidity ~= mixed_w_g
                                                best_T = None
                                                best_diff = None
                                                step_search = 0.2
                                                T = xmin
                                                while T <= xmax:
                                                    try:
                                                        w_rh = humidity_ratio(T, float(crh_val) / 100.0)
                                                        if w_rh is not None:
                                                            w_rh_g = w_rh * 1000.0
                                                            diff = abs(w_rh_g - float(mixed_w_g))
                                                            if best_diff is None or diff < best_diff:
                                                                best_diff = diff
                                                                best_T = T
                                                    except Exception:
                                                        pass
                                                    T += step_search
                                                if best_T is not None:
                                                    x_int = xpix(best_T)
                                                    # horizontal line to RH curve intersection
                                                    try:
                                                        cvs.create_line(x_m, y_m, x_int, y_m, fill='#87CEEB', width=2)
                                                    except Exception:
                                                        pass
                                                    # follow RH curve from intersection to LAT temperature (if LAT available)
                                                    try:
                                                        # build RH points for coil_rh from best_T towards lat_t
                                                        pts_rh = []
                                                        if lat_t is None:
                                                            # if LAT unknown, just draw a short segment along RH curve (to the right)
                                                            Tstart = best_T
                                                            Tend = min(xmax, best_T + 5.0)
                                                        else:
                                                            Tstart = best_T
                                                            Tend = float(lat_t)
                                                        # choose direction and step
                                                        if Tend >= Tstart:
                                                            T = Tstart
                                                            step_dir = abs(step_search)
                                                            cond = lambda a, b: a <= b + 1e-9
                                                        else:
                                                            T = Tstart
                                                            step_dir = -abs(step_search)
                                                            cond = lambda a, b: a >= b - 1e-9
                                                        # sample points along RH curve
                                                        while cond(T, Tend):
                                                            try:
                                                                w_rh = humidity_ratio(T, float(crh_val) / 100.0)
                                                                if w_rh is not None:
                                                                    w_rh_g = w_rh * 1000.0
                                                                    if w_rh_g >= ymin and w_rh_g <= ymax:
                                                                        pts_rh.append((xpix(T), ypix(w_rh_g)))
                                                            except Exception:
                                                                pass
                                                            T += step_dir
                                                        # if LAT provided, ensure the LAT point on RH curve included (compute exact w at LAT)
                                                        if lat_t is not None:
                                                            try:
                                                                w_at_lat = humidity_ratio(float(lat_t), float(crh_val) / 100.0)
                                                                if w_at_lat is not None:
                                                                    w_at_lat_g = w_at_lat * 1000.0
                                                                    pts_rh.append((xpix(float(lat_t)), ypix(w_at_lat_g)))
                                                            except Exception:
                                                                pass
                                                        # draw the RH-curve-following line
                                                        if len(pts_rh) >= 2:
                                                            for ii in range(len(pts_rh)-1):
                                                                try:
                                                                    cvs.create_line(pts_rh[ii][0], pts_rh[ii][1], pts_rh[ii+1][0], pts_rh[ii+1][1], fill='#87CEEB', width=2)
                                                                except Exception:
                                                                    pass
                                                    except Exception:
                                                        pass
                                        except Exception:
                                            pass
                            except Exception:
                                pass
                    except Exception:
                        pass
                    
                    # indoor (summer)
                    try:
                        it = to_float(indoor_t_var.get())
                        irh = to_float(indoor_rh_var.get())
                        iw = to_float(indoor_abs_var.get())
                        # compute iw from RH if missing
                        try:
                            if (iw is None) and (it is not None) and (irh is not None):
                                w = humidity_ratio(float(it), float(irh) / 100.0)
                                if w is not None:
                                    iw = w * 1000.0
                        except Exception:
                            pass

                        if it is not None and iw is not None:
                            plot_point(float(it), float(iw), '실내(하)', color='#00ff00', rh=irh)
                            # Draw SHF (현열비) line at the summer indoor point if sens_frac available
                            try:
                                f = to_float(sens_frac_var.get())
                                if f is None:
                                    # try to compute from totals if available
                                    try:
                                        s_num = to_float(total_sens_var.get())
                                        l_num = to_float(total_lat_var.get())
                                        if s_num is not None and l_num is not None and (s_num + l_num) != 0:
                                            f = float(s_num) / float(s_num + l_num)
                                    except Exception:
                                        f = None
                                if f is not None:
                                    try:
                                        ff = float(f)
                                    except Exception:
                                        ff = None
                                    # Build SHF line starting at summer indoor point (it, iw)
                                    step = 0.5
                                    pts_left = []
                                    try:
                                        # extend to the left (decreasing temperature) from indoor temperature until saturation reached
                                        Tcur = float(it) - step
                                        Tmin = float(xmin)
                                        while Tcur >= Tmin:
                                            w_line = float(iw)
                                            if ff is not None and ff > 0 and ff < 1:
                                                cp = 1.005
                                                L = 2501.0
                                                slope = 1000.0 * cp * (1.0 - ff) / (ff * L)
                                                w_line = float(iw) + slope * (Tcur - float(it))
                                            try:
                                                w_sat = humidity_ratio(Tcur, 1.0)
                                                w_sat_g = None if w_sat is None else (w_sat * 1000.0)
                                            except Exception:
                                                w_sat_g = None
                                            # include point only if below or equal to saturation and within y range
                                            if w_sat_g is not None and w_line <= w_sat_g and w_line >= ymin and w_line <= ymax:
                                                pts_left.append((xpix(Tcur), ypix(w_line)))
                                                Tcur -= step
                                            else:
                                                break
                                    except Exception:
                                        pts_left = []
                                    # build sequence from indoor point to leftmost point
                                    pts_combined = [(xpix(float(it)), ypix(float(iw)))] + pts_left
                                    # draw if at least two distinct points exist
                                    if len(pts_combined) >= 2:
                                        for ii in range(len(pts_combined) - 1):
                                            try:
                                                cvs.create_line(pts_combined[ii][0], pts_combined[ii][1], pts_combined[ii+1][0], pts_combined[ii+1][1], fill='#88ff88', width=2, dash=(4,2))
                                            except Exception:
                                                pass
                            except Exception:
                                pass
                    except:
                        pass
                    
                    # indoor (winter)
                    try:
                        iwt = to_float(indoor_w_t_var.get())
                        iww = to_float(indoor_w_abs_var.get())
                        iwrh = to_float(indoor_w_rh_var.get())
                        if iwt is not None and iww is not None:
                            plot_point(float(iwt), float(iww), '실내(동)', color='#ffff00', rh=iwrh)
                    except:
                        pass
                    
                    # LAT point
                    try:
                        lat = to_float(lat_var.get())
                        crh = to_float(coil_rh_var.get())
                        if lat is not None and crh is not None:
                            w_coil = humidity_ratio(lat, float(crh) / 100.0)
                            if w_coil is not None:
                                plot_point(float(lat), w_coil * 1000.0, 'LAT', color='#ff00ff', rh=crh)
                    except:
                        pass
                    
                    # LAT(동) point and lines
                    try:
                        # compute LAT(동) temperature: indoor_winter_temp + (indoor_heat_load / 1.2 / 0.24 / supply_flow)
                        iwt = to_float(indoor_w_t_var.get())
                        heat_load = to_float(indoor_heat_load_var.get())
                        supply = to_float(margin_flow_var.get())
                        if supply is None:
                            supply = to_float(flow_var.get())
                        winter_out_abs = to_float(win_abs_var.get())
                        winter_out_temp = to_float(win_db_var.get())
                        
                        if iwt is not None and heat_load is not None and supply is not None and supply != 0 and winter_out_abs is not None and winter_out_temp is not None:
                            # LAT(동) temperature
                            lat_winter_temp = float(iwt) + (float(heat_load) / 1.2 / 0.24 / float(supply))
                            # LAT(동) absolute humidity = winter outdoor absolute humidity
                            lat_winter_abs = float(winter_out_abs)
                            # compute RH at LAT(동) point
                            lat_winter_rh = None
                            try:
                                w_kg = lat_winter_abs / 1000.0
                                w_sat = humidity_ratio(lat_winter_temp, 1.0)
                                if w_sat is not None and w_sat > 0:
                                    lat_winter_rh = (w_kg / w_sat) * 100.0
                            except Exception:
                                pass
                            
                            # plot LAT(동) point
                            plot_point(lat_winter_temp, lat_winter_abs, 'LAT(동)', color='#ff0000', rh=lat_winter_rh)
                            
                            # draw red line from winter outdoor to LAT(동) (horizontal line)
                            try:
                                x1 = xpix(float(winter_out_temp))
                                y1 = ypix(float(winter_out_abs))
                                x2 = xpix(lat_winter_temp)
                                y2 = ypix(lat_winter_abs)
                                cvs.create_line(x1, y1, x2, y2, fill='#ff0000', width=2)
                            except Exception:
                                pass
                            
                            # draw red line from LAT(동) to indoor(winter)
                            try:
                                iww = to_float(indoor_w_abs_var.get())
                                if iww is not None:
                                    x3 = xpix(lat_winter_temp)
                                    y3 = ypix(lat_winter_abs)
                                    x4 = xpix(float(iwt))
                                    y4 = ypix(float(iww))
                                    cvs.create_line(x3, y3, x4, y4, fill='#ff0000', width=2)
                            except Exception:
                                pass
                    except Exception:
                        pass
                except Exception:
                    pass

            def recompute_lat(*a):
                try:
                    it = to_float(indoor_t_var.get())
                    irh = to_float(indoor_rh_var.get())
                    crh = to_float(coil_rh_var.get())
                    f = to_float(sens_frac_var.get())
                    if it is None or irh is None or crh is None or f is None:
                        lat_var.set('')
                        delta_var.set('')
                        return
                    lat = compute_LAT_local(it, irh, float(f), crh)
                    if lat is None:
                        lat_var.set('')
                        delta_var.set('')
                        return
                    lat_var.set(f"{lat:.3f}")
                    # compute coil-exit enthalpy at LAT using coil_rh_var
                    try:
                        crh_val = to_float(coil_rh_var.get())
                        if crh_val is None:
                            coil_ent_var.set('')
                        else:
                            w_coil = humidity_ratio(lat, float(crh_val) / 100.0)
                            if w_coil is None:
                                coil_ent_var.set('')
                            else:
                                h_coil_kcal = enthalpy_kcal_per_kg(lat, w_coil)
                                if h_coil_kcal is None:
                                    coil_ent_var.set('')
                                else:
                                    coil_ent_var.set(f"{h_coil_kcal:.3f}")
                    except Exception:
                        coil_ent_var.set('')
                    # compute delta = indoor_temp - LAT
                    try:
                        if it is not None:
                            delta = it - float(lat)
                            # truncate from second decimal place (keep 1 decimal, no rounding)
                            trunc = int(delta * 10) / 10.0
                            delta_var.set(f"{trunc:.1f}")
                        else:
                            delta_var.set('')
                    except Exception:
                        delta_var.set('')
                    # compute AHU-design delta = trunc - 0.3, show truncated to 1 decimal
                    try:
                        if delta_var.get() and delta_var.get() != '':
                            try:
                                dnum = float(delta_var.get())
                                calc = dnum - 0.3
                                calc_trunc = int(calc * 10) / 10.0
                                calc_delta_var.set(f"{calc_trunc:.1f}")
                            except Exception:
                                calc_delta_var.set('')
                        else:
                            calc_delta_var.set('')
                    except Exception:
                        calc_delta_var.set('')
                    # compute AHU airflow if possible: total_sensible / 1.2 / 0.24 / delta
                    try:
                        s_val = to_float(total_sens_var.get())
                        if s_val is None or it is None or lat is None:
                            flow_var.set('')
                        else:
                            # use the truncated delta (in deg C)
                            if trunc == 0:
                                flow_var.set('')
                            else:
                                q = float(s_val) / 1.2 / 0.24 / trunc
                                # ceiling to nearest 100 (백의자리에서 올림)
                                q_ceil100 = int(math.ceil(q / 100.0) * 100)
                                flow_var.set(f"{q_ceil100:,}")
                    except Exception:
                        flow_var.set('')

                    # compute margin-adjusted airflow using AHU-design delta (calc_delta_var)
                    try:
                        s_val = to_float(total_sens_var.get())
                        if s_val is None or it is None or lat is None:
                            margin_flow_var.set('')
                        else:
                            # use calc_delta_var (design delta) if available
                            cd = to_float(calc_delta_var.get())
                            if cd is None or cd == 0:
                                margin_flow_var.set('')
                            else:
                                q_m = float(s_val) / 1.2 / 0.24 / float(cd)
                                q_m_ceil100 = int(math.ceil(q_m / 100.0) * 100)
                                margin_flow_var.set(f"{q_m_ceil100:,}")
                    except Exception:
                        margin_flow_var.set('')
                    try:
                        update_mixed_props()
                    except Exception:
                        pass
                    # redraw psychrometric chart after all updates
                    try:
                        draw_psychrometric()
                    except Exception:
                        pass
                except Exception:
                    lat_var.set('')
                    delta_var.set('')

            result = {'ok': False}

            def on_ok():
                # validate values
                s = to_float(total_sens_var.get())
                l = to_float(total_lat_var.get())
                f = to_float(sens_frac_var.get())
                it = to_float(indoor_t_var.get())
                irh = to_float(indoor_rh_var.get())
                crh = to_float(coil_rh_var.get())

                # when manual fraction mode and fraction provided, totals may be disabled
                if manual_frac_var.get():
                    if f is None:
                        messagebox.showerror('입력 오류', '현열비를 올바르게 입력하세요.')
                        return
                else:
                    # require sensible and latent to be provided
                    if s is None or l is None:
                        messagebox.showerror('입력 오류', '전체현열량/전체잠열량을 올바르게 입력하세요.')
                        return
                    denom = s + l
                    if denom == 0:
                        messagebox.showerror('입력 오류', '전체현열량+전체잠열량의 합이 0입니다.')
                        return
                    # ensure fraction computed
                    try:
                        f = float(s) / float(denom)
                    except Exception:
                        f = None

                # basic validation for temps/RH
                if it is None or irh is None or crh is None:
                    messagebox.showerror('입력 오류', '온도 및 상대습도 항목을 올바르게 입력하세요.')
                    return

                # store values
                # compute LAT to store (if available)
                try:
                    lat_val = None
                    fval = float(f) if f is not None else None
                    if it is not None and irh is not None and crh is not None and fval is not None:
                        lat_val = compute_LAT_local(it, irh, float(fval), crh)
                except Exception:
                    lat_val = None

                # compute stored flow values using numeric parsed values
                stored_flow = None
                stored_margin_flow = None
                try:
                    s_num = to_float(total_sens_var.get())
                    # prefer calc_delta_var for stored ahu_flow
                    cd_num = to_float(calc_delta_var.get())
                    dnum = to_float(delta_var.get())
                    if s_num is not None and cd_num is not None and cd_num != 0:
                        q_m = float(s_num) / 1.2 / 0.24 / float(cd_num)
                        stored_margin_flow = int(math.ceil(q_m / 100.0) * 100)
                    # legacy stored_flow based on truncated delta
                    if s_num is not None and dnum is not None and dnum != 0:
                        q = float(s_num) / 1.2 / 0.24 / float(dnum)
                        stored_flow = int(math.ceil(q / 100.0) * 100)
                except Exception:
                    stored_flow = None
                    stored_margin_flow = None

                self.ahu_capacity = {
                    'total_sensible_kcal_hr': s,
                    'total_latent_kcal_hr': l,
                    'sensible_fraction': f,
                    'indoor_temp_c': it,
                    'indoor_rh_pct': irh,
                    'coil_exit_rh_pct': crh,
                    'lat_c': lat_val,
                    'delta_t_c': (dnum if 'dnum' in locals() else None),
                    'design_delta_t_c': (cd_num if 'cd_num' in locals() else None),
                    'ahu_flow_m3_hr': stored_margin_flow if stored_margin_flow is not None else stored_flow,
                    'legacy_ahu_flow_m3_hr': stored_flow,
                    'manual_frac': bool(manual_frac_var.get()),
                    'outdoor_input_raw': (outdoor_var.get() if 'outdoor_var' in locals() else None),
                    'outdoor_m3_hr': None
                }
                # store outdoor condition inputs (winter/summer)
                try:
                    self.ahu_capacity['outdoor_winter_db_c'] = to_float(win_db_var.get()) if 'win_db_var' in locals() else None
                    self.ahu_capacity['outdoor_winter_rh_pct'] = to_float(win_rh_var.get()) if 'win_rh_var' in locals() else None
                    self.ahu_capacity['outdoor_summer_db_c'] = to_float(sum_db_var.get()) if 'sum_db_var' in locals() else None
                    self.ahu_capacity['outdoor_summer_rh_pct'] = to_float(sum_rh_var.get()) if 'sum_rh_var' in locals() else None
                except Exception:
                    # ignore storing outdoor conditions if any error
                    pass
                # compute stored outdoor value (numeric) if input present
                try:
                    if 'outdoor_var' in locals() and (outdoor_var.get() or '').strip() != '':
                        raw = outdoor_var.get().strip()
                        if '%' in raw:
                            pnum = to_float(raw.replace('%', '').strip())
                            base = (stored_margin_flow if stored_margin_flow is not None else stored_flow)
                            if pnum is not None and base is not None:
                                val = float(base) * (float(pnum) / 100.0)
                                val_ceil = int(math.ceil(val / 100.0) * 100)
                                self.ahu_capacity['outdoor_m3_hr'] = val_ceil
                        else:
                            vnum = to_float(raw)
                            if vnum is not None:
                                self.ahu_capacity['outdoor_m3_hr'] = int(round(vnum))
                except Exception:
                    self.ahu_capacity['outdoor_m3_hr'] = None
                # compute stored return air = supply - outdoor
                try:
                    supply_num = None
                    if 'margin_flow_var' in locals():
                        supply_num = to_float(margin_flow_var.get())
                    if supply_num is None:
                        supply_num = (stored_margin_flow if stored_margin_flow is not None else stored_flow)
                    out_num = self.ahu_capacity.get('outdoor_m3_hr')
                    if supply_num is not None and out_num is not None:
                        ret = float(supply_num) - float(out_num)
                        if ret <= 0:
                            self.ahu_capacity['return_air_m3_hr'] = 0
                        else:
                            self.ahu_capacity['return_air_m3_hr'] = int(math.ceil(ret / 100.0) * 100)
                    else:
                        self.ahu_capacity['return_air_m3_hr'] = None
                except Exception:
                    self.ahu_capacity['return_air_m3_hr'] = None
                result['ok'] = True
                try:
                    dlg.grab_release()
                except Exception:
                    pass
                dlg.destroy()

            def on_cancel():
                try:
                    dlg.grab_release()
                except Exception:
                    pass
                dlg.destroy()

            # 버튼은 이미 위에서 btnf 프레임으로 생성되어 pack됨
            try:
                dlg.lift()
            except Exception:
                pass
            okb = tk.Button(btnf, text='확인', command=on_ok, width=10)
            okb.pack(side=tk.LEFT, padx=6)
            cb = tk.Button(btnf, text='취소', command=on_cancel, width=10)
            cb.pack(side=tk.LEFT, padx=6)

            # center dialog and wait
            try:
                dlg.update_idletasks()
                w = dlg.winfo_width()
                h = dlg.winfo_height()
                x = (dlg.winfo_toplevel().winfo_screenwidth() - w) // 2
                y = (dlg.winfo_toplevel().winfo_screenheight() - h) // 2
                dlg.geometry(f'+{x}+{y}')
            except Exception:
                pass

            # ensure LAT initialized before showing dialog
            try:
                recompute_frac()
                recompute_lat()
            except Exception:
                pass
            self.root.wait_window(dlg)
            return bool(result.get('ok'))
        except Exception as e:
            try:
                messagebox.showerror('오류', f'공조기 용량 입력창 생성 중 오류: {e}')
            except Exception:
                pass
            return False

    def _refresh_diffuser_outlines(self, palette: 'Palette'):
        """Update outlines on the given palette: assigned -> red, otherwise clear unless selected (blue).

        This iterates over diffuser items known to the palette and sets outline color based
        on whether the item id is present in any hvac_map mapping. If the item is also in
        the palette.selected_points set, selected-but-unassigned items are shown as blue.
        """
        if palette is None:
            return
        try:
            # build a set of all assigned ids across hvac_map (for fast lookup)
            assigned_all = set()
            try:
                for m in getattr(self, 'hvac_map', {}).values():
                    try:
                        for iid in m.get('ids', set()) or set():
                            try:
                                assigned_all.add(int(iid))
                            except Exception:
                                assigned_all.add(iid)
                    except Exception:
                        continue
            except Exception:
                assigned_all = set()

            # iterate diffuser and main_point items tracked on palette
            try:
                candidates = list(palette.canvas.find_withtag('diffuser'))
                # Also include main_points in the candidate list
                try:
                    for mp in palette.canvas.find_withtag('main_point'):
                        if mp not in candidates:
                            candidates.append(mp)
                except Exception:
                    pass
            except Exception:
                candidates = list(palette.canvas.find_all())

            # persistent applied diffusers set
            try:
                applied_diffusers = set(getattr(self, '_supply_assigned', set()) or set())
            except Exception:
                applied_diffusers = set()

            # get active HVAC name to check if applied diffuser belongs to it
            try:
                active_hvac = getattr(self, '_active_hvac_name', None)
            except Exception:
                active_hvac = None

            # build map of which diffusers belong to which HVAC
            diffuser_to_hvac = {}
            try:
                for hvac_name, mapping in getattr(self, 'hvac_map', {}).items():
                    if not mapping or not isinstance(mapping, dict):
                        continue
                    try:
                        for did in mapping.get('ids', set()) or set():
                            try:
                                diffuser_to_hvac[int(did)] = hvac_name
                            except Exception:
                                diffuser_to_hvac[did] = hvac_name
                    except Exception:
                        continue
            except Exception:
                pass

            for iid in candidates:
                try:
                    # If item is applied (finalized), show yellow if it belongs to active HVAC, otherwise blue
                    if iid in applied_diffusers:
                        try:
                            belongs_to_active = (diffuser_to_hvac.get(iid) == active_hvac)
                            if belongs_to_active:
                                palette.canvas.itemconfigure(iid, outline='yellow', width=2)
                            else:
                                palette.canvas.itemconfigure(iid, outline='blue', width=2)
                        except Exception:
                            palette.canvas.itemconfigure(iid, outline='blue', width=2)
                        continue

                    if iid in assigned_all:
                        # assigned but not applied: yellow outline
                        try:
                            palette.canvas.itemconfigure(iid, outline='yellow', width=2)
                        except Exception:
                            pass
                    else:
                        # unassigned: if selected (temporary), red; else clear
                        try:
                            if getattr(palette, 'selected_points', None) and iid in getattr(palette, 'selected_points', set()):
                                palette.canvas.itemconfigure(iid, outline='red', width=2)
                            else:
                                palette.canvas.itemconfigure(iid, outline='')
                        except Exception:
                            pass
                except Exception:
                    continue
        except Exception:
            pass

    def _rename_duct_tab(self):
        """Rename the Duct tab at runtime using the entry value."""
        try:
            new_name = (self.duct_tab_name_entry.get() or "").strip()
            if not new_name:
                messagebox.showinfo("입력 필요", "새 탭 이름을 입력하세요.")
                return
            # enforce a reasonable max length
            max_len = 20
            if len(new_name) > max_len:
                new_name = new_name[:max_len]
                messagebox.showinfo("이름 잘림", f"탭 이름은 {max_len}자 이하로 잘립니다.")
            # find index of the duct tab and set its text
            idx = None
            try:
                idx = self.left_notebook.index(self.duct_tab)
            except Exception:
                # fallback: search by widget
                for i in range(self.left_notebook.index("end")):
                    if self.left_notebook.nametowidget(self.left_notebook.tabs()[i]) is self.duct_tab:
                        idx = i
                        break
            if idx is not None:
                self.left_notebook.tab(idx, text=new_name)
                # update entry to normalized name (in case trimming occurred)
                try:
                    self.duct_tab_name_entry.delete(0, tk.END)
                    self.duct_tab_name_entry.insert(0, new_name)
                except Exception:
                    pass
        except Exception as e:
            messagebox.showerror("오류", f"탭 이름 변경 중 오류: {e}")

    def _add_hvac(self):
        """Add new HVAC system from the entry into the listbox."""
        try:
            name = (self.hvac_new_entry.get() or "").strip()
            if not name:
                messagebox.showinfo("입력 필요", "추가할 시스템 이름을 입력하세요.")
                return
            # prevent duplicates
            existing = self.hvac_listbox.get(0, tk.END)
            if name in existing:
                messagebox.showinfo("중복", "이미 존재하는 시스템입니다.")
                return
            self.hvac_listbox.insert(tk.END, name)
            # auto-select the newly added item so it's active immediately
            try:
                last_idx = self.hvac_listbox.size() - 1
                self.hvac_listbox.selection_clear(0, tk.END)
                self.hvac_listbox.selection_set(last_idx)
                self._active_hvac_name = name
                # trigger selection handling to highlight/reset palette selection
                try:
                    self._on_hvac_select()
                except Exception:
                    pass
            except Exception:
                pass
            self.hvac_new_entry.delete(0, tk.END)
        except Exception as e:
            messagebox.showerror("오류", f"시스템 추가 중 오류: {e}")

    def _apply_hvac(self):
        """Apply the selected HVAC system (placeholder action)."""
        try:
            sel = self.hvac_listbox.curselection()
            if not sel:
                messagebox.showinfo("선택 필요", "적용할 시스템을 선택하세요.")
                return
            name = self.hvac_listbox.get(sel[0])
            # compute distinct diffuser "kinds" among currently selected diffusers
            rc = self.get_current_palette()
            sel_count = 0
            kinds = set()
            if rc is not None:
                    # normalize selected point ids to ints where possible so comparisons
                    # against stored hvac_map ids are robust
                    sel_points_raw = getattr(rc, 'selected_points', set()) or set()
                    sel_points_int = set()
                    for iid in sel_points_raw:
                        try:
                            sel_points_int.add(int(iid))
                        except Exception:
                            sel_points_int.add(iid)
                    sel_count = len(sel_points_int)
                    # compute kinds from the normalized ids
                    for iid in sel_points_int:
                        try:
                            tags = tuple(rc.canvas.gettags(iid))
                        except Exception:
                            tags = ()
                        kind = None
                        # explicit per-item type tag: 'diffuser_type:NAME'
                        for t in tags:
                            if isinstance(t, str) and t.startswith('diffuser_type:'):
                                kind = t.split(':', 1)[1]
                                break
                        # common tags: 'supply' / 'return'
                        if not kind:
                            if 'supply' in tags:
                                kind = 'supply'
                            elif 'return' in tags:
                                kind = 'return'
                        # fallback to fill color
                        if not kind:
                            try:
                                fill = rc.canvas.itemcget(iid, 'fill')
                                if fill:
                                    kind = f'color:{fill}'
                            except Exception:
                                pass
                        if not kind:
                            kind = 'unknown'
                        kinds.add(kind)

            # show basic confirmation and update Duct tab label with counts
            # Before confirming, check whether any of the selected diffusers are
            # already assigned to some other HVAC in self.hvac_map. If so, notify
            # the user and offer to reassign them to the current system.
            try:
                conflicts = {}
                for other_name, mapping in list(self.hvac_map.items()):
                    try:
                        if not mapping or not isinstance(mapping, dict):
                            continue
                        if other_name == name:
                            continue
                        other_ids = set()
                        for oi in mapping.get('ids', set()) or set():
                            try:
                                other_ids.add(int(oi))
                            except Exception:
                                other_ids.add(oi)
                        inter = set(sel_points_int) & other_ids
                        if inter:
                            conflicts[other_name] = inter
                    except Exception:
                        continue
                if conflicts:
                    # build message listing conflicts per system
                    parts = []
                    total_conf = 0
                    for oname, ids in conflicts.items():
                        parts.append(f"{oname}: {len(ids)}개")
                        total_conf += len(ids)
                    msg = (f"선택한 디퓨저 중 {total_conf}개가 다른 시스템에 할당되어 있습니다:\n"
                           + "\n".join(parts)
                           + f"\n\n계속하면 이 디퓨저들은 현재 시스템 '{name}'으로 재할당됩니다. 계속하시겠습니까?")
                    proceed = messagebox.askyesno("충돌 감지 - 재할당 확인", msg)
                    if not proceed:
                        # abort apply so user can adjust selection
                        try:
                            return
                        except Exception:
                            return
                    # perform reassignment: remove ids from other mappings
                    for oname, ids in conflicts.items():
                        try:
                            other_map = self.hvac_map.get(oname)
                            if not other_map or not isinstance(other_map, dict):
                                continue
                            other_palette = other_map.get('palette')
                            other_set = set()
                            for oi in other_map.get('ids', set()) or set():
                                try:
                                    other_set.add(int(oi))
                                except Exception:
                                    other_set.add(oi)
                            # remove conflicting ids
                            for rem in ids:
                                try:
                                    if rem in other_set:
                                        other_set.remove(rem)
                                except Exception:
                                    try:
                                        other_set.discard(rem)
                                    except Exception:
                                        pass
                            # update mapping
                            try:
                                other_map['ids'] = other_set
                                self.hvac_map[oname] = other_map
                            except Exception:
                                try:
                                    del self.hvac_map[oname]
                                except Exception:
                                    pass
                            # refresh outlines on the other palette if available
                            try:
                                opal = other_map.get('palette')
                                try:
                                    self._refresh_diffuser_outlines(opal)
                                except Exception:
                                    pass
                            except Exception:
                                pass
                            # additionally, remove hvac tag and any nearby main_point_flow labels
                            try:
                                for rem in ids:
                                    try:
                                        # try int conversion
                                        try:
                                            rem_int = int(rem)
                                        except Exception:
                                            rem_int = rem
                                        if other_palette is None:
                                            continue
                                        # remove hvac tag from the specific item if present
                                        try:
                                            other_palette.canvas.dtag(rem_int, f'hvac:{oname}')
                                        except Exception:
                                            pass
                                        # if the removed item exists on the other palette, try to delete nearby main_point_flow labels
                                        try:
                                            if rem_int in other_palette.canvas.find_all():
                                                coords = other_palette.canvas.coords(rem_int)
                                                if coords and len(coords) >= 2:
                                                    if len(coords) >= 4:
                                                        cx = (coords[0] + coords[2]) / 2.0
                                                        cy = (coords[1] + coords[3]) / 2.0
                                                    else:
                                                        cx = coords[0]
                                                        cy = coords[1]
                                                    # scan hvac-tagged items for main_point_flow near this point
                                                    try:
                                                        for it in list(other_palette.canvas.find_withtag(f'hvac:{oname}')):
                                                            try:
                                                                tgs = other_palette.canvas.gettags(it)
                                                            except Exception:
                                                                tgs = ()
                                                            if 'main_point_flow' not in tgs:
                                                                continue
                                                            try:
                                                                c2 = other_palette.canvas.coords(it)
                                                                if not c2 or len(c2) < 2:
                                                                    continue
                                                                if len(c2) >= 4:
                                                                    ix = (c2[0] + c2[2]) / 2.0
                                                                    iy = (c2[1] + c2[3]) / 2.0
                                                                else:
                                                                    ix = c2[0]
                                                                    iy = c2[1]
                                                                # distance threshold in pixels (approx); remove only very close labels
                                                                if abs(ix - cx) <= 24 and abs(iy - cy) <= 24:
                                                                    try:
                                                                        other_palette.canvas.delete(it)
                                                                    except Exception:
                                                                        pass
                                                            except Exception:
                                                                continue
                                                    except Exception:
                                                        pass
                                        except Exception:
                                            pass
                                    except Exception:
                                        continue
                            except Exception:
                                pass
                        except Exception:
                            continue
            except Exception:
                # non-fatal: continue
                pass
            try:
                messagebox.showinfo("적용", f"선택된 시스템: {name}")
            except Exception:
                pass

            types_count = len(kinds)
            types_list = ", ".join(sorted(kinds)) if kinds else "없음"
            try:
                self.duct_selected_label_var.set(f"선택 디퓨저: {sel_count} | 종류 수: {types_count} ({types_list})")
            except Exception:
                # fallback: nothing to do
                pass
            # Note: Blue outline will be applied after main point assignment completes
            # If this HVAC already has stored mapping on this palette, remove
            # any previously-created main-point markers (and their text labels)
            # before starting a new assignment. Do NOT delete diffuser items.
            try:
                existing_map = self.hvac_map.get(name)
                if existing_map and isinstance(existing_map, dict):
                    try:
                        mapped_palette = existing_map.get('palette')
                        mapped_ids = set(existing_map.get('ids', set()) or set())
                    except Exception:
                        mapped_palette = None
                        mapped_ids = set()
                    if mapped_palette is rc and mapped_ids:
                        remaining = set()
                        for iid in list(mapped_ids):
                            try:
                                # ensure iid is int
                                iid_int = int(iid)
                            except Exception:
                                try:
                                    iid_int = iid
                                except Exception:
                                    continue
                            try:
                                if iid_int not in rc.canvas.find_all():
                                    continue
                            except Exception:
                                # if find_all fails for this id, skip
                                try:
                                    # still try to convert and skip
                                    continue
                                except Exception:
                                    continue
                            try:
                                ctype = rc.canvas.type(iid_int)
                                tags = rc.canvas.gettags(iid_int)
                            except Exception:
                                ctype = None
                                tags = ()
                            # delete only items that are main_point markers or text labels
                            try:
                                if 'main_point' in tags or ctype == 'text':
                                    try:
                                        rc.canvas.delete(iid_int)
                                    except Exception:
                                        pass
                                    # don't keep this id
                                    continue
                                else:
                                    # preserve other ids (diffusers etc.)
                                    remaining.add(iid_int)
                            except Exception:
                                remaining.add(iid_int)
                        # Remove only items tagged specifically for this HVAC (includes flow labels tagged with hvac:<name>)
                        try:
                            hv_tag = f'hvac:{name}'
                            for tag_item in list(rc.canvas.find_withtag(hv_tag)):
                                try:
                                    rc.canvas.delete(tag_item)
                                except Exception:
                                    pass
                        except Exception:
                            pass
                        # update mapping ids to remaining ones
                        try:
                            existing_map['ids'] = remaining
                            self.hvac_map[name] = existing_map
                        except Exception:
                            try:
                                del self.hvac_map[name]
                            except Exception:
                                pass
                        # refresh outlines on current palette so removed main_point markers clear
                        try:
                            self._refresh_diffuser_outlines(rc)
                        except Exception:
                            pass
            except Exception:
                pass
            # Offer the user to assign one main point per kind interactively
            try:
                if types_count > 0:
                    if messagebox.askyesno("메인 포인트 지정", f"{types_count}개의 종류가 감지되었습니다. 각 종류별 메인 포인트를 지정하시겠습니까?"):
                        kinds_ordered = sorted(kinds)
                        # start interactive assignment on the current palette
                        try:
                            self._start_main_point_assignment(rc, kinds_ordered, name)
                        except Exception as e:
                            messagebox.showerror("오류", f"메인 포인트 지정 중 오류: {e}")
            except Exception:
                pass
        except Exception as e:
            messagebox.showerror("오류", f"적용 중 오류: {e}")

    def _on_hvac_right_click(self, event):
        """Show a small popup menu to delete the item under the cursor."""
        try:
            # index of item under pointer
            idx = self.hvac_listbox.nearest(event.y)
            if idx is None:
                return
            # select the item so user sees which will be affected
            self.hvac_listbox.selection_clear(0, tk.END)
            self.hvac_listbox.selection_set(idx)
            # popup the menu at the pointer location
            try:
                self._hvac_menu.tk_popup(event.x_root, event.y_root)
            finally:
                self._hvac_menu.grab_release()
        except Exception as e:
            # silent fail with optional debug
            print(f"HVAC right-click menu error: {e}")

    def _delete_selected_hvac(self):
        """Delete the currently selected HVAC item after user confirmation."""
        try:
            sel = self.hvac_listbox.curselection()
            if not sel:
                return
            idx = sel[0]
            name = self.hvac_listbox.get(idx)
            if messagebox.askyesno("삭제 확인", f"'{name}' 항목을 삭제하시겠습니까?"):
                self.hvac_listbox.delete(idx)
        except Exception as e:
            messagebox.showerror("오류", f"삭제 중 오류: {e}")

    def _on_hvac_select(self):
        """Highlight items related to the currently selected HVAC in the active palette."""
        try:
            sel = self.hvac_listbox.curselection()
            if not sel:
                return
            name = self.hvac_listbox.get(sel[0])
            try:
                print(f"DEBUG _on_hvac_select: selected_name={name}")
            except Exception:
                pass
            # track active hvac name for robust checks in mouse handlers
            try:
                self._active_hvac_name = name
            except Exception:
                self._active_hvac_name = None
            rc = self.get_current_palette()
            if not rc:
                return
            # clear previous highlights for this palette
            try:
                # persistent supply-assigned set should not be cleared here
                try:
                    supply_assigned = set(getattr(self, '_supply_assigned', set()) or set())
                except Exception:
                    supply_assigned = set()
                
                # Build map of all assigned items to their HVAC systems
                all_assigned_map = {}
                try:
                    for hvac_name, hvac_mapping in self.hvac_map.items():
                        if hvac_mapping and isinstance(hvac_mapping, dict):
                            for iid in hvac_mapping.get('ids', set()) or set():
                                all_assigned_map[iid] = hvac_name
                except Exception:
                    pass
                
                # Restore outlines for previously highlighted items (includes main_points)
                for iid in list(getattr(self, '_hvac_highlighted', set())):
                    try:
                        # only process items that still exist on this canvas
                        if iid in rc.canvas.find_all():
                            # If applied (in supply_assigned), restore to blue
                            if iid in supply_assigned:
                                rc.canvas.itemconfigure(iid, outline='blue', width=2)
                            # If assigned to some HVAC but not applied
                            elif iid in all_assigned_map:
                                # Will be set to yellow later if it belongs to the new HVAC
                                rc.canvas.itemconfigure(iid, outline='')
                            else:
                                # Unassigned: clear outline
                                rc.canvas.itemconfigure(iid, outline='')
                    except Exception:
                        pass
                
                # Clear _hvac_highlighted set
                try:
                    self._hvac_highlighted.clear()
                except Exception:
                    self._hvac_highlighted = set()
            except Exception:
                pass
            # Clear any existing point selection in the palette
            # (selected_points only contains diffusers, not main_points)
            try:
                # Get all currently selected points (diffusers only)
                prev_selected = set(getattr(rc, 'selected_points', set()) or set())
                
                # Restore outlines for previously selected diffusers were already handled above
                # in _hvac_highlighted loop, so just clear the set
                rc.selected_points = set()
            except Exception:
                pass

            # fetch mapping (stored as {'palette': rc_obj, 'ids': set(...)})
            mapping = self.hvac_map.get(name)
            try:
                print(f"DEBUG _on_hvac_select: mapping_exists={bool(mapping)} mapping={mapping}")
            except Exception:
                pass
            mapped_for_palette = []
            if mapping and isinstance(mapping, dict):
                try:
                    mapped_palette = mapping.get('palette')
                    ids = mapping.get('ids', set())
                    # only restore if the recorded palette is the same instance as current
                    if mapped_palette is rc:
                        mapped_for_palette = list(ids)
                except Exception:
                    mapped_for_palette = []
            if not mapped_for_palette:
                # nothing mapped: ensure label shows zero
                try:
                    if getattr(self, 'duct_selected_label_var', None) is not None:
                        self.duct_selected_label_var.set("선택 디퓨저: 0")
                except Exception:
                    pass
                try:
                    print(f"DEBUG _on_hvac_select: no mapped items for {name}; cleared selection on palette")
                except Exception:
                    pass
                try:
                    # Force focus to the canvas so that a user clicking/dragging
                    # on the palette immediately after selecting an HVAC will
                    # deliver mouse events to the canvas.
                    try:
                        rc.canvas.focus_force()
                    except Exception:
                        try:
                            rc.canvas.focus_set()
                        except Exception:
                            pass
                    # schedule a short delayed focus in case the UI focus is
                    # still settling after the listbox selection event.
                    try:
                        self.root.after(50, lambda: rc.canvas.focus_set())
                    except Exception:
                        pass
                except Exception:
                    pass
                return

            # apply new highlights and selection set
            for iid in mapped_for_palette:
                try:
                    if iid in rc.canvas.find_all():
                        # Check if this item is a main_point (should not be added to selected_points)
                        try:
                            tags = rc.canvas.gettags(iid)
                            is_main_point = 'main_point' in tags
                        except Exception:
                            is_main_point = False
                        
                        # Show all assigned items (diffusers and main_points) in yellow when their HVAC is selected
                        rc.canvas.itemconfigure(iid, outline='yellow', width=2)
                        
                        if not is_main_point:
                            # Only add diffusers to selected_points (not main_points)
                            try:
                                rc.selected_points.add(iid)
                            except Exception:
                                rc.selected_points = set([iid])
                        
                        self._hvac_highlighted.add(iid)
                except Exception:
                    pass
            # update selection count label
            try:
                if getattr(self, 'duct_selected_label_var', None) is not None:
                    self.duct_selected_label_var.set(f"선택 디퓨저: {len(getattr(rc, 'selected_points', set()))}")
            except Exception:
                pass
            try:
                print(f"DEBUG _on_hvac_select: restored {len(getattr(rc, 'selected_points', set()))} items for {name}")
            except Exception:
                pass
            try:
                rc.canvas.focus_set()
            except Exception:
                pass
        except Exception:
            pass

    def _on_reset_diffusers(self):
        rc = self.get_current_palette()
        if not rc:
            messagebox.showinfo("정보", "활성화된 팔레트가 없습니다.")
            return

    def _start_main_point_assignment(self, rc, kinds_ordered, hvac_name=None):
        """Interactively ask the user to click one main diffuser point per kind.

        rc: Palette instance
        kinds_ordered: list of kind strings to assign
        """
        if rc is None:
            return

        canvas = rc.canvas
        assigned = {}

        info_txt = (
            "이제 메인 포인트를 지정합니다.\n"
            "각 창에 표시되는 안내에 따라 해당 종류의 대표 디퓨저를 캔버스에서 클릭하세요.\n"
            "취소하려면 ESC 키를 누르세요."
        )
        messagebox.showinfo("메인 포인트 안내", info_txt)

        state = {
            'kinds': kinds_ordered,
            'index': 0,
            'assigned': assigned,
            'orig_bind_click': None,
            'orig_bind_key': None,
            'preview_id': None,
        }

        def finish_assignment(success=True):
            # restore bindings
            try:
                # remove temporary click/key handlers used during assignment
                try:
                    canvas.unbind('<Button-1>')
                except Exception:
                    pass
                try:
                    canvas.unbind('<Motion>')
                except Exception:
                    pass
            except Exception:
                pass
            try:
                canvas.unbind('<Key>')
            except Exception:
                pass
            # remove any preview marker
            try:
                pid = state.get('preview_id')
                if pid is not None:
                    try:
                        if pid in canvas.find_all():
                            canvas.delete(pid)
                    except Exception:
                        try:
                            canvas.delete(pid)
                        except Exception:
                            pass
                    state['preview_id'] = None
            except Exception:
                pass
            try:
                canvas.configure(cursor='')
            except Exception:
                pass
            # focus back to root
            try:
                self.root.focus_force()
            except Exception:
                pass
            # restore the Palette's standard mouse bindings (left button handlers)
            try:
                # restore Palette instance handlers
                canvas.bind('<ButtonPress-1>', rc.on_left_down)
                canvas.bind('<B1-Motion>', rc.on_left_drag)
                canvas.bind('<ButtonRelease-1>', rc.on_left_up)
                # ensure canvas has focus to receive events
                try:
                    canvas.focus_set()
                except Exception:
                    pass
            except Exception:
                pass
            # Ensure the Palette instance transient state is fully reset so it doesn't
            # interfere with normal Room Design interactions afterwards.
            try:
                # clear any rectangle-selection state
                try:
                    if getattr(rc, 'rect_select_id', None):
                        drawc = getattr(rc, 'rect_draw_canvas', None) or getattr(rc, 'overlay', None) or rc.canvas
                        if drawc and rc.rect_select_id in drawc.find_all():
                            try:
                                drawc.delete(rc.rect_select_id)
                            except Exception:
                                pass
                except Exception:
                    pass
                try:
                    rc.rect_select_id = None
                    rc.rect_select_start = None
                    rc.rect_select_ctrl = False
                    rc.rect_draw_canvas = None
                    rc.rect_draw_total = False
                except Exception:
                    pass
                # clear any active side-drag or moving state
                try:
                    rc.active_side_name = None
                    rc.drag_start_mouse_pos = None
                    rc.drag_start_coords = None
                    rc.moving_shape = None
                    rc.move_start_mouse_pos = None
                    rc.move_start_shape_coords = None
                except Exception:
                    pass
                # ensure overlay is removed if present
                try:
                    if getattr(rc, 'overlay', None) is not None and getattr(rc, 'overlay', 'canvas') is not rc.canvas:
                        try:
                            rc.overlay.delete('all')
                        except Exception:
                            pass
                except Exception:
                    pass
            except Exception:
                pass
            # if assignment succeeded and hvac_name provided, record mapping
            try:
                if success and hvac_name:
                    # store mapping associated with this exact Palette instance so
                    # re-selecting works even if palette ordering changed
                    ids = set()
                    # Add main point markers (created during assignment)
                    for kind, info in state.get('assigned', {}).items():
                        iid = info.get('iid')
                        labid = info.get('label_id')
                        if iid:
                            try:
                                ids.add(int(iid))
                            except Exception:
                                pass
                        if labid:
                            try:
                                ids.add(int(labid))
                            except Exception:
                                pass
                    # Add ONLY the currently selected diffuser ids (not all same-type diffusers)
                    try:
                        sel_pts = getattr(rc, 'selected_points', set()) or set()
                        for sp in list(sel_pts):
                            try:
                                ids.add(int(sp))
                            except Exception:
                                pass
                    except Exception:
                        pass
                    # store mapping with palette reference
                    try:
                        # Before updating, remove diffusers from _supply_assigned that were
                        # previously assigned to this HVAC but are no longer selected
                        try:
                            old_mapping = self.hvac_map.get(hvac_name)
                            if old_mapping and isinstance(old_mapping, dict):
                                old_ids = set()
                                for oid in old_mapping.get('ids', set()) or set():
                                    try:
                                        old_ids.add(int(oid))
                                    except Exception:
                                        old_ids.add(oid)
                                # Get main point ids (should not be removed from _supply_assigned)
                                main_point_ids = set()
                                try:
                                    for kind, info in state.get('assigned', {}).items():
                                        mp_iid = info.get('iid')
                                        if mp_iid:
                                            try:
                                                main_point_ids.add(int(mp_iid))
                                            except Exception:
                                                main_point_ids.add(mp_iid)
                                except Exception:
                                    pass
                                # Find diffusers that were in old mapping but not in new ids
                                removed_diffusers = old_ids - ids - main_point_ids
                                # Remove these from _supply_assigned
                                try:
                                    if hasattr(self, '_supply_assigned') and self._supply_assigned:
                                        for rid in removed_diffusers:
                                            try:
                                                self._supply_assigned.discard(rid)
                                            except Exception:
                                                pass
                                        # Also clear their outline
                                        try:
                                            for rid in removed_diffusers:
                                                if rid in rc.canvas.find_all():
                                                    try:
                                                        rc.canvas.itemconfigure(rid, outline='')
                                                    except Exception:
                                                        pass
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                        except Exception:
                            pass
                        
                        # store mapping with palette reference
                        mapping_entry = {'palette': rc, 'ids': ids}
                        # compute per-main-point aggregated flows across the whole HVAC mapping
                        main_point_flows = {}
                        try:
                            # hvac_ids: all diffuser/main ids recorded for this HVAC system
                            hvac_ids = set(ids)
                            # For each assigned kind, sum flows of hvac_ids that match the kind
                            for kind, info in state.get('assigned', {}).items():
                                iid = info.get('iid')
                                if not iid:
                                    continue
                                total = 0.0
                                try:
                                    # iterate every recorded id for this hvac and look up its palette/lab
                                    for did in hvac_ids:
                                        try:
                                            # find the palette that contains this item id
                                            found_pal = None
                                            found_lab = None
                                            for pal in getattr(self, 'palettes', []):
                                                try:
                                                    if did in pal.canvas.find_all():
                                                        found_pal = pal
                                                        break
                                                except Exception:
                                                    continue
                                            if not found_pal:
                                                continue
                                            try:
                                                tags = found_pal.canvas.gettags(did)
                                            except Exception:
                                                tags = ()
                                            include = False
                                            try:
                                                if isinstance(kind, str) and (kind == 'supply' or kind == 'return'):
                                                    if kind in tags:
                                                        include = True
                                                else:
                                                    if f'diffuser_type:{kind}' in tags:
                                                        include = True
                                            except Exception:
                                                include = False
                                            if not include:
                                                continue
                                            # locate the lab containing this diffuser id
                                            for lab in getattr(found_pal, 'generated_space_labels', []):
                                                try:
                                                    if did in (lab.get('diffuser_ids') or []):
                                                        found_lab = lab
                                                        break
                                                except Exception:
                                                    continue
                                            if not found_lab:
                                                continue
                                            try:
                                                df = float(found_lab.get('diffuser_flows', {}).get(did, 0.0))
                                            except Exception:
                                                try:
                                                    df = float(found_lab.get('diffuser_flows', {}).get(int(did), 0.0))
                                                except Exception:
                                                    df = 0.0
                                            total += df
                                        except Exception:
                                            continue
                                except Exception:
                                    total = 0.0
                                main_point_flows[iid] = round(float(total), 2)
                                # bind hover handlers to show tooltip for this main point
                                try:
                                    ft = f"{main_point_flows[iid]:.2f} m3/hr"
                                    # bind enter/leave on the palette canvas where the main point exists
                                    try:
                                        mp_pal = rc
                                        if iid not in mp_pal.canvas.find_all():
                                            # try find the palette containing the main point
                                            for pal2 in getattr(self, 'palettes', []):
                                                try:
                                                    if iid in pal2.canvas.find_all():
                                                        mp_pal = pal2
                                                        break
                                                except Exception:
                                                    continue
                                        mp_pal.canvas.tag_bind(iid, '<Enter>', (lambda ev, pal=mp_pal, txt=ft: pal._show_flow_tooltip(txt, ev.x, ev.y)))
                                        mp_pal.canvas.tag_bind(iid, '<Leave>', (lambda ev, pal=mp_pal: pal._hide_flow_tooltip()))
                                    except Exception:
                                        # fallback: bind to current palette
                                        rc.canvas.tag_bind(iid, '<Enter>', (lambda ev, rc=rc, txt=ft: rc._show_flow_tooltip(txt, ev.x, ev.y)))
                                        rc.canvas.tag_bind(iid, '<Leave>', (lambda ev, rc=rc: rc._hide_flow_tooltip()))
                                except Exception:
                                    pass
                        except Exception:
                            main_point_flows = {}
                        mapping_entry['main_point_flows'] = main_point_flows
                        self.hvac_map[hvac_name] = mapping_entry
                        # After main point assignment completes, mark all selected diffusers and main_points
                        # with blue outline (applied/persistent state)
                        try:
                            # initialize persistent set if not present
                            try:
                                if not hasattr(self, '_supply_assigned') or self._supply_assigned is None:
                                    self._supply_assigned = set()
                            except Exception:
                                self._supply_assigned = set()
                            # get currently selected points on this palette and mark them as applied
                            try:
                                sel_pts = getattr(rc, 'selected_points', set()) or set()
                                for sp in list(sel_pts):
                                    try:
                                        sp_int = int(sp)
                                    except Exception:
                                        sp_int = sp
                                    try:
                                        rc.canvas.itemconfigure(sp_int, outline='blue', width=2)
                                    except Exception:
                                        pass
                                    try:
                                        self._supply_assigned.add(sp_int)
                                    except Exception:
                                        try:
                                            self._supply_assigned = set(getattr(self, '_supply_assigned', set()) or set())
                                            self._supply_assigned.add(sp_int)
                                        except Exception:
                                            pass
                            except Exception:
                                pass
                            # Also mark main_points as applied (blue outline)
                            try:
                                for kind, info in state.get('assigned', {}).items():
                                    mp_iid = info.get('iid')
                                    if mp_iid:
                                        try:
                                            mp_int = int(mp_iid)
                                        except Exception:
                                            mp_int = mp_iid
                                        try:
                                            rc.canvas.itemconfigure(mp_int, outline='blue', width=2)
                                        except Exception:
                                            pass
                                        try:
                                            self._supply_assigned.add(mp_int)
                                        except Exception:
                                            pass
                            except Exception:
                                pass
                        except Exception:
                            pass
                        # create small on-canvas labels next to each main point showing aggregated flow
                        try:
                            for iid, qv in list(main_point_flows.items()):
                                try:
                                    # find palette that contains this main point id
                                    mp_pal = rc
                                    if iid not in mp_pal.canvas.find_all():
                                        for pal2 in getattr(self, 'palettes', []):
                                            try:
                                                if iid in pal2.canvas.find_all():
                                                    mp_pal = pal2
                                                    break
                                            except Exception:
                                                continue
                                    # get coords
                                    try:
                                        coords = mp_pal.canvas.coords(iid)
                                        if not coords or len(coords) < 2:
                                            continue
                                        # main_point marker may be a shape or text; center accordingly
                                        if len(coords) >= 4:
                                            mx = (coords[0] + coords[2]) / 2.0
                                            my = (coords[1] + coords[3]) / 2.0
                                        else:
                                            mx = coords[0]
                                            my = coords[1]
                                    except Exception:
                                        continue
                                    try:
                                        txt = f"{float(qv):,.0f} m3/h"
                                    except Exception:
                                        try:
                                            txt = f"{int(qv)} m3/h"
                                        except Exception:
                                            txt = str(qv)
                                    # place label slightly above/right of main point
                                    try:
                                        mp_pal.canvas.create_text(mx + 8, my - 8, text=txt, anchor=tk.W, fill='red', font=("Arial", 9, "bold"), tags=('main_point_flow', f'hvac:{hvac_name}'))
                                    except Exception:
                                        try:
                                            mp_pal.canvas.create_text(mx + 8, my - 8, text=txt, anchor=tk.W, fill='red', font=("Arial", 9))
                                        except Exception:
                                            pass
                                except Exception:
                                    continue
                        except Exception:
                            pass
                    except Exception:
                        pass
            except Exception:
                pass

        def on_key(event):
            # ESC to cancel
            if event.keysym == 'Escape':
                messagebox.showinfo('취소', '메인 포인트 지정을 취소합니다.')
                finish_assignment(False)

        def on_motion(event):
            # show a preview of where the main point would be snapped
            try:
                wx = canvas.canvasx(event.x)
                wy = canvas.canvasy(event.y)
                import math
                spacing = max(1.0, rc.meter_to_pixel(0.5))
                try:
                    if rc.shapes:
                        anchor_x = float(rc.shapes[0].coords[0])
                        anchor_y = float(rc.shapes[0].coords[1])
                    else:
                        anchor_x = 0.0
                        anchor_y = 0.0
                except Exception:
                    anchor_x = 0.0
                    anchor_y = 0.0
                rem_x = anchor_x - math.floor(anchor_x / spacing) * spacing
                rem_y = anchor_y - math.floor(anchor_y / spacing) * spacing
                kx = int(round((wx - rem_x) / spacing))
                ky = int(round((wy - rem_y) / spacing))
                cx = kx * spacing + rem_x
                cy = ky * spacing + rem_y
                # determine radius similar to on_click
                try:
                    radius = 3
                    try:
                        existing = list(canvas.find_withtag('diffuser'))
                        if existing:
                            c = canvas.coords(existing[0])
                            if c and len(c) >= 4:
                                radius = abs((c[2] - c[0]) / 2.0)
                    except Exception:
                        radius = 3
                except Exception:
                    radius = 3
                # draw or move preview oval
                try:
                    pid = state.get('preview_id')
                    if pid is None or pid not in canvas.find_all():
                        # translucent preview (use empty outline and stipple via a transparent fill if unsupported, use light color)
                        try:
                            pid = canvas.create_oval(cx - radius, cy - radius, cx + radius, cy + radius,
                                                     fill='orange', outline='black', dash=(2, 2), tags=('preview',))
                        except Exception:
                            pid = canvas.create_oval(cx - radius, cy - radius, cx + radius, cy + radius,
                                                     fill='orange', outline='black', tags=('preview',))
                        state['preview_id'] = pid
                    else:
                        try:
                            canvas.coords(pid, cx - radius, cy - radius, cx + radius, cy + radius)
                        except Exception:
                            # recreate if move fails
                            try:
                                canvas.delete(pid)
                            except Exception:
                                pass
                            try:
                                pid = canvas.create_oval(cx - radius, cy - radius, cx + radius, cy + radius,
                                                         fill='orange', outline='black', dash=(2, 2), tags=('preview',))
                                state['preview_id'] = pid
                            except Exception:
                                state['preview_id'] = None
                except Exception:
                    pass
            except Exception:
                pass

        def on_click(event):
            idx = state['index']
            if idx >= len(state['kinds']):
                finish_assignment(True)
                return
            kind = state['kinds'][idx]
            # Create a NEW main point snapped to the nearest grid intersection
            try:
                # convert event to canvas/world coordinates
                wx = canvas.canvasx(event.x)
                wy = canvas.canvasy(event.y)
                import math
                # compute spacing and anchor similar to draw_grid
                spacing = max(1.0, rc.meter_to_pixel(0.5))
                try:
                    if rc.shapes:
                        anchor_x = float(rc.shapes[0].coords[0])
                        anchor_y = float(rc.shapes[0].coords[1])
                    else:
                        anchor_x = 0.0
                        anchor_y = 0.0
                except Exception:
                    anchor_x = 0.0
                    anchor_y = 0.0
                rem_x = anchor_x - math.floor(anchor_x / spacing) * spacing
                rem_y = anchor_y - math.floor(anchor_y / spacing) * spacing
                kx = int(round((wx - rem_x) / spacing))
                ky = int(round((wy - rem_y) / spacing))
                cx = kx * spacing + rem_x
                cy = ky * spacing + rem_y

                # create a small oval point at snapped coords; match existing diffuser pixel size when possible
                try:
                    radius = 3
                    # prefer to match an existing diffuser's current pixel radius (accounts for zoom/scale)
                    try:
                        existing = list(canvas.find_withtag('diffuser'))
                        if existing:
                            # use first diffuser's bbox to derive radius
                            c = canvas.coords(existing[0])
                            if c and len(c) >= 4:
                                radius = abs((c[2] - c[0]) / 2.0)
                    except Exception:
                        radius = 3
                except Exception:
                    radius = 3
                # tag the main_point with hvac name when available so it remains associated
                main_tags = ('diffuser','main_point', f'diffuser_type:{kind}')
                try:
                    if hvac_name:
                        # convert to tuple with hvac tag
                        main_tags = tuple(list(main_tags) + [f'hvac:{hvac_name}'])
                except Exception:
                    pass
                iid_new = canvas.create_oval(cx - radius, cy - radius, cx + radius, cy + radius,
                                             fill='red', outline='', tags=main_tags)
                # create label next to it
                try:
                    tid = canvas.create_text(cx + 8, cy, text=kind, anchor=tk.W, fill='black', font=('Arial', 8, 'bold'))
                    try:
                        canvas.addtag_withtag(f'diffuser_type:{kind}', tid)
                    except Exception:
                        pass
                except Exception:
                    tid = None
                # record assignment
                state['assigned'][kind] = {'iid': iid_new, 'label_id': tid, 'orig_fill': None}
                # remove preview if present
                try:
                    pid = state.get('preview_id')
                    if pid is not None:
                        try:
                            if pid in canvas.find_all():
                                canvas.delete(pid)
                        except Exception:
                            try:
                                canvas.delete(pid)
                            except Exception:
                                pass
                        state['preview_id'] = None
                except Exception:
                    pass
            except Exception as e:
                messagebox.showerror('오류', f'메인 포인트 생성 중 오류: {e}')
                finish_assignment(False)
                return

            state['index'] += 1
            if state['index'] >= len(state['kinds']):
                messagebox.showinfo('완료', '모든 종류의 메인 포인트가 지정되었습니다.')
                finish_assignment(True)
                return
            else:
                # prompt next kind
                next_kind = state['kinds'][state['index']]
                messagebox.showinfo('다음 지정', f'다음 종류: {next_kind} 를 클릭하세요.')

        # prepare canvas to receive clicks
        try:
            canvas.focus_set()
            canvas.bind('<Button-1>', lambda e: on_click(e))
            canvas.bind('<Motion>', lambda e: on_motion(e))
            canvas.bind('<Key>', lambda e: on_key(e))
            canvas.configure(cursor='crosshair')
            # initial prompt for first kind
            if state['kinds']:
                messagebox.showinfo('지시', f'첫번째 종류: {state["kinds"][0]} 를 클릭하세요.')
        except Exception as e:
            messagebox.showerror('오류', f'메인 포인트 입력 준비 중 오류: {e}')
    
    def load_csv_preview(self):
        """Open a CSV file and show its contents in a new window as a simple table.

        Uses several encoding fallbacks (utf-8, cp949, latin-1) to handle common CSV encodings.
        """
        from tkinter import filedialog
        import csv

        file_path = filedialog.askopenfilename(title="CSV 파일 선택", filetypes=[("CSV files", "*.csv"), ("All files", "*")])
        if not file_path:
            return

        encodings = ["utf-8", "cp949", "latin-1"]
        rows = []
        used_enc = None
        for enc in encodings:
            try:
                with open(file_path, 'r', encoding=enc, errors='strict') as f:
                    reader = csv.reader(f)
                    rows = [r for r in reader]
                used_enc = enc
                break
            except Exception:
                # try next encoding
                continue

        if used_enc is None:
            # last resort: open with latin-1 permissive
            try:
                with open(file_path, 'r', encoding='latin-1', errors='replace') as f:
                    reader = csv.reader(f)
                    rows = [r for r in reader]
                used_enc = 'latin-1'
            except Exception as e:
                messagebox.showerror("CSV 로드 오류", f"파일을 읽을 수 없습니다:\n{e}")
                return

        # create preview window
        # save loaded CSV on the app for later use by popups
        try:
            self.last_csv_rows = rows
            self.last_csv_file_path = file_path
            self.last_csv_encoding = used_enc
        except Exception:
            pass
        
        try:
            # ensure any transient overlay is removed so the dialog is visible
            try:
                self._destroy_total_overlay()
            except Exception:
                pass
        except Exception:
            pass
        win = tk.Toplevel(self.root)
        try:
            win.lift()
            try:
                win.wm_attributes('-topmost', True)
                win.after(60, lambda: win.wm_attributes('-topmost', False))
            except Exception:
                pass
        except Exception:
            pass
        win.title(f"CSV 미리보기 - {os.path.basename(file_path)} ({used_enc})")
        win.geometry("800x400")

        from tkinter import ttk
        tree = ttk.Treeview(win, show='headings')

        # determine column count
        max_cols = max((len(r) for r in rows), default=0)
        cols = [f"C{i+1}" for i in range(max_cols)]
        tree['columns'] = cols
        for i, c in enumerate(cols):
            tree.heading(c, text=c)
            tree.column(c, width=120, anchor='w')

        # insert rows
        for r in rows:
            # pad shorter rows
            row = list(r) + [""] * (max_cols - len(r))
            tree.insert('', tk.END, values=row)

        tree.pack(fill=tk.BOTH, expand=True)

        # add a simple close button
        btn = tk.Button(win, text="닫기", command=win.destroy)
        btn.pack(side=tk.BOTTOM, pady=6)
 
    def extract_equipment_list(self):
        """Collect per-room displayed values and export to .xlsx (or CSV fallback).

        Uses the currently selected palette (tab). If CSV rows were loaded earlier via
        'CSV로드', those rows are used to select table values per-room similarly to the
        popup logic.
        """
        rows = getattr(self, 'last_csv_rows', None)
        if not rows:
            messagebox.showinfo("장비일람표 없음", "먼저 CSV를 로드하세요 (툴바의 'CSV로드').")
            return

        rc = self.get_current_palette()
        if not rc:
            messagebox.showinfo('장비일람표 없음', '활성화된 팔레트를 선택하세요.')
            return

        base_header = [
            "Room Name",
            "HVAC Type",
            "HVAC Detail",
            "Area (m2)",
            "Norm (W/m2)",
            "Equip (W/m2)",
            "Matched CSV Column",
            "Matched Value",
        ]

        export_rows = [base_header]

        def _get_text(lab, key):
            try:
                return rc.canvas.itemcget(lab[key], 'text')
            except Exception:
                return ""

        # helper to extract first numeric token
        def _extract_num_token(s: str):
            if not s:
                return ""
            for tok in s.replace(',', ' ').split():
                try:
                    float(tok)
                    return tok
                except Exception:
                    continue
            return ""

        # iterate labels from the active palette
        for lab in getattr(rc, 'generated_space_labels', []):
            try:
                name = _get_text(lab, 'name_id')
                area_text = _get_text(lab, 'area_id')
                norm_text = _get_text(lab, 'heat_norm_id')
                equip_text = _get_text(lab, 'heat_equip_id')

                area_val = _extract_num_token(area_text)
                norm_val = _extract_num_token(norm_text)
                equip_val = _extract_num_token(equip_text)

                hvac_type = lab.get('hvac_type', '')
                hvac_detail_text = lab.get('hvac_detail_text', '') or lab.get('hvac_detail', '') or ''

                matched_col = ''
                matched_val = ''
                table_rows_for_export = []

                # reproduce popup selection logic minimally
                try:
                    rows_local = rows
                    if rows_local and len(rows_local) >= 2 and str(hvac_type) == '2' and hvac_detail_text:
                        headers = rows_local[0]
                        second = rows_local[1]
                        sel_detail = hvac_detail_text

                        preferred_cols = []
                        for ci, h in enumerate(headers):
                            try:
                                if sel_detail.lower() in str(h).lower():
                                    preferred_cols.append(ci)
                            except Exception:
                                continue

                        candidates = []
                        if preferred_cols:
                            for ci in preferred_cols:
                                try:
                                    v = float(second[ci]) if ci < len(second) else None
                                    if v is not None:
                                        candidates.append((ci, v))
                                except Exception:
                                    continue
                        else:
                            for ci, val in enumerate(second):
                                try:
                                    v = float(val)
                                    candidates.append((ci, v))
                                except Exception:
                                    continue

                        csv_shown_vals = []
                        if sel_detail and not preferred_cols:
                            csv_shown_vals = [((r[0] if len(r) > 0 else ''), '') for r in rows_local]
                        else:
                            if candidates:
                                import math
                                # compute total_kw safely
                                try:
                                    total_kw_local = float(area_val) * (float(norm_val) if norm_val else 0.0 + float(equip_val) if equip_val else 0.0) / 1000.0
                                except Exception:
                                    total_kw_local = 0.0

                                if preferred_cols and sel_detail:
                                    vals_only = [c[1] for c in candidates]
                                    max_val = max(vals_only) if vals_only else 0.0

                                    # If the user previously saved a quantity for this lab, prefer it
                                    stored_qty = None
                                    try:
                                        if 'hvac_qty' in lab and lab.get('hvac_qty') is not None:
                                            stored_qty = int(lab.get('hvac_qty'))
                                    except Exception:
                                        stored_qty = None

                                    # compute qty/target using stored quantity when available
                                    if stored_qty is not None and stored_qty > 0:
                                        qty = stored_qty
                                        target = total_kw_local / max(1, qty)
                                    else:
                                        if max_val > 0 and total_kw_local < max_val:
                                            target = total_kw_local / 2.0
                                            qty = 2
                                        else:
                                            if max_val > 0:
                                                ratio = total_kw_local / max_val
                                            else:
                                                ratio = total_kw_local
                                            qty = int(math.ceil(ratio)) + 2
                                            if qty <= 0:
                                                qty = 2
                                            target = total_kw_local / qty if qty != 0 else total_kw_local

                                    greater = [c for c in candidates if c[1] >= target]
                                    if greater:
                                        best = min(greater, key=lambda x: x[1])
                                    else:
                                        lesser = [c for c in candidates if c[1] < target]
                                        if lesser:
                                            best = max(lesser, key=lambda x: x[1])
                                        else:
                                            best = candidates[0]
                                    ci, cv = best
                                    matched_col = headers[ci] if ci < len(headers) else f'C{ci+1}'
                                    csv_shown_vals = [((r[0] if len(r) > 0 else ''), (r[ci] if ci < len(r) else '')) for r in rows_local]
                                    try:
                                        # ensure displayed quantity reflects stored value if present
                                        csv_shown_vals.insert(0, ("대수(Q'ty)", str(qty)))
                                    except Exception:
                                        pass
                                    for data_row in rows_local[1:]:
                                        if ci < len(data_row) and data_row[ci] is not None and str(data_row[ci]).strip() != "":
                                            matched_val = data_row[ci]
                                            break
                                else:
                                            # consider stored quantity when available for default selection as well
                                            stored_qty = None
                                            try:
                                                if 'hvac_qty' in lab and lab.get('hvac_qty') is not None:
                                                    stored_qty = int(lab.get('hvac_qty'))
                                            except Exception:
                                                stored_qty = None

                                            if stored_qty is not None and stored_qty > 0:
                                                # compute target per-unit value and pick candidate closest >= target else closest below
                                                target = total_kw_local / max(1, stored_qty)
                                                greater = [c for c in candidates if c[1] >= target]
                                                if greater:
                                                    best = min(greater, key=lambda x: x[1])
                                                else:
                                                    lesser = [c for c in candidates if c[1] < target]
                                                    if lesser:
                                                        best = max(lesser, key=lambda x: abs(x[1] - target))
                                                    else:
                                                        best = candidates[0]
                                            else:
                                                greater = [c for c in candidates if c[1] >= total_kw_local]
                                                if greater:
                                                    best = min(greater, key=lambda x: x[1])
                                                else:
                                                    lesser = [c for c in candidates if c[1] < total_kw_local]
                                                    if lesser:
                                                        best = max(lesser, key=lambda x: x[1])
                                                    else:
                                                        best = candidates[0]
                                            ci, cv = best
                                            matched_col = headers[ci] if ci < len(headers) else f'C{ci+1}'
                                            csv_shown_vals = [((r[0] if len(r) > 0 else ''), (r[ci] if ci < len(r) else '')) for r in rows_local]
                                            # if stored_qty exists, insert it as the first quantity row so exported table reflects edited qty
                                            try:
                                                if stored_qty is not None:
                                                    csv_shown_vals.insert(0, ("대수(Q'ty)", str(stored_qty)))
                                                else:
                                                    csv_shown_vals.insert(0, ("대수(Q'ty)", "1"))
                                            except Exception:
                                                pass
                                            for data_row in rows_local[1:]:
                                                if ci < len(data_row) and data_row[ci] is not None and str(data_row[ci]).strip() != "":
                                                    matched_val = data_row[ci]
                                                    break

                        # prepare table rows list
                        for t0, v0 in csv_shown_vals:
                            table_rows_for_export.append((str(t0).strip(), str(v0).strip()))
                except Exception:
                    matched_col = ''
                    matched_val = ''
                    table_rows_for_export = []

                export_rows.append([
                    name,
                    str(hvac_type),
                    hvac_detail_text,
                    area_val,
                    norm_val,
                    equip_val,
                    matched_col,
                    matched_val,
                    table_rows_for_export
                ])
            except Exception:
                # skip problematic label but continue
                continue

        # Build final header with Table columns expanded to maximum seen
        max_table_pairs = 0
        for r in export_rows[1:]:
            trows = r[8] if len(r) > 8 else []
            if trows and isinstance(trows, list):
                max_table_pairs = max(max_table_pairs, len(trows))

        # If we have only the base header and no room rows, show diagnostics and stop
        if len(export_rows) <= 1:
            try:
                cnt = len(getattr(rc, 'generated_space_labels', []))
                rows_diag = []
                for lab in getattr(rc, 'generated_space_labels', []):
                    try:
                        keys = list(lab.keys())
                    except Exception:
                        keys = []
                    try:
                        n = rc.canvas.itemcget(lab.get('name_id', -1), 'text')
                    except Exception:
                        n = '<err>'
                    try:
                        a = rc.canvas.itemcget(lab.get('area_id', -1), 'text')
                    except Exception:
                        a = '<err>'
                    try:
                        hv = lab.get('hvac_type', '<no>')
                    except Exception:
                        hv = '<err>'
                    try:
                        hd = lab.get('hvac_detail_text', lab.get('hvac_detail', ''))
                    except Exception:
                        hd = '<err>'
                    rows_diag.append(f"keys={keys[:10]} name={n!s} area={a!s} hvac={hv!s} detail={hd!s}")

                diag_text = f"내보낼 실별 데이터가 없습니다. 생성된 라벨 수: {cnt}\n\n" + "\n".join(rows_diag[:20])
                if len(diag_text) > 2500:
                    diag_text = diag_text[:2500] + "\n..."
                messagebox.showinfo('데이터 없음 - 진단', diag_text)
            except Exception:
                messagebox.showinfo('데이터 없음', '내보낼 실별 데이터가 없습니다. 캔버스의 라벨을 확인하세요.')
            return

        final_header = base_header[:]
        for i in range(1, max_table_pairs + 1):
            final_header.append(f"Table_{i}_Title")
            final_header.append(f"Table_{i}_Value")

        # --- Show preview window with multiple tabs (like Excel sheets): pivot + per-room tabs ---
        try:
            # ensure any transient overlay is removed so the dialog is visible
            try:
                self._destroy_total_overlay()
            except Exception:
                pass
            pv = tk.Toplevel(self.root)
            try:
                pv.lift()
                try:
                    pv.wm_attributes('-topmost', True)
                    pv.after(60, lambda: pv.wm_attributes('-topmost', False))
                except Exception:
                    pass
            except Exception:
                pass
            pv.title("장비일람표 미리보기")
            pv.geometry("1000x520")

            from tkinter import ttk
            nb = ttk.Notebook(pv)
            nb.pack(fill=tk.BOTH, expand=True)

            # Prepare room maps (title->value) and orders
            rooms = []
            room_maps = []
            room_title_orders = []
            for r in export_rows[1:]:
                try:
                    base = r[:8]
                    room_name = str(base[0]) if base and base[0] is not None else ''
                    rooms.append(room_name)
                    tlist = r[8] if len(r) > 8 else []
                    m = {}
                    order = []
                    for (t0, v0) in (tlist or []):
                        key = str(t0)
                        if key not in m:
                            order.append(key)
                        m[key] = str(v0)
                    room_maps.append(m)
                    room_title_orders.append(order)
                except Exception:
                    rooms.append('')
                    room_maps.append({})
                    room_title_orders.append([])

            # global title ordering
            global_titles = []
            seen = set()
            for order in room_title_orders:
                for t in order:
                    if t not in seen:
                        seen.add(t)
                        global_titles.append(t)

            # Pivot tab
            pivot_frame = tk.Frame(nb)
            nb.add(pivot_frame, text='Pivot')

            pivot_fr = tk.Frame(pivot_frame)
            pivot_fr.pack(fill=tk.BOTH, expand=True)

            # Treeview for pivot
            pivot_cols = ['항목'] + rooms
            tree = ttk.Treeview(pivot_fr, columns=[f"c{i}" for i in range(len(pivot_cols))], show='headings')
            for i, h in enumerate(pivot_cols):
                tree.heading(f"c{i}", text=h)
                tree.column(f"c{i}", width=160 if i == 0 else 120, anchor='w')

            vsb = ttk.Scrollbar(pivot_fr, orient=tk.VERTICAL, command=tree.yview)
            hsb = ttk.Scrollbar(pivot_fr, orient=tk.HORIZONTAL, command=tree.xview)
            tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
            tree.grid(row=0, column=0, sticky='nsew')
            vsb.grid(row=0, column=1, sticky='ns')
            hsb.grid(row=1, column=0, sticky='ew')
            pivot_fr.rowconfigure(0, weight=1)
            pivot_fr.columnconfigure(0, weight=1)

            # First row: 공간이름
            try:
                tree.insert('', tk.END, values=['공간이름'] + rooms)
            except Exception:
                pass

            for title in global_titles:
                rowvals = [title]
                for rm in room_maps:
                    rowvals.append(rm.get(title, ''))
                try:
                    tree.insert('', tk.END, values=rowvals)
                except Exception:
                    continue

            # Group tabs by equipment type (hvac_detail_text if present else hvac_text/unknown)
            equip_groups = {}
            # determine equipment label per room from export_rows (parallel to rooms list)
            for i, r in enumerate(export_rows[1:]):
                try:
                    equip_label = r[2] if len(r) > 2 and r[2] else ''
                except Exception:
                    equip_label = ''
                if not equip_label:
                    # fallback to hvac text or generic
                    try:
                        equip_label = r[5] if len(r) > 5 and r[5] else ''
                    except Exception:
                        equip_label = ''
                if not equip_label:
                    equip_label = 'Unknown'
                equip_groups.setdefault(equip_label, []).append(i)

            # create one tab per equipment type
            for equip_label, idx_list in equip_groups.items():
                try:
                    gf = tk.Frame(nb)
                    nb.add(gf, text=equip_label)
                    gfr = tk.Frame(gf)
                    gfr.pack(fill=tk.BOTH, expand=True)

                    # collect group room names and maps
                    g_rooms = [rooms[i] for i in idx_list]
                    g_maps = [room_maps[i] for i in idx_list]
                    g_orders = [room_title_orders[i] for i in idx_list]

                    # determine group titles order
                    g_titles = []
                    seen_g = set()
                    for ordl in g_orders:
                        for t in ordl:
                            if t not in seen_g:
                                seen_g.add(t)
                                g_titles.append(t)

                    # Treeview for this equipment group: pivoted
                    cols = ['항목'] + g_rooms
                    tv = ttk.Treeview(gfr, columns=[f"c{i}" for i in range(len(cols))], show='headings')
                    for i, h in enumerate(cols):
                        tv.heading(f"c{i}", text=h)
                        tv.column(f"c{i}", width=160 if i == 0 else 120, anchor='w')

                    vs = ttk.Scrollbar(gfr, orient=tk.VERTICAL, command=tv.yview)
                    hs = ttk.Scrollbar(gfr, orient=tk.HORIZONTAL, command=tv.xview)
                    tv.configure(yscrollcommand=vs.set, xscrollcommand=hs.set)
                    tv.grid(row=0, column=0, sticky='nsew')
                    vs.grid(row=0, column=1, sticky='ns')
                    hs.grid(row=1, column=0, sticky='ew')
                    gfr.rowconfigure(0, weight=1)
                    gfr.columnconfigure(0, weight=1)

                    # first row: 공간이름
                    try:
                        tv.insert('', tk.END, values=['공간이름'] + g_rooms)
                    except Exception:
                        pass

                    # rows: group titles
                    for t in g_titles:
                        rowvals = [t]
                        for gm in g_maps:
                            rowvals.append(gm.get(t, ''))
                        try:
                            tv.insert('', tk.END, values=rowvals)
                        except Exception:
                            continue
                except Exception:
                    continue

            # buttons area
            btnf = tk.Frame(pv)
            btnf.pack(fill=tk.X, pady=6)
            exp_btn = tk.Button(btnf, text="Export (저장)...", command=lambda: pv.destroy())
            exp_btn.pack(side=tk.LEFT, padx=8)
            close_btn = tk.Button(btnf, text="Close", command=pv.destroy)
            close_btn.pack(side=tk.RIGHT, padx=8)
        except Exception:
            pass

        # Ask user where to save .xlsx
        from tkinter import filedialog
        fp = filedialog.asksaveasfilename(parent=self.root, defaultextension='.xlsx', filetypes=[('Excel files', '*.xlsx'), ('All files', '*.*')], title='장비일람표 저장 (.xlsx)')
        if not fp:
            return

        # Try to save as .xlsx; fallback to CSV if openpyxl not available
        try:
            try:
                import openpyxl
                from openpyxl import Workbook
                openpyxl_path = getattr(openpyxl, '__file__', None)
            except Exception:
                # fallback to CSV
                import csv, sys
                csv_fp = fp
                if csv_fp.lower().endswith('.xlsx'):
                    csv_fp = csv_fp[:-5] + '.csv'
                # write CSV with BOM so Excel (Windows) recognizes UTF-8 Korean text
                with open(csv_fp, 'w', newline='', encoding='utf-8-sig') as cf:
                    writer = csv.writer(cf)
                    writer.writerow(final_header)
                    for r in export_rows[1:]:
                        base = r[:8]
                        tlist = r[8] if len(r) > 8 else []
                        row_out = list(base)
                        for (t0, v0) in tlist:
                            row_out.append(t0)
                            row_out.append(v0)
                        while len(row_out) < len(final_header):
                            row_out.append("")
                        writer.writerow(row_out)
                messagebox.showinfo('저장 완료 (CSV)', f"openpyxl이 없어 CSV로 저장했습니다: {csv_fp}\nPython: {sys.executable}")
                return

            wb = Workbook()
            ws = wb.active
            ws.title = '장비일람표'
            ws.append(final_header)
            for r in export_rows[1:]:
                base = r[:8]
                tlist = r[8] if len(r) > 8 else []
                row_out = list(base)
                for (t0, v0) in tlist:
                    row_out.append(t0)
                    row_out.append(v0)
                while len(row_out) < len(final_header):
                    row_out.append("")
                ws.append(row_out)
            wb.save(fp)
            try:
                openpyxl_info = openpyxl_path
            except Exception:
                openpyxl_info = None
            messagebox.showinfo('저장 완료', f'장비일람표를 저장했습니다: {fp}\nPython: {sys.executable}\nopenpyxl: {openpyxl_info}')
        except Exception as e:
            messagebox.showerror('저장 오류', f'파일 저장 중 오류가 발생했습니다:\n{e}')
 
    def get_current_palette(self) -> Palette | None:
        if not self.notebook.tabs():
            return None
        idx = self.notebook.index(self.notebook.select())
        if 0 <= idx < len(self.palettes):
            return self.palettes[idx]
        return None

    def add_new_tab(self):
        tab = tk.Frame(self.notebook)
        self.notebook.add(tab, text=f"팔레트 {len(self.palettes)+1}")
        self.notebook.select(len(self.palettes))
        rc = Palette(tab, app=self)
        self.palettes.append(rc)

    def delete_current_tab(self):
        if not self.palettes:
            return

        current_index = self.notebook.index(self.notebook.select())
        if len(self.palettes) == 1:
            messagebox.showinfo(
                "삭제 불가",
                "마지막 팔레트는 삭제할 수 없습니다.\n새 팔레트를 추가한 후 삭제해 주세요."
            )
            return

        answer = messagebox.askyesno(
            "팔레트 삭제 확인",
            "현재 선택된 팔레트를 정말로 삭제하시겠습니까?\n"
            "이 작업은 되돌릴 수 없습니다."
        )
        if not answer:
            return

        rc_to_delete = self.palettes[current_index]
        rc_to_delete.shapes.clear()
        rc_to_delete.generated_space_labels.clear()
        rc_to_delete.canvas.delete("all")
        rc_to_delete.highlight_line_id = None
        rc_to_delete.tooltip_id = None
        rc_to_delete.corner_highlight_id = None
        rc_to_delete.active_shape = None
        rc_to_delete.active_side_name = None

        tabs = self.notebook.tabs()
        if 0 <= current_index < len(tabs):
            tab_id = tabs[current_index]
            self.notebook.forget(tab_id)
        if 0 <= current_index < len(self.palettes):
            del self.palettes[current_index]

    def clear_current_palette(self):
        rc = self.get_current_palette()
        if not rc:
            return

        answer = messagebox.askyesno("팔레트 초기화 확인", "현재 팔레트의 모든 내용을 삭제하고 처음부터 다시 그리시겠습니까?")
        if not answer:
            return

        rc.shapes.clear()
        # delete all items except those tagged as 'grid' so the grid remains visible
        try:
            all_items = list(rc.canvas.find_all())
            for item in all_items:
                try:
                    tags = rc.canvas.gettags(item)
                    if 'grid' in tags:
                        continue
                    rc.canvas.delete(item)
                except Exception:
                    continue
        except Exception:
            try:
                rc.canvas.delete("all")
            except Exception:
                pass
        rc.generated_space_labels.clear()
        rc.highlight_line_id = None
        rc.tooltip_id = None
        rc.corner_highlight_id = None
        rc.active_shape = None
        rc.active_side_name = None

        rc.canvas.tag_bind("dim_width", "<Button-1>", rc.on_dim_width_click)
        rc.canvas.tag_bind("dim_height", "<Button-1>", rc.on_dim_height_click)
        rc.canvas.tag_bind("space_name", "<Button-1>", rc.on_space_name_click)
        rc.canvas.tag_bind("space_heat_norm", "<Button-1>", rc.on_space_heat_norm_click)
        rc.canvas.tag_bind("space_heat_equip", "<Button-1>", rc.on_space_heat_equip_click)

        self.update_selected_area_label(rc)

    def draw_square_from_area_current(self):
        rc = self.get_current_palette()
        if not rc:
            return
        s = self.area_entry.get().strip()
        try:
            area = float(s)
        except ValueError:
            return
        rc.draw_square_from_area(area)

    def undo_current(self):
        rc = self.get_current_palette()
        if rc:
            rc.undo()

    def auto_generate_current(self):
        rc = self.get_current_palette()
        if rc:
            rc.auto_generate_space_labels()

    def save_current(self):
        rc = self.get_current_palette()
        if not rc:
            return
        file_path = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON 파일", "*.json"), ("모든 파일", "*.*")]
        )
        if not file_path:
            return
        data = rc.to_dict()
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            messagebox.showinfo("저장 완료", f"현재 팔레트를 저장했습니다.\n{file_path}")
        except Exception as e:
            messagebox.showerror("저장 오류", f"파일 저장 중 오류가 발생했습니다.\n{e}")

    def load_current(self):
        rc = self.get_current_palette()
        if not rc:
            return
        file_path = filedialog.askopenfilename(
            defaultextension=".json",
            filetypes=[("JSON 파일", "*.json"), ("모든 파일", "*.*")]
        )
        if not file_path:
            return
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            rc.load_from_dict(data)
            messagebox.showinfo("불러오기 완료", f"팔레트를 불러왔습니다.\n{file_path}")
        except Exception as e:
            messagebox.showerror("불러오기 오류", f"파일 불러오기 중 오류가 발생했습니다.\n{e}")

    def update_selected_area_label(self, rc: Palette | None):
        if not rc or not rc.active_shape:
            self.area_label_var.set("선택 도형 면적: - m²")
            return
        x1, y1, x2, y2 = rc.active_shape.coords
        w = rc.pixel_to_meter(x2 - x1)
        h = rc.pixel_to_meter(y2 - y1)
        self.area_label_var.set(f"선택 도형 면적: {w*h:.3f} m²")

    def _on_check_diffusers(self):
        rc = self.get_current_palette()
        if not rc:
            messagebox.showinfo("정보", "활성화된 팔레트가 없습니다.")
            return
        room_name = simpledialog.askstring("룸 선택", "검사할 룸 이름을 입력하세요:", initialvalue="Room 6")
        if not room_name:
            return
        assigned_count, inside_count, outside_count, outside_ids = rc.check_diffusers_in_room(room_name)
        msg = (f"{room_name}: 할당된 디퓨저 {assigned_count}개\n"
               f"공간 기준 내부 {inside_count}개, 외부 {outside_count}개")
        messagebox.showinfo("디퓨저 점검 결과", msg)
        # highlight outside points in red briefly
        for did in outside_ids:
            try:
                rc.canvas.itemconfig(did, fill="red")
            except Exception:
                pass
    
    def cloud_upload_current(self):
        """현재 팔레트를 클라우드에 업로드"""
        rc = self.get_current_palette()
        if not rc:
            messagebox.showinfo("정보", "활성화된 팔레트가 없습니다.")
            return
        
        # 임시 파일에 저장 (보안: 고유한 임시 파일 생성)
        import tempfile
        temp_fd, temp_file = tempfile.mkstemp(suffix=".json", prefix="palette_")
        
        try:
            data = rc.to_dict()
            # Close the file descriptor and write to the file
            os.close(temp_fd)
            with open(temp_file, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            
            # 클라우드 업로드 다이얼로그 열기
            from cloud_ui import CloudUploadDialog
            dialog = CloudUploadDialog(self.root, file_path=temp_file, data_type="drawing")
            self.root.wait_window(dialog)
            
            # 임시 파일 삭제
            try:
                os.remove(temp_file)
            except Exception:
                pass
                
        except Exception as e:
            messagebox.showerror("오류", f"클라우드 업로드 준비 중 오류가 발생했습니다:\n{e}")
    
    def cloud_browser(self):
        """클라우드 브라우저 열기"""
        try:
            from cloud_ui import CloudBrowserDialog
            dialog = CloudBrowserDialog(self.root)
            self.root.wait_window(dialog)
        except Exception as e:
            messagebox.showerror("오류", f"클라우드 브라우저를 여는 중 오류가 발생했습니다:\n{e}")


if __name__ == "__main__":
    root = tk.Tk()
    app = ResizableRectApp(root)
    root.mainloop()
